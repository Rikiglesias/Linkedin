[{"filePath":"C:\\Users\\albie\\Desktop\\Programmi\\Linkedin\\src\\workers\\inviteWorker.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'e' is defined but never used.","line":108,"column":18,"messageId":"unusedVar","endLine":108,"endColumn":19}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Page } from 'playwright';\nimport { detectChallenge, humanDelay, humanMouseMove, humanType, simulateHumanReading } from '../browser';\nimport { transitionLead } from '../core/leadStateService';\nimport { getLeadById, incrementDailyStat, incrementListDailyStat, updateLeadScrapedContext, updateLeadPromptVariant } from '../core/repositories';\nimport { SELECTORS } from '../selectors';\nimport { InviteJobPayload, LeadRecord } from '../types/domain';\nimport { WorkerContext } from './context';\nimport { ChallengeDetectedError, RetryableWorkerError } from './errors';\nimport { isSalesNavigatorUrl } from '../linkedinUrl';\nimport { config } from '../config';\nimport { buildPersonalizedInviteNote } from '../ai/inviteNotePersonalizer';\nimport { pauseAutomation } from '../risk/incidentManager';\nimport { bridgeDailyStat, bridgeLeadStatus } from '../cloud/cloudBridge';\n\nasync function clickConnectOnProfile(page: Page): Promise<boolean> {\n    const primaryBtn = page.locator(SELECTORS.connectButtonPrimary).first();\n    if (await primaryBtn.count() > 0) {\n        await humanMouseMove(page, SELECTORS.connectButtonPrimary);\n        await humanDelay(page, 120, 320);\n        await primaryBtn.click();\n        return true;\n    }\n\n    const moreBtn = page.locator(SELECTORS.moreActionsButton).first();\n    if (await moreBtn.count() > 0) {\n        await humanMouseMove(page, SELECTORS.moreActionsButton);\n        await humanDelay(page, 120, 300);\n        await moreBtn.click();\n        await humanDelay(page, 700, 1300);\n        const connectInMenu = page.locator(SELECTORS.connectInMoreMenu).first();\n        if (await connectInMenu.count() > 0) {\n            await humanMouseMove(page, SELECTORS.connectInMoreMenu);\n            await humanDelay(page, 120, 300);\n            await connectInMenu.click();\n            return true;\n        }\n    }\n\n    return false;\n}\n\nasync function detectInviteProof(page: Page): Promise<boolean> {\n    const pendingCount = await page.locator(SELECTORS.invitePendingIndicators).count();\n    if (pendingCount > 0) {\n        return true;\n    }\n\n    const pageText = await page.textContent('body').catch(() => '');\n    if (!pageText) {\n        return false;\n    }\n    return /invitation sent|in attesa|pending/i.test(pageText);\n}\n\nasync function detectWeeklyInviteLimit(page: Page): Promise<boolean> {\n    const selectorCount = await page.locator(SELECTORS.inviteWeeklyLimitSignals).count();\n    if (selectorCount > 0) {\n        return true;\n    }\n\n    const pageText = await page.textContent('body').catch(() => '');\n    if (!pageText) {\n        return false;\n    }\n    return /weekly invitation limit|limite settimanale(?: degli)? inviti|hai raggiunto il limite settimanale/i.test(pageText);\n}\n\n/**\n * Tenta di inviare l'invito con nota personalizzata (se INVITE_WITH_NOTE=true).\n * Flusso:\n *   1. Cerca il bottone \"Add a note\" nel modale\n *   2. Scrive la nota via humanType\n *   3. Clicca \"Send\" dal modale\n * Se il bottone \"Add a note\" non ├¿ presente, ricade su sendWithoutNote.\n * Ritorna se l'invio ├¿ avvenuto con nota e la source della nota (template/ai).\n */\nasync function handleInviteModal(\n    page: Page,\n    lead: LeadRecord,\n    dryRun: boolean,\n    localDate: string,\n): Promise<{ sentWithNote: boolean; noteSource: 'template' | 'ai' | null; variant?: string | null }> {\n    if (dryRun) return { sentWithNote: false, noteSource: null, variant: null };\n\n    // Controlla se c'├¿ il bottone \"Add a note\" (con retry breve se il modale sta caricando)\n    const addNoteBtn = page.locator(SELECTORS.addNoteButton).first();\n    let canAddNote = await addNoteBtn.count() > 0;\n    if (config.inviteWithNote && !canAddNote) {\n        await page.waitForSelector(SELECTORS.addNoteButton, { timeout: 2000 }).catch(() => null);\n        canAddNote = await addNoteBtn.count() > 0;\n    }\n\n    if (config.inviteWithNote && canAddNote) {\n        await humanMouseMove(page, SELECTORS.addNoteButton);\n        await humanDelay(page, 150, 350);\n        await addNoteBtn.click();\n        await humanDelay(page, 600, 1200);\n\n        // Scrivi la nota nella textarea del modale\n        const generatedNote = await buildPersonalizedInviteNote(lead);\n        if (generatedNote.variant) {\n            await updateLeadPromptVariant(lead.id, generatedNote.variant);\n            lead.invite_prompt_variant = generatedNote.variant;\n        }\n\n        try {\n            await humanType(page, SELECTORS.noteTextarea, generatedNote.note);\n        } catch (e) {\n            await incrementDailyStat(localDate, 'selector_failures');\n            throw new RetryableWorkerError('Impossibile digitare la nota', 'TYPE_ERROR');\n        }\n\n        await humanDelay(page, 400, 800); // Changed from context.session.page to page\n\n        const sendWithNote = page.locator(SELECTORS.sendWithNote).first(); // Changed from context.session.page to page\n        if (await sendWithNote.count() > 0) {\n            await humanMouseMove(page, SELECTORS.sendWithNote); // Changed from context.session.page to page\n            await humanDelay(page, 150, 400); // Changed from context.session.page to page\n\n            if (!dryRun) { // Changed from context.dryRun to dryRun\n                await sendWithNote.click();\n            } else {\n                console.log(`[DRY RUN] Inviato invito a ${lead.linkedin_url} (nota: ${generatedNote.source} - var: ${generatedNote.variant || 'none'})`);\n            }\n\n            return { sentWithNote: true, noteSource: generatedNote.source, variant: generatedNote.variant };\n        }\n\n        // Se il bottone Send del modale non ├¿ trovato, ├¿ un errore bloccante\n        await incrementDailyStat(localDate, 'selector_failures');\n        throw new RetryableWorkerError('Send con nota non trovato nel modale', 'SEND_WITH_NOTE_NOT_FOUND');\n    }\n\n    // Fallback: invia senza nota\n    const sendWithoutNote = page.locator(SELECTORS.sendWithoutNote).first();\n    if (await sendWithoutNote.count() > 0) {\n        await humanMouseMove(page, SELECTORS.sendWithoutNote);\n        await humanDelay(page, 120, 300);\n        await sendWithoutNote.click();\n        return { sentWithNote: false, noteSource: null, variant: null };\n    }\n\n    const fallback = page.locator(SELECTORS.sendFallback).first();\n    if (await fallback.count() > 0) {\n        await humanMouseMove(page, SELECTORS.sendFallback);\n        await humanDelay(page, 120, 300);\n        await fallback.click();\n        return { sentWithNote: false, noteSource: null, variant: null };\n    }\n\n    await incrementDailyStat(localDate, 'selector_failures');\n    throw new RetryableWorkerError('Conferma invito senza nota non trovata', 'SEND_BUTTON_NOT_FOUND');\n}\n\nexport async function processInviteJob(payload: InviteJobPayload, context: WorkerContext): Promise<void> {\n    const lead = await getLeadById(payload.leadId);\n    if (!lead) {\n        throw new RetryableWorkerError(`Lead ${payload.leadId} non trovato`, 'LEAD_NOT_FOUND');\n    }\n\n    if (lead.status === 'NEW' || lead.status === 'PENDING') {\n        await transitionLead(lead.id, 'READY_INVITE', 'new_lead_promoted');\n    }\n\n    if (lead.status !== 'READY_INVITE' && lead.status !== 'NEW' && lead.status !== 'PENDING') {\n        return;\n    }\n\n    if (isSalesNavigatorUrl(lead.linkedin_url)) {\n        await transitionLead(lead.id, 'BLOCKED', 'salesnav_url_requires_profile_invite');\n        return;\n    }\n\n    await context.session.page.goto(lead.linkedin_url, { waitUntil: 'domcontentloaded' });\n    await simulateHumanReading(context.session.page);\n\n    if (await detectChallenge(context.session.page)) {\n        throw new ChallengeDetectedError();\n    }\n\n    // --- PHASE 7: AI Context Extraction (About & Experience) ---\n    try {\n        let extractedAbout: string | null = null;\n        let extractedExperience: string | null = null;\n\n        const aboutLocator = context.session.page.locator(SELECTORS.aboutSection).first();\n        if (await aboutLocator.isVisible()) {\n            extractedAbout = (await aboutLocator.innerText()).trim();\n        }\n\n        const expLocator = context.session.page.locator(SELECTORS.experienceSection).first();\n        if (await expLocator.isVisible()) {\n            extractedExperience = (await expLocator.innerText()).trim();\n        }\n\n        if (extractedAbout || extractedExperience) {\n            await updateLeadScrapedContext(lead.id, extractedAbout || null, extractedExperience || null);\n            lead.about = extractedAbout || null;\n            lead.experience = extractedExperience || null;\n\n            // Sync with Cloud\n            bridgeLeadStatus(lead.linkedin_url, lead.status, {\n                about: extractedAbout || null,\n                experience: extractedExperience || null\n            });\n        }\n    } catch (e) {\n        // Estrazione Opzionale. Ignorare errori di timeout o parsing DOM\n        console.warn(`[WARN] Impossibile estrarre contesto AI per lead ${lead.id}:`, e);\n    }\n    // --- END PHASE 7 ---\n\n    const connectClicked = await clickConnectOnProfile(context.session.page);\n    if (!connectClicked) {\n        await incrementDailyStat(context.localDate, 'selector_failures');\n        await transitionLead(lead.id, 'SKIPPED', 'connect_not_found');\n        return;\n    }\n\n    await humanDelay(context.session.page, 900, 1800);\n\n    const inviteResult = await handleInviteModal(\n        context.session.page,\n        lead,\n        context.dryRun,\n        context.localDate,\n    );\n\n    if (!context.dryRun) {\n        const weeklyLimitReached = await detectWeeklyInviteLimit(context.session.page);\n        if (weeklyLimitReached) {\n            await pauseAutomation(\n                'WEEKLY_INVITE_LIMIT_REACHED',\n                {\n                    leadId: lead.id,\n                    linkedinUrl: lead.linkedin_url,\n                    accountId: context.accountId,\n                },\n                7 * 24 * 60\n            );\n            throw new RetryableWorkerError('Limite settimanale inviti raggiunto', 'WEEKLY_LIMIT_REACHED');\n        }\n    }\n\n    await humanDelay(context.session.page, 1200, 2200);\n    const proofOfSend = context.dryRun ? true : await detectInviteProof(context.session.page);\n    if (!proofOfSend) {\n        throw new RetryableWorkerError('Proof-of-send non rilevato', 'NO_PROOF_OF_SEND');\n    }\n\n    await transitionLead(lead.id, 'INVITED', context.dryRun ? 'invite_dry_run' : 'invite_sent', {\n        dryRun: context.dryRun,\n        withNote: inviteResult.sentWithNote,\n        withNoteSource: inviteResult.noteSource,\n        variant: inviteResult.variant || null\n    });\n    await incrementDailyStat(context.localDate, 'invites_sent');\n    await incrementListDailyStat(context.localDate, lead.list_name, 'invites_sent');\n    // Cloud sync non-bloccante\n    bridgeLeadStatus(lead.linkedin_url, 'INVITED', {\n        invited_at: new Date().toISOString(),\n        invite_prompt_variant: inviteResult.variant || null,\n        invite_note_sent: inviteResult.sentWithNote ? 'yes' : 'no'\n    });\n    bridgeDailyStat(context.localDate, context.accountId, 'invites_sent');\n}\n","usedDeprecatedRules":[{"ruleId":"semi","replacedBy":["@stylistic/semi"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"11.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin","url":"https://eslint.style"},"rule":{"name":"semi","url":"https://eslint.style/rules/semi"}}]}}]}]
