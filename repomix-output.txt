This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where line numbers have been added.

# File Summary

## Purpose
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A header with the file path (## File: path/to/file)
  b. The full contents of the file in a code block

## Usage Guidelines
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
- Pay special attention to the Repository Description. These contain important context and guidelines specific to this project.

## Notes
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: src/**/*, package.json, tsconfig.json, eslint.config.js, .env.example, ROADMAP.md, INTEGRATIONS.md, SECURITY.md
- Files matching these patterns are excluded: node_modules/**, dist/**, data/**, .env, *.log, package-lock.json, repomix-output.txt, .git/**
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Line numbers have been added to the beginning of each line
- Files are sorted by Git change count (files with more changes are at the bottom)

# User Provided Header
LinkedIn Bot Codebase - Condiviso per analisi AI

# Directory Structure
```
.env.example
eslint.config.js
INTEGRATIONS.md
package.json
ROADMAP.md
SECURITY.md
src/acceptanceChecker.ts
src/accountManager.ts
src/ai/guardian.ts
src/ai/inviteNotePersonalizer.ts
src/ai/messagePersonalizer.ts
src/ai/openaiClient.ts
src/browser.ts
src/config.ts
src/connectWorkflow.ts
src/core/audit.ts
src/core/companyEnrichment.ts
src/core/doctor.ts
src/core/jobRunner.ts
src/core/leadStateService.ts
src/core/orchestrator.ts
src/core/repositories.ts
src/core/salesNavigatorSync.ts
src/core/scheduler.ts
src/csvImporter.ts
src/db.ts
src/db/migrations/001_core.sql
src/db/migrations/002_legacy_status_backfill.sql
src/db/migrations/003_add_person_fields.sql
src/db/migrations/004_list_campaign_controls.sql
src/db/migrations/005_performance_indexes.sql
src/db/migrations/006_company_targets.sql
src/db/migrations/007_company_target_tracking.sql
src/db/migrations/008_runtime_locks.sql
src/db/migrations/009_site_check_tracking.sql
src/db/migrations/010_salesnav_lists.sql
src/index.ts
src/linkedinUrl.ts
src/messages.ts
src/messagingWorkflow.ts
src/models.ts
src/noteGenerator.ts
src/proxyManager.ts
src/risk/incidentManager.ts
src/risk/riskEngine.ts
src/salesnav/listActions.ts
src/salesnav/listScraper.ts
src/security/filesystem.ts
src/security/redaction.ts
src/selectors.ts
src/sync/eventSync.ts
src/sync/supabase.schema.sql
src/sync/supabaseSyncWorker.ts
src/sync/webhookSyncWorker.ts
src/telemetry/alerts.ts
src/telemetry/logger.ts
src/tests/e2eDry.ts
src/tests/integration.ts
src/tests/unit.ts
src/types/domain.ts
src/validation/messageValidator.ts
src/workers/acceptanceWorker.ts
src/workers/context.ts
src/workers/errors.ts
src/workers/inviteWorker.ts
src/workers/messageWorker.ts
src/workers/randomActivityWorker.ts
tsconfig.json
```

# Files

## File: eslint.config.js
````javascript
 1: const typescriptEslintEslintPlugin = require("@typescript-eslint/eslint-plugin");
 2: const typescriptEslintParser = require("@typescript-eslint/parser");
 3: 
 4: module.exports = [
 5:     {
 6:         files: ["**/*.ts"],
 7:         languageOptions: {
 8:             parser: typescriptEslintParser,
 9:             parserOptions: {
10:                 ecmaVersion: "latest",
11:                 sourceType: "module",
12:             },
13:         },
14:         plugins: {
15:             "@typescript-eslint": typescriptEslintEslintPlugin,
16:         },
17:         rules: {
18:             "no-console": "off",
19:             "@typescript-eslint/no-unused-vars": "error",
20:             "@typescript-eslint/no-explicit-any": "error",
21:             "semi": ["error", "always"]
22:         },
23:     },
24: ];
````

## File: INTEGRATIONS.md
````markdown
 1: # Integrations Guide
 2: 
 3: This bot can export control-plane events from `outbox_events` to one sink at a time:
 4: - `SUPABASE` (table `cp_events`)
 5: - `WEBHOOK` (for n8n, Make, Pipedream, custom middleware)
 6: 
 7: Set the active sink with:
 8: 
 9: ```env
10: EVENT_SYNC_SINK=SUPABASE
11: ```
12: 
13: Allowed values: `SUPABASE`, `WEBHOOK`, `NONE`.
14: 
15: ## n8n Setup (recommended external orchestrator)
16: 
17: 1. Create a workflow with a `Webhook` trigger (POST).
18: 2. Add an auth guard step:
19:    - verify `x-signature-sha256` if `WEBHOOK_SYNC_SECRET` is configured
20:    - deduplicate by `x-idempotency-key`
21: 3. Route by `topic` (for example `lead.transition`, `lead.reconciled`, `scheduler.snapshot`, `incident.opened`).
22: 4. Add actions (alerts, CRM update, BI, ticketing, etc.).
23: 
24: Bot `.env` example:
25: 
26: ```env
27: EVENT_SYNC_SINK=WEBHOOK
28: WEBHOOK_SYNC_ENABLED=true
29: WEBHOOK_SYNC_URL=https://your-n8n-host/webhook/linkedin-events
30: WEBHOOK_SYNC_SECRET=replace_with_long_random_secret
31: WEBHOOK_SYNC_BATCH_SIZE=100
32: WEBHOOK_SYNC_TIMEOUT_MS=10000
33: WEBHOOK_SYNC_MAX_RETRIES=8
34: 
35: # Optional: disable Supabase sink if not used
36: SUPABASE_SYNC_ENABLED=false
37: ```
38: 
39: ## Payload format sent to Webhook sink
40: 
41: ```json
42: {
43:   "topic": "lead.transition",
44:   "payload": { "leadId": 123, "fromStatus": "READY_INVITE", "toStatus": "INVITED" },
45:   "idempotencyKey": "lead.transition:123:READY_INVITE:INVITED:invite_sent",
46:   "createdAt": "2026-02-25 20:10:00"
47: }
48: ```
49: 
50: Headers:
51: - `x-idempotency-key`
52: - `x-event-topic`
53: - `x-signature-sha256` (only if `WEBHOOK_SYNC_SECRET` is configured)
54: 
55: ## Operational commands
56: 
57: - Check sink status: `.\bot.ps1 sync-status`
58: - Force one sync batch: `.\bot.ps1 sync-run-once`
59: 
60: ## Notes
61: 
62: - Do not enable stealth/evasion tooling. Keep automation conservative and policy-safe.
63: - Keep only one active sink in production to avoid configuration ambiguity.
64: - If both sink toggles are enabled, `EVENT_SYNC_SINK` decides which sink is used.
````

## File: package.json
````json
 1: {
 2:   "name": "linkedin",
 3:   "version": "1.0.0",
 4:   "description": "",
 5:   "main": "index.js",
 6:   "scripts": {
 7:     "build": "tsc",
 8:     "lint": "eslint src/**/*.ts",
 9:     "typecheck": "tsc --noEmit",
10:     "conta-problemi": "npm run typecheck && npm run lint",
11:     "pre-modifiche": "npm run conta-problemi",
12:     "post-modifiche": "npm run conta-problemi",
13:     "helper-manuali": "echo 'Esegui le correzioni manuali come da policy'",
14:     "start": "ts-node src/index.ts",
15:     "test:unit": "ts-node src/tests/unit.ts",
16:     "test:integration": "ts-node src/tests/integration.ts",
17:     "test:e2e:dry": "ts-node src/tests/e2eDry.ts",
18:     "test": "npm run test:unit && npm run test:integration && npm run test:e2e:dry"
19:   },
20:   "keywords": [],
21:   "author": "",
22:   "license": "ISC",
23:   "type": "commonjs",
24:   "dependencies": {
25:     "@supabase/supabase-js": "^2.57.4",
26:     "csv-parser": "^3.2.0",
27:     "dotenv": "^17.3.1",
28:     "playwright": "^1.58.2",
29:     "sqlite": "^5.1.1",
30:     "sqlite3": "^5.1.7"
31:   },
32:   "devDependencies": {
33:     "@types/node": "^25.3.0",
34:     "@types/sqlite3": "^3.1.11",
35:     "@typescript-eslint/eslint-plugin": "^8.56.1",
36:     "@typescript-eslint/parser": "^8.56.1",
37:     "eslint": "^10.0.2",
38:     "ts-node": "^10.9.2",
39:     "typescript": "^5.9.3"
40:   }
41: }
````

## File: ROADMAP.md
````markdown
 1: # LinkedIn Bot Roadmap
 2: 
 3: ## Objective
 4: Build a safer, more reliable, and measurable end-to-end automation flow:
 5: - Source lists from DB/control-plane
 6: - Execute invite/check/message workflows with strict safeguards
 7: - Keep LinkedIn state and local DB in sync
 8: - Reduce operational risk with adaptive policies and incident controls
 9: 
10: ## Status Legend
11: - `todo`: not started
12: - `in_progress`: currently being implemented
13: - `done`: completed and verified
14: - `blocked`: waiting on external input/decision
15: 
16: ## Owners
17: - `YOU`: business decisions, account operation, approvals
18: - `AI`: implementation in codebase
19: - `JOINT`: requires both
20: 
21: ## Priority Roadmap
22: 
23: | ID | Priority | Area | Task | Owner | Status | Dependencies | Done Criteria |
24: |---|---|---|---|---|---|---|---|
25: | P0-01 | P0 | Security | Rotate `SUPABASE_SERVICE_ROLE_KEY` and update `.env` | YOU | todo | None | Old key revoked, new key active, bot works |
26: | P0-02 | P0 | Security | Verify no secrets in logs/outbox payloads | AI | todo | P0-01 | No sensitive token appears in runtime logs |
27: | P0-03 | P0 | Security | Confirm private permissions on DB/session folders | AI | todo | None | `data` paths protected and documented |
28: | P0-04 | P0 | Runtime Safety | Add global single-runner lock (no dual bot) | AI | done | None | Second process exits with lock message |
29: | P0-05 | P0 | Runtime Safety | Add lock heartbeat and stale-lock recovery | AI | done | P0-04 | Crashed lock auto-recovers safely |
30: | P0-06 | P0 | Runtime Safety | Run `doctor` automatically before each loop cycle | AI | done | None | Loop skips if health check fails |
31: | P0-07 | P0 | Risk Engine | Implement adaptive caps per list/account | AI | done | None | Budgets auto-adjust from recent KPIs |
32: | P0-08 | P0 | Risk Engine | Implement auto cooldown engine (48h/72h policy) | AI | done | P0-07 | Cooldown triggers after risk anomalies |
33: | P0-09 | P0 | Risk Engine | Enforce no-burst pacing policy | AI | done | P0-07 | No clustered spikes in job execution |
34: | P0-10 | P0 | Session Safety | Add session/IP/device consistency guard + auto-pause | AI | todo | None | Context drift triggers pause and incident |
35: 
36: | ID | Priority | Area | Task | Owner | Status | Dependencies | Done Criteria |
37: |---|---|---|---|---|---|---|---|
38: | P1-01 | P1 | Workflow | Schedule daily `site-check --fix` from autopilot | AI | done | P0-04 | Daily reconciliation runs automatically |
39: | P1-02 | P1 | Workflow | Improve LinkedIn-vs-DB state reconciliation rules | AI | done | P1-01 | Mismatch false positives reduced |
40: | P1-03 | P1 | Workflow | Add `REVIEW_REQUIRED` lead state for ambiguous cases | AI | todo | P1-02 | Unsafe transitions blocked for review |
41: | P1-04 | P1 | Workflow | Add pending invite hygiene policy (age-based) | JOINT | todo | P1-02 | Old pending invites handled by policy |
42: | P1-05 | P1 | Control Plane | Upgrade Supabase from sink-only to control-plane | AI | todo | P0-01 | Campaign config can be managed remotely |
43: | P1-06 | P1 | Control Plane | Implement bidirectional sync (Supabase <-> local) | AI | todo | P1-05 | Config/data parity verified |
44: | P1-07 | P1 | Observability | Add dashboard KPIs (funnel, risk, pending, acceptance) | AI | todo | P1-05 | KPI panel populated from live data |
45: | P1-08 | P1 | Lead Quality | Add lead scoring before invite scheduling | AI | todo | P0-07 | Low-score leads filtered/deprioritized |
46: | P1-09 | P1 | Enrichment | Add confidence score + review queue for enrichment | AI | todo | P1-03 | Low-confidence matches not auto-sent |
47: | P1-10 | P1 | Messaging | Add semantic similarity anti-duplication checks | AI | todo | None | Repetitive messages auto-blocked |
48: | P1-11 | P1 | Integrations | Add selectable event-sync sink (`SUPABASE`/`WEBHOOK`) for n8n/Make/Pipedream | AI | done | None | `sync-status` mostra sink attivo; `sync-run-once` supporta webhook |
49: | P1-12 | P1 | Workflow | Add automatic post-run state sync (invite/accept/message reconciliation) | AI | done | P1-02 | DB state auto-updated each run from site signals |
50: | P1-13 | P1 | AI | Add optional AI message personalization with template fallback | AI | done | None | Messages can be AI-personalized without blocking flow |
51: | P1-14 | P1 | AI | Add optional AI guardian for preemptive risk pause/watch decisions | AI | done | P0-07 | Guardian emits decision and can auto-pause on critical |
52: 
53: | ID | Priority | Area | Task | Owner | Status | Dependencies | Done Criteria |
54: |---|---|---|---|---|---|---|---|
55: | P2-01 | P2 | Audit | Add `campaign_runs` table and run-by-run telemetry | AI | todo | None | Every loop writes run summary |
56: | P2-02 | P2 | Alerts | Expand alerting on challenge/quarantine/backlog bursts | AI | todo | P2-01 | Alerts fire with actionable context |
57: | P2-03 | P2 | Incident Ops | Create incident runbook with auto actions | JOINT | todo | P2-02 | Clear SOP for pause/recover/resume |
58: | P2-04 | P2 | Reporting | Add automated daily summary report | AI | todo | P2-01 | Daily report produced reliably |
59: | P2-05 | P2 | Testing | Add tests for lock/cooldown/adaptive caps/reconcile | AI | todo | P0-04, P0-08, P1-02 | New tests pass in CI/local |
60: | P2-06 | P2 | Testing | Run realistic e2e dry-run scenarios | AI | todo | P2-05 | Dry-run validates full orchestration |
61: | P2-07 | P2 | Rollout | Canary rollout on one list for 7 days | JOINT | todo | P0 and P1 complete | Stable KPIs, no major incidents |
62: | P2-08 | P2 | Rollout | Controlled ramp-up policy with stop thresholds | JOINT | todo | P2-07 | Scaled traffic without safety regressions |
63: | P2-09 | P2 | Intelligence | Monthly review of official + community signals | JOINT | todo | None | Risk policy updated monthly |
64: 
65: ## Execution Sequence
66: 1. Complete all `P0` tasks first.
67: 2. Enable `P1` control-plane and workflow intelligence.
68: 3. Stabilize with `P2` testing, reporting, and rollout governance.
69: 
70: ## Immediate Next Actions
71: 1. `YOU`: rotate Supabase service key (`P0-01`).
72: 2. `AI`: harden secret/privacy controls in logs and runtime paths (`P0-02`, `P0-03`).
73: 3. `AI`: implement session/IP/device consistency guard with auto-pause (`P0-10`).
74: 4. `AI`: add `REVIEW_REQUIRED` guardrail state for ambiguous reconciliation (`P1-03`).
````

## File: SECURITY.md
````markdown
 1: # Security & Privacy Hardening
 2: 
 3: ## What is already hardened
 4: - No stealth/evasion browser plugins in runtime dependencies.
 5: - Automatic pause/quarantine on risk bursts.
 6: - Sensitive log redaction (`token`, `key`, `cookie`, JWT-like values).
 7: - Local session and DB storage created with private-permission best effort.
 8: - Privacy retention cleanup command to reduce stored historical data.
 9: - AI integration is fail-safe: if AI API fails, bot falls back to local template/heuristics.
10: 
11: ## Daily operator workflow
12: 1. `.\bot.ps1 doctor`
13: 2. `.\bot.ps1 status`
14: 3. Run jobs only if `sessionLoginOk=true`, `quarantine=false`, `pause.paused=false`.
15: 
16: ## Emergency controls
17: - Pause immediately: `.\bot.ps1 pause 180 suspicious_activity`
18: - Resume: `.\bot.ps1 resume`
19: - Remove quarantine after manual checks: `.\bot.ps1 unquarantine`
20: - Inspect incidents: `.\bot.ps1 incidents`
21: - Resolve incident: `.\bot.ps1 incident-resolve <id>`
22: 
23: ## Privacy retention
24: - Default retention from `.env` via `RETENTION_DAYS` (recommended: `45`).
25: - Cleanup old operational data:
26:   - `.\bot.ps1 privacy-cleanup`
27:   - `.\bot.ps1 privacy-cleanup --days 30`
28: 
29: This cleanup removes only old operational history (`run_logs`, `job_attempts`, `lead_events`, `message_history`, delivered `outbox_events`, resolved incidents).  
30: It does not delete active leads/jobs.
31: 
32: ## Host machine recommendations
33: - Keep OS and browser updated automatically.
34: - Use full-disk encryption (BitLocker on Windows).
35: - Keep a dedicated OS user profile for automation.
36: - Use a password manager and enable 2FA on LinkedIn and email.
37: - Restrict remote-access software and unknown browser extensions.
38: 
39: ## AI key hygiene (if enabled)
40: - Keep `OPENAI_API_KEY` only in local `.env` (never in repository files).
41: - Rotate key periodically and after any suspected leak.
42: - Keep `AI_PERSONALIZATION_ENABLED=false` / `AI_GUARDIAN_ENABLED=false` until dry-run validation is complete.
43: 
44: ## Dependency note
45: `npm audit` currently reports high advisories related to `sqlite3` build-chain dependencies (`node-gyp` / `tar`) during install tooling.  
46: The runtime currently requires `sqlite3`; monitor upstream advisories and patch quickly when a safe upgrade path appears.
````

## File: src/acceptanceChecker.ts
````typescript
1: import { runWorkflow } from './core/orchestrator';
2: 
3: export async function runAcceptanceChecker(): Promise<void> {
4:     await runWorkflow({
5:         workflow: 'check',
6:         dryRun: false,
7:     });
8: }
````

## File: src/accountManager.ts
````typescript
  1: import { AccountProfileConfig, config } from './config';
  2: import { ProxyConfig } from './proxyManager';
  3: 
  4: export interface RuntimeAccountProfile {
  5:     id: string;
  6:     sessionDir: string;
  7:     proxy?: ProxyConfig;
  8: }
  9: 
 10: function parseProxyConfig(profile: AccountProfileConfig): ProxyConfig | undefined {
 11:     const rawUrl = profile.proxyUrl.trim();
 12:     if (!rawUrl) {
 13:         return undefined;
 14:     }
 15: 
 16:     const normalizedUrl = /^[a-zA-Z][a-zA-Z\d+.-]*:\/\//.test(rawUrl) ? rawUrl : `http://${rawUrl}`;
 17:     let server = normalizedUrl;
 18:     let username = profile.proxyUsername.trim() || undefined;
 19:     let password = profile.proxyPassword.trim() || undefined;
 20: 
 21:     try {
 22:         const parsed = new URL(normalizedUrl);
 23:         server = `${parsed.protocol}//${parsed.host}`;
 24:         if (!username && parsed.username) {
 25:             username = decodeURIComponent(parsed.username);
 26:         }
 27:         if (!password && parsed.password) {
 28:             password = decodeURIComponent(parsed.password);
 29:         }
 30:     } catch {
 31:         // Manteniamo rawUrl così com'è: Playwright valuterà la validità lato launch.
 32:     }
 33: 
 34:     return {
 35:         server,
 36:         username,
 37:         password,
 38:     };
 39: }
 40: 
 41: function toRuntimeProfile(profile: AccountProfileConfig): RuntimeAccountProfile {
 42:     const fallbackId = 'default';
 43:     const trimmedId = profile.id.trim();
 44:     return {
 45:         id: trimmedId || fallbackId,
 46:         sessionDir: profile.sessionDir,
 47:         proxy: parseProxyConfig(profile),
 48:     };
 49: }
 50: 
 51: function dedupeById(profiles: RuntimeAccountProfile[]): RuntimeAccountProfile[] {
 52:     const unique = new Map<string, RuntimeAccountProfile>();
 53:     for (const profile of profiles) {
 54:         if (!unique.has(profile.id)) {
 55:             unique.set(profile.id, profile);
 56:         }
 57:     }
 58:     return Array.from(unique.values());
 59: }
 60: 
 61: function getConfiguredRuntimeProfiles(): RuntimeAccountProfile[] {
 62:     const runtime = config.accountProfiles.map(toRuntimeProfile);
 63:     const deduped = dedupeById(runtime);
 64:     return deduped.slice(0, 2);
 65: }
 66: 
 67: export function getRuntimeAccountProfiles(): RuntimeAccountProfile[] {
 68:     const configured = getConfiguredRuntimeProfiles();
 69:     if (!config.multiAccountEnabled || configured.length === 0) {
 70:         return [{
 71:             id: 'default',
 72:             sessionDir: config.sessionDir,
 73:         }];
 74:     }
 75:     return configured;
 76: }
 77: 
 78: export function isMultiAccountRuntimeEnabled(): boolean {
 79:     return config.multiAccountEnabled && getRuntimeAccountProfiles().length > 1;
 80: }
 81: 
 82: export function getSchedulingAccountIds(): string[] {
 83:     return getRuntimeAccountProfiles().map((profile) => profile.id);
 84: }
 85: 
 86: export function pickAccountIdForLead(leadId: number): string {
 87:     const accountIds = getSchedulingAccountIds();
 88:     if (accountIds.length === 0) {
 89:         return 'default';
 90:     }
 91:     if (accountIds.length === 1) {
 92:         return accountIds[0];
 93:     }
 94: 
 95:     const normalizedLeadId = Number.isFinite(leadId) ? Math.abs(Math.trunc(leadId)) : 0;
 96:     const index = normalizedLeadId % accountIds.length;
 97:     return accountIds[index] ?? accountIds[0];
 98: }
 99: 
100: export function getAccountProfileById(accountId: string | null | undefined): RuntimeAccountProfile {
101:     const accounts = getRuntimeAccountProfiles();
102:     if (accounts.length === 0) {
103:         return {
104:             id: 'default',
105:             sessionDir: config.sessionDir,
106:         };
107:     }
108:     if (!accountId) {
109:         return accounts[0];
110:     }
111:     const found = accounts.find((profile) => profile.id === accountId);
112:     return found ?? accounts[0];
113: }
````

## File: src/ai/guardian.ts
````typescript
  1: import { config } from '../config';
  2: import { ScheduleResult, WorkflowSelection } from '../core/scheduler';
  3: import { getRuntimeFlag, setRuntimeFlag } from '../core/repositories';
  4: import { requestOpenAIText } from './openaiClient';
  5: 
  6: const AI_GUARDIAN_LAST_RUN_AT_KEY = 'ai_guardian.last_run_at';
  7: 
  8: export type AiGuardianSeverity = 'normal' | 'watch' | 'critical';
  9: 
 10: export interface AiGuardianDecision {
 11:     source: 'heuristic' | 'ai';
 12:     severity: AiGuardianSeverity;
 13:     summary: string;
 14:     recommendations: string[];
 15:     pauseMinutes: number;
 16: }
 17: 
 18: export interface AiGuardianResult {
 19:     executed: boolean;
 20:     reason: string;
 21:     decision: AiGuardianDecision | null;
 22: }
 23: 
 24: interface ParsedAiGuardianPayload {
 25:     severity: AiGuardianSeverity;
 26:     summary: string;
 27:     recommendations: string[];
 28:     pauseMinutes: number;
 29: }
 30: 
 31: function clampPauseMinutes(value: number): number {
 32:     const parsed = Number.isFinite(value) ? Math.floor(value) : 0;
 33:     if (parsed <= 0) return 0;
 34:     return Math.min(24 * 60, parsed);
 35: }
 36: 
 37: function heuristics(schedule: ScheduleResult): AiGuardianDecision {
 38:     const criticalList = schedule.listBreakdown.find(
 39:         (list) => list.pendingRatio >= 0.78 || list.blockedRatio >= 0.35
 40:     );
 41: 
 42:     if (schedule.riskSnapshot.action === 'STOP' || criticalList) {
 43:         return {
 44:             source: 'heuristic',
 45:             severity: 'critical',
 46:             summary: 'Rischio elevato rilevato prima dell’esecuzione.',
 47:             recommendations: [
 48:                 'Pausa automatica e controllo manuale account.',
 49:                 'Ridurre limiti giornalieri su inviti e messaggi.',
 50:                 'Eseguire site-check con --fix prima della ripartenza.',
 51:             ],
 52:             pauseMinutes: config.aiGuardianPauseMinutes,
 53:         };
 54:     }
 55: 
 56:     if (
 57:         schedule.riskSnapshot.action === 'WARN'
 58:         || schedule.riskSnapshot.pendingRatio >= config.pendingRatioWarn
 59:         || schedule.riskSnapshot.errorRate >= 0.2
 60:     ) {
 61:         return {
 62:             source: 'heuristic',
 63:             severity: 'watch',
 64:             summary: 'Rischio intermedio: conviene rallentare e monitorare.',
 65:             recommendations: [
 66:                 'Ridurre volume inviti nel prossimo ciclo.',
 67:                 'Aumentare intervallo loop e verificare mismatch DB/sito.',
 68:             ],
 69:             pauseMinutes: 0,
 70:         };
 71:     }
 72: 
 73:     return {
 74:         source: 'heuristic',
 75:         severity: 'normal',
 76:         summary: 'Situazione stabile.',
 77:         recommendations: ['Continuare con policy conservative attive.'],
 78:         pauseMinutes: 0,
 79:     };
 80: }
 81: 
 82: function tryExtractJsonBlock(raw: string): string | null {
 83:     const start = raw.indexOf('{');
 84:     const end = raw.lastIndexOf('}');
 85:     if (start === -1 || end === -1 || end <= start) {
 86:         return null;
 87:     }
 88:     return raw.slice(start, end + 1);
 89: }
 90: 
 91: function parseAiDecision(raw: string): ParsedAiGuardianPayload | null {
 92:     const jsonBlock = tryExtractJsonBlock(raw);
 93:     if (!jsonBlock) return null;
 94: 
 95:     try {
 96:         const parsed = JSON.parse(jsonBlock) as Record<string, unknown>;
 97:         const severityRaw = typeof parsed.severity === 'string' ? parsed.severity.toLowerCase() : '';
 98:         const severity: AiGuardianSeverity = severityRaw === 'critical' || severityRaw === 'watch' || severityRaw === 'normal'
 99:             ? severityRaw
100:             : 'watch';
101:         const summary = typeof parsed.summary === 'string' ? parsed.summary.trim() : '';
102:         const recommendationsRaw = Array.isArray(parsed.recommendations) ? parsed.recommendations : [];
103:         const recommendations = recommendationsRaw
104:             .filter((item): item is string => typeof item === 'string')
105:             .map((item) => item.trim())
106:             .filter(Boolean)
107:             .slice(0, 5);
108:         const pauseMinutesRaw = typeof parsed.pauseMinutes === 'number'
109:             ? parsed.pauseMinutes
110:             : Number.parseInt(String(parsed.pauseMinutes ?? '0'), 10);
111: 
112:         return {
113:             severity,
114:             summary: summary || 'AI guardian non ha fornito un summary dettagliato.',
115:             recommendations: recommendations.length > 0 ? recommendations : ['Verificare manualmente trend rischio.'],
116:             pauseMinutes: clampPauseMinutes(pauseMinutesRaw),
117:         };
118:     } catch {
119:         return null;
120:     }
121: }
122: 
123: async function shouldRunAiGuardianNow(now: Date): Promise<{ allowed: boolean; reason: string }> {
124:     const lastRaw = await getRuntimeFlag(AI_GUARDIAN_LAST_RUN_AT_KEY);
125:     if (!lastRaw) {
126:         return { allowed: true, reason: 'first_run' };
127:     }
128:     const parsed = Date.parse(lastRaw);
129:     if (!Number.isFinite(parsed)) {
130:         return { allowed: true, reason: 'invalid_last_run' };
131:     }
132:     const elapsedMinutes = (now.getTime() - parsed) / 60_000;
133:     if (elapsedMinutes >= config.aiGuardianMinIntervalMinutes) {
134:         return { allowed: true, reason: 'interval_elapsed' };
135:     }
136:     return { allowed: false, reason: 'interval_not_elapsed' };
137: }
138: 
139: export async function evaluateAiGuardian(
140:     workflow: WorkflowSelection,
141:     schedule: ScheduleResult
142: ): Promise<AiGuardianResult> {
143:     const heuristicDecision = heuristics(schedule);
144:     if (!config.aiGuardianEnabled || !config.openaiApiKey) {
145:         return {
146:             executed: true,
147:             reason: 'heuristic_only',
148:             decision: heuristicDecision,
149:         };
150:     }
151: 
152:     const now = new Date();
153:     const runCheck = await shouldRunAiGuardianNow(now);
154:     if (!runCheck.allowed) {
155:         return {
156:             executed: false,
157:             reason: runCheck.reason,
158:             decision: null,
159:         };
160:     }
161: 
162:     const systemPrompt = [
163:         'Sei un risk controller per automazione LinkedIn.',
164:         'Valuta il rischio in anticipo e rispondi SOLO JSON valido.',
165:         'Schema JSON: {"severity":"normal|watch|critical","summary":"...","recommendations":["..."],"pauseMinutes":number}',
166:         'Usa approccio conservativo, no ottimismo.',
167:     ].join(' ');
168:     const userPrompt = JSON.stringify({
169:         workflow,
170:         riskSnapshot: schedule.riskSnapshot,
171:         inviteBudget: schedule.inviteBudget,
172:         messageBudget: schedule.messageBudget,
173:         queuedInviteJobs: schedule.queuedInviteJobs,
174:         queuedCheckJobs: schedule.queuedCheckJobs,
175:         queuedMessageJobs: schedule.queuedMessageJobs,
176:         listBreakdown: schedule.listBreakdown,
177:         fallbackHeuristic: heuristicDecision,
178:     });
179: 
180:     try {
181:         const text = await requestOpenAIText({
182:             system: systemPrompt,
183:             user: `Valuta questo contesto operativo e decidi: ${userPrompt}`,
184:             maxOutputTokens: 260,
185:             temperature: 0.2,
186:         });
187:         const parsed = parseAiDecision(text);
188:         await setRuntimeFlag(AI_GUARDIAN_LAST_RUN_AT_KEY, now.toISOString());
189: 
190:         if (!parsed) {
191:             return {
192:                 executed: true,
193:                 reason: 'ai_parse_failed_fallback_heuristic',
194:                 decision: heuristicDecision,
195:             };
196:         }
197: 
198:         return {
199:             executed: true,
200:             reason: runCheck.reason,
201:             decision: {
202:                 source: 'ai',
203:                 severity: parsed.severity,
204:                 summary: parsed.summary,
205:                 recommendations: parsed.recommendations,
206:                 pauseMinutes: parsed.pauseMinutes,
207:             },
208:         };
209:     } catch {
210:         return {
211:             executed: true,
212:             reason: 'ai_error_fallback_heuristic',
213:             decision: heuristicDecision,
214:         };
215:     }
216: }
````

## File: src/ai/inviteNotePersonalizer.ts
````typescript
 1: import { config } from '../config';
 2: import { generateInviteNote } from '../noteGenerator';
 3: import { LeadRecord } from '../types/domain';
 4: import { logWarn } from '../telemetry/logger';
 5: import { requestOpenAIText } from './openaiClient';
 6: 
 7: export interface PersonalizedInviteNoteResult {
 8:     note: string;
 9:     source: 'template' | 'ai';
10:     model: string | null;
11: }
12: 
13: const INVITE_NOTE_MAX_CHARS = 300;
14: 
15: function trimToMaxChars(input: string, maxChars: number = INVITE_NOTE_MAX_CHARS): string {
16:     const normalized = input.replace(/\s+/g, ' ').trim();
17:     if (!normalized) return '';
18:     if (normalized.length <= maxChars) return normalized;
19:     return normalized.slice(0, maxChars).trim();
20: }
21: 
22: function safeFirstName(lead: LeadRecord): string {
23:     const value = (lead.first_name ?? '').trim();
24:     if (value) return value;
25:     return 'collega';
26: }
27: 
28: export async function buildPersonalizedInviteNote(lead: LeadRecord): Promise<PersonalizedInviteNoteResult> {
29:     const template = trimToMaxChars(generateInviteNote(lead.first_name ?? ''), INVITE_NOTE_MAX_CHARS);
30: 
31:     if (config.inviteNoteMode !== 'ai' || !config.openaiApiKey) {
32:         return {
33:             note: template,
34:             source: 'template',
35:             model: null,
36:         };
37:     }
38: 
39:     const systemPrompt = [
40:         'Sei un assistant B2B per inviti LinkedIn in italiano.',
41:         'Genera una singola nota breve e naturale (1-2 frasi).',
42:         `Massimo ${INVITE_NOTE_MAX_CHARS} caratteri.`,
43:         'Niente link, niente emoji, niente claim aggressivi.',
44:         'Tono professionale, rispettoso, umano.',
45:     ].join(' ');
46: 
47:     const userPrompt = JSON.stringify({
48:         firstName: safeFirstName(lead),
49:         company: lead.account_name,
50:         role: lead.job_title,
51:         fallbackTemplate: template,
52:     });
53: 
54:     try {
55:         const generated = await requestOpenAIText({
56:             system: systemPrompt,
57:             user: `Dati lead: ${userPrompt}`,
58:             maxOutputTokens: 120,
59:             temperature: 0.7,
60:         });
61:         const finalNote = trimToMaxChars(generated, INVITE_NOTE_MAX_CHARS);
62:         if (!finalNote) {
63:             return {
64:                 note: template,
65:                 source: 'template',
66:                 model: null,
67:             };
68:         }
69:         return {
70:             note: finalNote,
71:             source: 'ai',
72:             model: config.aiModel,
73:         };
74:     } catch (error) {
75:         await logWarn('ai.invite_note.fallback_template', {
76:             leadId: lead.id,
77:             error: error instanceof Error ? error.message : String(error),
78:         });
79:         return {
80:             note: template,
81:             source: 'template',
82:             model: null,
83:         };
84:     }
85: }
````

## File: src/ai/messagePersonalizer.ts
````typescript
 1: import { config } from '../config';
 2: import { buildFollowUpMessage } from '../messages';
 3: import { LeadRecord } from '../types/domain';
 4: import { requestOpenAIText } from './openaiClient';
 5: import { logWarn } from '../telemetry/logger';
 6: 
 7: export interface PersonalizedMessageResult {
 8:     message: string;
 9:     source: 'template' | 'ai';
10:     model: string | null;
11: }
12: 
13: function trimToMaxChars(input: string, maxChars: number): string {
14:     const normalized = input.replace(/\s+\n/g, '\n').replace(/\n{3,}/g, '\n\n').trim();
15:     if (normalized.length <= maxChars) {
16:         return normalized;
17:     }
18:     return normalized.slice(0, maxChars).trim();
19: }
20: 
21: function safeFirstName(lead: LeadRecord): string {
22:     const value = (lead.first_name ?? '').trim();
23:     if (value) return value;
24:     return 'there';
25: }
26: 
27: export async function buildPersonalizedFollowUpMessage(lead: LeadRecord): Promise<PersonalizedMessageResult> {
28:     const template = buildFollowUpMessage(lead);
29:     if (!config.aiPersonalizationEnabled || !config.openaiApiKey) {
30:         return {
31:             message: trimToMaxChars(template, config.aiMessageMaxChars),
32:             source: 'template',
33:             model: null,
34:         };
35:     }
36: 
37:     const systemPrompt = [
38:         'Sei un assistant B2B per outreach LinkedIn in italiano.',
39:         'Genera un singolo messaggio breve, naturale, professionale.',
40:         `Massimo ${config.aiMessageMaxChars} caratteri.`,
41:         'Niente hype, niente emoji, niente claim aggressivi, niente link.',
42:         'Mantieni tono rispettoso e personalizzato sul profilo.',
43:     ].join(' ');
44: 
45:     const userPrompt = JSON.stringify({
46:         firstName: safeFirstName(lead),
47:         lastName: lead.last_name,
48:         company: lead.account_name,
49:         role: lead.job_title,
50:         website: lead.website,
51:         fallbackTemplate: template,
52:     });
53: 
54:     try {
55:         const generated = await requestOpenAIText({
56:             system: systemPrompt,
57:             user: `Dati lead: ${userPrompt}`,
58:             maxOutputTokens: 220,
59:             temperature: 0.6,
60:         });
61:         const finalMessage = trimToMaxChars(generated, config.aiMessageMaxChars);
62:         if (!finalMessage) {
63:             return {
64:                 message: trimToMaxChars(template, config.aiMessageMaxChars),
65:                 source: 'template',
66:                 model: null,
67:             };
68:         }
69:         return {
70:             message: finalMessage,
71:             source: 'ai',
72:             model: config.aiModel,
73:         };
74:     } catch (error) {
75:         await logWarn('ai.personalization.fallback_template', {
76:             leadId: lead.id,
77:             error: error instanceof Error ? error.message : String(error),
78:         });
79:         return {
80:             message: trimToMaxChars(template, config.aiMessageMaxChars),
81:             source: 'template',
82:             model: null,
83:         };
84:     }
85: }
````

## File: src/ai/openaiClient.ts
````typescript
 1: import { config } from '../config';
 2: 
 3: interface OpenAITextRequest {
 4:     system: string;
 5:     user: string;
 6:     maxOutputTokens: number;
 7:     temperature: number;
 8: }
 9: 
10: function safeJoinUrl(baseUrl: string, suffix: string): string {
11:     return `${baseUrl.replace(/\/+$/, '')}${suffix}`;
12: }
13: 
14: function extractOutputText(payload: unknown): string {
15:     if (!payload || typeof payload !== 'object') {
16:         return '';
17:     }
18: 
19:     const direct = (payload as { output_text?: unknown }).output_text;
20:     if (typeof direct === 'string' && direct.trim()) {
21:         return direct.trim();
22:     }
23: 
24:     const output = (payload as { output?: unknown }).output;
25:     if (!Array.isArray(output)) {
26:         return '';
27:     }
28: 
29:     const fragments: string[] = [];
30:     for (const item of output) {
31:         if (!item || typeof item !== 'object') continue;
32:         const content = (item as { content?: unknown }).content;
33:         if (!Array.isArray(content)) continue;
34:         for (const block of content) {
35:             if (!block || typeof block !== 'object') continue;
36:             const type = (block as { type?: unknown }).type;
37:             if (type !== 'output_text') continue;
38:             const text = (block as { text?: unknown }).text;
39:             if (typeof text === 'string' && text.trim()) {
40:                 fragments.push(text.trim());
41:             }
42:         }
43:     }
44: 
45:     return fragments.join('\n').trim();
46: }
47: 
48: export function isOpenAIConfigured(): boolean {
49:     return !!config.openaiApiKey;
50: }
51: 
52: export async function requestOpenAIText(input: OpenAITextRequest): Promise<string> {
53:     if (!config.openaiApiKey) {
54:         throw new Error('OPENAI_API_KEY mancante.');
55:     }
56: 
57:     const response = await fetch(safeJoinUrl(config.openaiBaseUrl, '/responses'), {
58:         method: 'POST',
59:         headers: {
60:             'content-type': 'application/json',
61:             authorization: `Bearer ${config.openaiApiKey}`,
62:         },
63:         body: JSON.stringify({
64:             model: config.aiModel,
65:             input: [
66:                 { role: 'system', content: input.system },
67:                 { role: 'user', content: input.user },
68:             ],
69:             temperature: input.temperature,
70:             max_output_tokens: input.maxOutputTokens,
71:         }),
72:         signal: AbortSignal.timeout(config.aiRequestTimeoutMs),
73:     });
74: 
75:     if (!response.ok) {
76:         const text = (await response.text().catch(() => '')).slice(0, 500);
77:         throw new Error(`OpenAI HTTP ${response.status}: ${response.statusText}${text ? ` ${text}` : ''}`);
78:     }
79: 
80:     const payload = await response.json().catch(() => null);
81:     const outputText = extractOutputText(payload);
82:     if (!outputText) {
83:         throw new Error('Risposta AI vuota o non parseabile.');
84:     }
85:     return outputText;
86: }
````

## File: src/connectWorkflow.ts
````typescript
1: import { runWorkflow } from './core/orchestrator';
2: 
3: export async function runConnectionWorkflow(): Promise<void> {
4:     await runWorkflow({
5:         workflow: 'invite',
6:         dryRun: false,
7:     });
8: }
````

## File: src/core/companyEnrichment.ts
````typescript
  1: import { checkLogin, closeBrowser, detectChallenge, humanDelay, launchBrowser } from '../browser';
  2: import { config } from '../config';
  3: import { quarantineAccount } from '../risk/incidentManager';
  4: import { logInfo, logWarn } from '../telemetry/logger';
  5: import {
  6:     addLead,
  7:     CompanyTargetRecord,
  8:     getCompanyTargetsForEnrichment,
  9:     setCompanyTargetStatus,
 10: } from './repositories';
 11: 
 12: export interface CompanyEnrichmentOptions {
 13:     limit?: number;
 14:     maxProfilesPerCompany?: number;
 15:     dryRun?: boolean;
 16: }
 17: 
 18: export interface CompanyEnrichmentReport {
 19:     scanned: number;
 20:     matched: number;
 21:     createdLeads: number;
 22:     noMatch: number;
 23:     errors: number;
 24:     dryRun: boolean;
 25: }
 26: 
 27: function normalizeProfileUrl(raw: string): string | null {
 28:     try {
 29:         const parsed = new URL(raw);
 30:         if (!parsed.hostname.toLowerCase().includes('linkedin.com')) return null;
 31:         const path = parsed.pathname.replace(/\/+$/, '');
 32:         if (!path.startsWith('/in/')) return null;
 33:         return `https://www.linkedin.com${path}/`;
 34:     } catch {
 35:         return null;
 36:     }
 37: }
 38: 
 39: function toTitleCase(input: string): string {
 40:     if (!input) return '';
 41:     return input.charAt(0).toUpperCase() + input.slice(1).toLowerCase();
 42: }
 43: 
 44: function parseNamesFromProfileUrl(profileUrl: string): { firstName: string; lastName: string } {
 45:     try {
 46:         const parsed = new URL(profileUrl);
 47:         const slug = parsed.pathname.replace('/in/', '').replace(/\/+$/, '');
 48:         const clean = slug.replace(/[-_]/g, ' ').replace(/\d+/g, ' ').replace(/\s+/g, ' ').trim();
 49:         if (!clean) return { firstName: '', lastName: '' };
 50: 
 51:         const parts = clean.split(' ').filter((part) => /^[A-Za-zÀ-ÿ]{2,}$/.test(part));
 52:         if (parts.length === 0) return { firstName: '', lastName: '' };
 53:         if (parts.length === 1) return { firstName: toTitleCase(parts[0]), lastName: '' };
 54: 
 55:         return {
 56:             firstName: toTitleCase(parts[0]),
 57:             lastName: parts.slice(1).map(toTitleCase).join(' '),
 58:         };
 59:     } catch {
 60:         return { firstName: '', lastName: '' };
 61:     }
 62: }
 63: 
 64: function extractDomain(website: string): string {
 65:     const raw = (website ?? '').trim();
 66:     if (!raw) return '';
 67:     try {
 68:         const parsed = raw.startsWith('http://') || raw.startsWith('https://')
 69:             ? new URL(raw)
 70:             : new URL(`https://${raw}`);
 71:         return parsed.hostname.replace(/^www\./i, '');
 72:     } catch {
 73:         return raw.replace(/^https?:\/\//i, '').replace(/^www\./i, '').split('/')[0];
 74:     }
 75: }
 76: 
 77: function buildSearchQuery(target: CompanyTargetRecord): string {
 78:     const company = (target.account_name ?? '').trim();
 79:     const domain = extractDomain(target.website);
 80:     const terms = [company, domain].filter((v) => v.length > 0);
 81:     return terms.join(' ').trim();
 82: }
 83: 
 84: function buildSearchQueries(target: CompanyTargetRecord): string[] {
 85:     const company = (target.account_name ?? '').trim();
 86:     const domain = extractDomain(target.website);
 87:     const candidates = [
 88:         buildSearchQuery(target),
 89:         company,
 90:         domain,
 91:     ].filter((value) => value.length > 0);
 92: 
 93:     const unique = new Set<string>();
 94:     for (const value of candidates) {
 95:         unique.add(value);
 96:     }
 97:     return Array.from(unique);
 98: }
 99: 
100: async function extractProfileUrls(page: Parameters<typeof detectChallenge>[0], maxProfiles: number): Promise<string[]> {
101:     const rawUrls = await page.$$eval('a[href*="/in/"]', (anchors) =>
102:         anchors.map((anchor) => (anchor as HTMLAnchorElement).href).filter((href) => !!href)
103:     );
104: 
105:     const unique = new Set<string>();
106:     for (const rawUrl of rawUrls) {
107:         const normalized = normalizeProfileUrl(rawUrl);
108:         if (!normalized) continue;
109:         unique.add(normalized);
110:         if (unique.size >= maxProfiles) break;
111:     }
112: 
113:     return Array.from(unique);
114: }
115: 
116: async function processCompanyTarget(
117:     target: CompanyTargetRecord,
118:     options: Required<CompanyEnrichmentOptions>,
119:     page: Parameters<typeof checkLogin>[0]
120: ): Promise<{ matched: boolean; createdLeads: number; noMatch: boolean; error: string | null }> {
121:     const queries = buildSearchQueries(target);
122:     if (queries.length === 0) {
123:         return { matched: false, createdLeads: 0, noMatch: true, error: null };
124:     }
125: 
126:     let profileUrls: string[] = [];
127:     for (const query of queries) {
128:         const searchUrl = `https://www.linkedin.com/search/results/people/?keywords=${encodeURIComponent(query)}`;
129:         await page.goto(searchUrl, { waitUntil: 'domcontentloaded' });
130:         await humanDelay(page, 1700, 3000);
131: 
132:         if (await detectChallenge(page)) {
133:             await quarantineAccount('COMPANY_ENRICHMENT_CHALLENGE', {
134:                 targetId: target.id,
135:                 listName: target.list_name,
136:                 accountName: target.account_name,
137:             });
138:             throw new Error('Challenge rilevato durante enrichment');
139:         }
140: 
141:         profileUrls = await extractProfileUrls(page, options.maxProfilesPerCompany);
142:         if (profileUrls.length > 0) {
143:             break;
144:         }
145:     }
146:     if (profileUrls.length === 0) {
147:         return { matched: false, createdLeads: 0, noMatch: true, error: null };
148:     }
149: 
150:     let createdLeads = 0;
151:     if (!options.dryRun) {
152:         for (const profileUrl of profileUrls) {
153:             const names = parseNamesFromProfileUrl(profileUrl);
154:             const inserted = await addLead({
155:                 accountName: target.account_name,
156:                 firstName: names.firstName,
157:                 lastName: names.lastName,
158:                 jobTitle: '',
159:                 website: target.website,
160:                 linkedinUrl: profileUrl,
161:                 listName: target.list_name,
162:             });
163:             if (inserted) {
164:                 createdLeads += 1;
165:             }
166:         }
167:     } else {
168:         createdLeads = profileUrls.length;
169:     }
170: 
171:     return { matched: true, createdLeads, noMatch: false, error: null };
172: }
173: 
174: export async function runCompanyEnrichmentBatch(options: CompanyEnrichmentOptions = {}): Promise<CompanyEnrichmentReport> {
175:     const resolved: Required<CompanyEnrichmentOptions> = {
176:         limit: Math.max(1, options.limit ?? config.companyEnrichmentBatch),
177:         maxProfilesPerCompany: Math.max(1, options.maxProfilesPerCompany ?? config.companyEnrichmentMaxProfilesPerCompany),
178:         dryRun: options.dryRun ?? false,
179:     };
180: 
181:     const targets = await getCompanyTargetsForEnrichment(resolved.limit);
182:     const report: CompanyEnrichmentReport = {
183:         scanned: 0,
184:         matched: 0,
185:         createdLeads: 0,
186:         noMatch: 0,
187:         errors: 0,
188:         dryRun: resolved.dryRun,
189:     };
190: 
191:     if (targets.length === 0) {
192:         return report;
193:     }
194: 
195:     const session = await launchBrowser();
196:     try {
197:         const loggedIn = await checkLogin(session.page);
198:         if (!loggedIn) {
199:             await quarantineAccount('COMPANY_ENRICHMENT_LOGIN_MISSING', {
200:                 reason: 'Sessione non autenticata durante enrichment automatico',
201:             });
202:             await logWarn('company_enrichment.skipped.login_missing', { targets: targets.length });
203:             return report;
204:         }
205: 
206:         for (const target of targets) {
207:             report.scanned += 1;
208:             try {
209:                 const result = await processCompanyTarget(target, resolved, session.page);
210:                 if (result.matched) {
211:                     report.matched += 1;
212:                     report.createdLeads += result.createdLeads;
213:                     if (!resolved.dryRun) {
214:                         await setCompanyTargetStatus(target.id, 'ENRICHED', null);
215:                     }
216:                 } else if (result.noMatch) {
217:                     report.noMatch += 1;
218:                     if (!resolved.dryRun) {
219:                         await setCompanyTargetStatus(target.id, 'NO_MATCH', null);
220:                     }
221:                 }
222:             } catch (error) {
223:                 const message = error instanceof Error ? error.message : String(error);
224:                 report.errors += 1;
225:                 if (!resolved.dryRun) {
226:                     await setCompanyTargetStatus(target.id, 'ERROR', message);
227:                 }
228:                 await logWarn('company_enrichment.target_failed', {
229:                     targetId: target.id,
230:                     listName: target.list_name,
231:                     accountName: target.account_name,
232:                     error: message,
233:                 });
234:                 if (/challenge/i.test(message)) {
235:                     break;
236:                 }
237:             }
238:         }
239:     } finally {
240:         await closeBrowser(session);
241:     }
242: 
243:     await logInfo('company_enrichment.batch', {
244:         scanned: report.scanned,
245:         matched: report.matched,
246:         createdLeads: report.createdLeads,
247:         noMatch: report.noMatch,
248:         errors: report.errors,
249:         dryRun: report.dryRun,
250:     });
251:     return report;
252: }
````

## File: src/core/leadStateService.ts
````typescript
 1: import { appendLeadEvent, getLeadById, pushOutboxEvent, setLeadStatus } from './repositories';
 2: import { LeadStatus } from '../types/domain';
 3: 
 4: const allowedTransitions: Record<Exclude<LeadStatus, 'PENDING'>, LeadStatus[]> = {
 5:     NEW: ['READY_INVITE', 'BLOCKED'],
 6:     READY_INVITE: ['INVITED', 'SKIPPED', 'BLOCKED'],
 7:     INVITED: ['ACCEPTED', 'BLOCKED'],
 8:     ACCEPTED: ['READY_MESSAGE', 'BLOCKED'],
 9:     READY_MESSAGE: ['MESSAGED', 'BLOCKED'],
10:     MESSAGED: [],
11:     SKIPPED: [],
12:     BLOCKED: [],
13: };
14: 
15: function normalize(status: LeadStatus): Exclude<LeadStatus, 'PENDING'> {
16:     if (status === 'PENDING') {
17:         return 'READY_INVITE';
18:     }
19:     return status;
20: }
21: 
22: export function isValidLeadTransition(fromStatus: LeadStatus, toStatus: LeadStatus): boolean {
23:     const normalizedFrom = normalize(fromStatus);
24:     const normalizedTo = normalize(toStatus);
25:     const nextAllowed = allowedTransitions[normalizedFrom];
26:     return nextAllowed.includes(normalizedTo);
27: }
28: 
29: export async function transitionLead(
30:     leadId: number,
31:     toStatus: LeadStatus,
32:     reason: string,
33:     metadata: Record<string, unknown> = {}
34: ): Promise<void> {
35:     const lead = await getLeadById(leadId);
36:     if (!lead) {
37:         throw new Error(`Lead ${leadId} non trovato.`);
38:     }
39: 
40:     const fromStatus = normalize(lead.status);
41:     const targetStatus = normalize(toStatus);
42:     if (!isValidLeadTransition(fromStatus, targetStatus)) {
43:         throw new Error(`Transizione non consentita: ${fromStatus} -> ${targetStatus}.`);
44:     }
45: 
46:     const blockedReason = targetStatus === 'BLOCKED' ? reason : undefined;
47:     await setLeadStatus(leadId, targetStatus, undefined, blockedReason);
48:     await appendLeadEvent(leadId, fromStatus, targetStatus, reason, metadata);
49:     await pushOutboxEvent(
50:         'lead.transition',
51:         {
52:             leadId,
53:             fromStatus,
54:             toStatus: targetStatus,
55:             reason,
56:             metadata,
57:         },
58:         `lead.transition:${leadId}:${fromStatus}:${targetStatus}:${reason}`
59:     );
60: }
61: 
62: export async function reconcileLeadStatus(
63:     leadId: number,
64:     toStatus: LeadStatus,
65:     reason: string,
66:     metadata: Record<string, unknown> = {}
67: ): Promise<void> {
68:     const lead = await getLeadById(leadId);
69:     if (!lead) {
70:         throw new Error(`Lead ${leadId} non trovato.`);
71:     }
72: 
73:     const fromStatus = normalize(lead.status);
74:     const targetStatus = normalize(toStatus);
75:     if (fromStatus === targetStatus) {
76:         return;
77:     }
78: 
79:     await setLeadStatus(leadId, targetStatus);
80:     await appendLeadEvent(leadId, fromStatus, targetStatus, reason, {
81:         ...metadata,
82:         reconcile: true,
83:     });
84:     await pushOutboxEvent(
85:         'lead.reconciled',
86:         {
87:             leadId,
88:             fromStatus,
89:             toStatus: targetStatus,
90:             reason,
91:             metadata,
92:         },
93:         `lead.reconciled:${leadId}:${fromStatus}:${targetStatus}:${reason}`
94:     );
95: }
````

## File: src/core/salesNavigatorSync.ts
````typescript
  1: import { getAccountProfileById } from '../accountManager';
  2: import { checkLogin, closeBrowser, detectChallenge, launchBrowser } from '../browser';
  3: import { quarantineAccount } from '../risk/incidentManager';
  4: import {
  5:     getLeadByLinkedinUrl,
  6:     linkLeadToSalesNavList,
  7:     markSalesNavListSynced,
  8:     upsertSalesNavList,
  9:     upsertSalesNavigatorLead,
 10: } from './repositories';
 11: import { navigateToSavedLists, scrapeLeadsFromSalesNavList, SalesNavLeadCandidate, SalesNavSavedList } from '../salesnav/listScraper';
 12: 
 13: export interface SalesNavigatorSyncOptions {
 14:     listName?: string | null;
 15:     listUrl?: string | null;
 16:     maxPages: number;
 17:     maxLeadsPerList: number;
 18:     dryRun: boolean;
 19:     accountId?: string;
 20: }
 21: 
 22: export interface SalesNavigatorSyncListReport {
 23:     listName: string;
 24:     listUrl: string;
 25:     pagesVisited: number;
 26:     candidatesDiscovered: number;
 27:     uniqueCandidates: number;
 28:     inserted: number;
 29:     updated: number;
 30:     unchanged: number;
 31:     wouldInsert: number;
 32:     wouldUpdate: number;
 33:     errors: number;
 34:     samples: Array<{
 35:         linkedinUrl: string;
 36:         firstName: string;
 37:         lastName: string;
 38:         accountName: string;
 39:         jobTitle: string;
 40:     }>;
 41: }
 42: 
 43: export interface SalesNavigatorSyncReport {
 44:     accountId: string;
 45:     dryRun: boolean;
 46:     listFilter: string | null;
 47:     listDiscoveryCount: number;
 48:     maxPages: number;
 49:     maxLeadsPerList: number;
 50:     pagesVisited: number;
 51:     candidatesDiscovered: number;
 52:     uniqueCandidates: number;
 53:     inserted: number;
 54:     updated: number;
 55:     unchanged: number;
 56:     wouldInsert: number;
 57:     wouldUpdate: number;
 58:     errors: number;
 59:     challengeDetected: boolean;
 60:     lists: SalesNavigatorSyncListReport[];
 61: }
 62: 
 63: function cleanText(value: string | null | undefined): string {
 64:     return (value ?? '').replace(/\s+/g, ' ').trim();
 65: }
 66: 
 67: function matchesListNameFilter(list: SalesNavSavedList, filter: string): boolean {
 68:     const normalizedFilter = filter.toLowerCase();
 69:     const normalizedName = cleanText(list.name).toLowerCase();
 70:     return normalizedName === normalizedFilter || normalizedName.includes(normalizedFilter);
 71: }
 72: 
 73: function toSample(candidate: SalesNavLeadCandidate): SalesNavigatorSyncListReport['samples'][number] {
 74:     return {
 75:         linkedinUrl: candidate.linkedinUrl,
 76:         firstName: candidate.firstName,
 77:         lastName: candidate.lastName,
 78:         accountName: candidate.accountName,
 79:         jobTitle: candidate.jobTitle,
 80:     };
 81: }
 82: 
 83: export async function runSalesNavigatorListSync(options: SalesNavigatorSyncOptions): Promise<SalesNavigatorSyncReport> {
 84:     const listFilter = cleanText(options.listName) || null;
 85:     const explicitListUrl = cleanText(options.listUrl) || null;
 86:     const maxPages = Math.max(1, options.maxPages);
 87:     const maxLeadsPerList = Math.max(1, options.maxLeadsPerList);
 88:     const account = getAccountProfileById(options.accountId);
 89: 
 90:     const report: SalesNavigatorSyncReport = {
 91:         accountId: account.id,
 92:         dryRun: options.dryRun,
 93:         listFilter,
 94:         listDiscoveryCount: 0,
 95:         maxPages,
 96:         maxLeadsPerList,
 97:         pagesVisited: 0,
 98:         candidatesDiscovered: 0,
 99:         uniqueCandidates: 0,
100:         inserted: 0,
101:         updated: 0,
102:         unchanged: 0,
103:         wouldInsert: 0,
104:         wouldUpdate: 0,
105:         errors: 0,
106:         challengeDetected: false,
107:         lists: [],
108:     };
109: 
110:     const session = await launchBrowser({
111:         sessionDir: account.sessionDir,
112:         proxy: account.proxy,
113:     });
114: 
115:     try {
116:         const loggedIn = await checkLogin(session.page);
117:         if (!loggedIn) {
118:             throw new Error(`Sales Navigator sync: sessione non autenticata (account=${account.id}).`);
119:         }
120: 
121:         let targetLists: SalesNavSavedList[] = [];
122:         if (explicitListUrl) {
123:             targetLists = [{
124:                 name: listFilter || 'default',
125:                 url: explicitListUrl,
126:             }];
127:         } else {
128:             const discovered = await navigateToSavedLists(session.page);
129:             report.listDiscoveryCount = discovered.length;
130:             if (listFilter) {
131:                 targetLists = discovered.filter((entry) => matchesListNameFilter(entry, listFilter));
132:             } else {
133:                 targetLists = discovered;
134:             }
135:         }
136: 
137:         if (targetLists.length === 0) {
138:             throw new Error('Sales Navigator sync: nessuna lista trovata con i criteri forniti.');
139:         }
140: 
141:         for (const targetList of targetLists) {
142:             const listName = cleanText(targetList.name) || 'default';
143:             const listUrl = cleanText(targetList.url);
144:             const listReport: SalesNavigatorSyncListReport = {
145:                 listName,
146:                 listUrl,
147:                 pagesVisited: 0,
148:                 candidatesDiscovered: 0,
149:                 uniqueCandidates: 0,
150:                 inserted: 0,
151:                 updated: 0,
152:                 unchanged: 0,
153:                 wouldInsert: 0,
154:                 wouldUpdate: 0,
155:                 errors: 0,
156:                 samples: [],
157:             };
158: 
159:             const scraped = await scrapeLeadsFromSalesNavList(session.page, {
160:                 listUrl,
161:                 maxPages,
162:                 leadLimit: maxLeadsPerList,
163:             });
164:             listReport.pagesVisited = scraped.pagesVisited;
165:             listReport.candidatesDiscovered = scraped.candidatesDiscovered;
166:             listReport.uniqueCandidates = scraped.uniqueCandidates;
167: 
168:             report.pagesVisited += scraped.pagesVisited;
169:             report.candidatesDiscovered += scraped.candidatesDiscovered;
170:             report.uniqueCandidates += scraped.uniqueCandidates;
171: 
172:             if (await detectChallenge(session.page)) {
173:                 report.challengeDetected = true;
174:                 await quarantineAccount('SALESNAV_SYNC_CHALLENGE_DETECTED', {
175:                     listName,
176:                     listUrl,
177:                     accountId: account.id,
178:                 });
179:                 report.lists.push(listReport);
180:                 break;
181:             }
182: 
183:             const listRow = options.dryRun ? null : await upsertSalesNavList(listName, listUrl);
184:             for (const candidate of scraped.leads) {
185:                 if (listReport.samples.length < 10) {
186:                     listReport.samples.push(toSample(candidate));
187:                 }
188:                 try {
189:                     if (options.dryRun) {
190:                         const existing = await getLeadByLinkedinUrl(candidate.linkedinUrl);
191:                         if (existing) {
192:                             listReport.wouldUpdate += 1;
193:                             report.wouldUpdate += 1;
194:                         } else {
195:                             listReport.wouldInsert += 1;
196:                             report.wouldInsert += 1;
197:                         }
198:                         continue;
199:                     }
200: 
201:                     const upserted = await upsertSalesNavigatorLead({
202:                         listName,
203:                         linkedinUrl: candidate.linkedinUrl,
204:                         accountName: candidate.accountName,
205:                         firstName: candidate.firstName,
206:                         lastName: candidate.lastName,
207:                         jobTitle: candidate.jobTitle,
208:                         website: candidate.website,
209:                     });
210: 
211:                     if (listRow && upserted.leadId > 0) {
212:                         await linkLeadToSalesNavList(listRow.id, upserted.leadId);
213:                     }
214: 
215:                     if (upserted.action === 'inserted') {
216:                         listReport.inserted += 1;
217:                         report.inserted += 1;
218:                     } else if (upserted.action === 'updated') {
219:                         listReport.updated += 1;
220:                         report.updated += 1;
221:                     } else {
222:                         listReport.unchanged += 1;
223:                         report.unchanged += 1;
224:                     }
225:                 } catch {
226:                     listReport.errors += 1;
227:                     report.errors += 1;
228:                 }
229:             }
230: 
231:             if (listRow && !options.dryRun) {
232:                 await markSalesNavListSynced(listRow.id);
233:             }
234: 
235:             report.lists.push(listReport);
236:         }
237: 
238:         return report;
239:     } finally {
240:         await closeBrowser(session);
241:     }
242: }
````

## File: src/csvImporter.ts
````typescript
  1: import fs from 'fs';
  2: import csv from 'csv-parser';
  3: import { addCompanyTarget, addLead } from './core/repositories';
  4: import { isLinkedInUrl, normalizeLinkedInUrl } from './linkedinUrl';
  5: 
  6: export interface ImportResult {
  7:     inserted: number;
  8:     companyTargetsInserted: number;
  9:     skipped: number;
 10: }
 11: 
 12: /**
 13:  * Legge un valore da un record CSV provando più possibili nomi di colonna in ordine.
 14:  */
 15: function pickField(row: Record<string, string>, ...keys: string[]): string {
 16:     for (const key of keys) {
 17:         const val = row[key];
 18:         if (val && val.trim()) {
 19:             return val.trim();
 20:         }
 21:     }
 22:     return '';
 23: }
 24: 
 25: function normalizeWebsite(raw: string): string {
 26:     const trimmed = raw.trim();
 27:     if (!trimmed) return '';
 28:     if (/^https?:\/\//i.test(trimmed)) return trimmed;
 29:     if (trimmed.includes('.') && !trimmed.includes(' ')) {
 30:         return `https://${trimmed}`;
 31:     }
 32:     return trimmed;
 33: }
 34: 
 35: export async function importLeadsFromCSV(filePath: string, listName: string): Promise<ImportResult> {
 36:     const rows: Array<Record<string, string>> = [];
 37: 
 38:     await new Promise<void>((resolve, reject) => {
 39:         fs.createReadStream(filePath)
 40:             .pipe(csv())
 41:             .on('data', (row: Record<string, string>) => rows.push(row))
 42:             .on('end', resolve)
 43:             .on('error', reject);
 44:     });
 45: 
 46:     let inserted = 0;
 47:     let companyTargetsInserted = 0;
 48:     let skipped = 0;
 49: 
 50:     for (const row of rows) {
 51:         // LinkedIn URL — Sales Navigator e formati alternativi
 52:         const lnUrlRaw = pickField(
 53:             row,
 54:             'linkedin_url',
 55:             'LinkedIn URL',
 56:             'linkedinUrl',
 57:             'LinkedIn Profile URL',
 58:             'Profile URL',
 59:             'Linkedin',
 60:             'Person Linkedin Url',
 61:             'Contact LinkedIn URL'
 62:         );
 63: 
 64:         const linkedinUrl = normalizeLinkedInUrl(lnUrlRaw.trim());
 65: 
 66:         // Sales Navigator: "First Name" e "Last Name" separati
 67:         const firstName = pickField(row, 'First Name', 'first_name', 'FirstName');
 68:         const lastName = pickField(row, 'Last Name', 'last_name', 'LastName');
 69: 
 70:         // Nome account / azienda
 71:         const accountName = pickField(
 72:             row,
 73:             'Account Name', 'account_name', 'Company', 'Company Name', 'company_name',
 74:             'companyName', 'Organization'
 75:         );
 76: 
 77:         // Se non abbiamo accountName esplicito, lo costruiamo da first+last
 78:         const resolvedAccountName = accountName || [firstName, lastName].filter(Boolean).join(' ');
 79: 
 80:         const jobTitle = pickField(row, 'Title', 'Job Title', 'job_title', 'Position');
 81:         const website = normalizeWebsite(
 82:             pickField(
 83:                 row,
 84:                 'Website',
 85:                 'website',
 86:                 'Company Website',
 87:                 'Company Domain',
 88:                 'domain'
 89:             )
 90:         );
 91: 
 92:         if (!linkedinUrl || !isLinkedInUrl(linkedinUrl)) {
 93:             const insertedCompanyTarget = await addCompanyTarget({
 94:                 listName,
 95:                 accountName: resolvedAccountName,
 96:                 website,
 97:                 sourceFile: filePath,
 98:             });
 99:             if (insertedCompanyTarget) {
100:                 companyTargetsInserted += 1;
101:             } else {
102:                 skipped += 1;
103:             }
104:             continue;
105:         }
106: 
107:         const isNew = await addLead({
108:             accountName: resolvedAccountName,
109:             firstName,
110:             lastName,
111:             jobTitle,
112:             website,
113:             linkedinUrl,
114:             listName,
115:         });
116: 
117:         if (isNew) {
118:             inserted += 1;
119:         } else {
120:             skipped += 1;
121:         }
122:     }
123: 
124:     return { inserted, companyTargetsInserted, skipped };
125: }
````

## File: src/db/migrations/001_core.sql
````sql
  1: CREATE TABLE IF NOT EXISTS _migrations (
  2:     id INTEGER PRIMARY KEY AUTOINCREMENT,
  3:     name TEXT NOT NULL UNIQUE,
  4:     applied_at DATETIME DEFAULT CURRENT_TIMESTAMP
  5: );
  6: 
  7: CREATE TABLE IF NOT EXISTS leads (
  8:     id INTEGER PRIMARY KEY AUTOINCREMENT,
  9:     account_name TEXT NOT NULL DEFAULT '',
 10:     website TEXT NOT NULL DEFAULT '',
 11:     linkedin_url TEXT NOT NULL UNIQUE,
 12:     status TEXT NOT NULL DEFAULT 'NEW',
 13:     list_name TEXT NOT NULL DEFAULT 'default',
 14:     invited_at DATETIME,
 15:     accepted_at DATETIME,
 16:     messaged_at DATETIME,
 17:     last_error TEXT,
 18:     blocked_reason TEXT,
 19:     created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
 20:     updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
 21: );
 22: 
 23: CREATE TABLE IF NOT EXISTS lead_lists (
 24:     id INTEGER PRIMARY KEY AUTOINCREMENT,
 25:     name TEXT NOT NULL UNIQUE,
 26:     source TEXT NOT NULL DEFAULT 'manual',
 27:     created_at DATETIME DEFAULT CURRENT_TIMESTAMP
 28: );
 29: 
 30: CREATE TABLE IF NOT EXISTS list_leads (
 31:     list_id INTEGER NOT NULL,
 32:     lead_id INTEGER NOT NULL,
 33:     created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
 34:     PRIMARY KEY (list_id, lead_id),
 35:     FOREIGN KEY (list_id) REFERENCES lead_lists(id),
 36:     FOREIGN KEY (lead_id) REFERENCES leads(id)
 37: );
 38: 
 39: CREATE TABLE IF NOT EXISTS daily_stats (
 40:     date TEXT PRIMARY KEY,
 41:     invites_sent INTEGER NOT NULL DEFAULT 0,
 42:     messages_sent INTEGER NOT NULL DEFAULT 0,
 43:     challenges_count INTEGER NOT NULL DEFAULT 0,
 44:     selector_failures INTEGER NOT NULL DEFAULT 0,
 45:     run_errors INTEGER NOT NULL DEFAULT 0
 46: );
 47: 
 48: CREATE TABLE IF NOT EXISTS jobs (
 49:     id INTEGER PRIMARY KEY AUTOINCREMENT,
 50:     type TEXT NOT NULL,
 51:     status TEXT NOT NULL DEFAULT 'QUEUED',
 52:     payload_json TEXT NOT NULL,
 53:     idempotency_key TEXT NOT NULL UNIQUE,
 54:     priority INTEGER NOT NULL DEFAULT 100,
 55:     attempts INTEGER NOT NULL DEFAULT 0,
 56:     max_attempts INTEGER NOT NULL DEFAULT 3,
 57:     next_run_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
 58:     locked_at DATETIME,
 59:     last_error TEXT,
 60:     created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
 61:     updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
 62: );
 63: 
 64: CREATE TABLE IF NOT EXISTS job_attempts (
 65:     id INTEGER PRIMARY KEY AUTOINCREMENT,
 66:     job_id INTEGER NOT NULL,
 67:     started_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
 68:     finished_at DATETIME,
 69:     success INTEGER NOT NULL DEFAULT 0,
 70:     error_code TEXT,
 71:     error_message TEXT,
 72:     evidence_path TEXT,
 73:     FOREIGN KEY (job_id) REFERENCES jobs(id)
 74: );
 75: 
 76: CREATE TABLE IF NOT EXISTS lead_events (
 77:     id INTEGER PRIMARY KEY AUTOINCREMENT,
 78:     lead_id INTEGER NOT NULL,
 79:     from_status TEXT NOT NULL,
 80:     to_status TEXT NOT NULL,
 81:     reason TEXT NOT NULL,
 82:     metadata_json TEXT NOT NULL DEFAULT '{}',
 83:     created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
 84:     FOREIGN KEY (lead_id) REFERENCES leads(id)
 85: );
 86: 
 87: CREATE TABLE IF NOT EXISTS account_incidents (
 88:     id INTEGER PRIMARY KEY AUTOINCREMENT,
 89:     type TEXT NOT NULL,
 90:     severity TEXT NOT NULL DEFAULT 'WARN',
 91:     status TEXT NOT NULL DEFAULT 'OPEN',
 92:     details_json TEXT NOT NULL DEFAULT '{}',
 93:     opened_at DATETIME DEFAULT CURRENT_TIMESTAMP,
 94:     acknowledged_at DATETIME,
 95:     resolved_at DATETIME
 96: );
 97: 
 98: CREATE TABLE IF NOT EXISTS outbox_events (
 99:     id INTEGER PRIMARY KEY AUTOINCREMENT,
100:     topic TEXT NOT NULL,
101:     payload_json TEXT NOT NULL,
102:     idempotency_key TEXT NOT NULL UNIQUE,
103:     attempts INTEGER NOT NULL DEFAULT 0,
104:     next_retry_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
105:     delivered_at DATETIME,
106:     last_error TEXT,
107:     created_at DATETIME DEFAULT CURRENT_TIMESTAMP
108: );
109: 
110: CREATE TABLE IF NOT EXISTS sync_state (
111:     key TEXT PRIMARY KEY,
112:     value TEXT NOT NULL,
113:     updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
114: );
115: 
116: CREATE TABLE IF NOT EXISTS message_history (
117:     id INTEGER PRIMARY KEY AUTOINCREMENT,
118:     lead_id INTEGER NOT NULL,
119:     content_hash TEXT NOT NULL,
120:     sent_at DATETIME DEFAULT CURRENT_TIMESTAMP,
121:     FOREIGN KEY (lead_id) REFERENCES leads(id)
122: );
123: 
124: CREATE TABLE IF NOT EXISTS run_logs (
125:     id INTEGER PRIMARY KEY AUTOINCREMENT,
126:     level TEXT NOT NULL,
127:     event TEXT NOT NULL,
128:     payload_json TEXT NOT NULL DEFAULT '{}',
129:     created_at DATETIME DEFAULT CURRENT_TIMESTAMP
130: );
131: 
132: CREATE INDEX IF NOT EXISTS idx_leads_status ON leads(status);
133: CREATE INDEX IF NOT EXISTS idx_jobs_status_next_run ON jobs(status, next_run_at);
134: CREATE INDEX IF NOT EXISTS idx_job_attempts_job_id ON job_attempts(job_id);
135: CREATE INDEX IF NOT EXISTS idx_outbox_pending ON outbox_events(delivered_at, next_retry_at);
136: CREATE INDEX IF NOT EXISTS idx_message_history_hash_sent_at ON message_history(content_hash, sent_at);
````

## File: src/db/migrations/002_legacy_status_backfill.sql
````sql
1: UPDATE leads
2: SET status = 'READY_INVITE',
3:     updated_at = CURRENT_TIMESTAMP
4: WHERE status = 'PENDING';
````

## File: src/db/migrations/003_add_person_fields.sql
````sql
1: -- Aggiunge campi persona (nome/cognome) alla tabella leads.
2: -- Sales Navigator esporta First Name e Last Name separatamente.
3: ALTER TABLE leads ADD COLUMN first_name TEXT NOT NULL DEFAULT '';
4: ALTER TABLE leads ADD COLUMN last_name  TEXT NOT NULL DEFAULT '';
5: ALTER TABLE leads ADD COLUMN job_title  TEXT NOT NULL DEFAULT '';
````

## File: src/db/migrations/004_list_campaign_controls.sql
````sql
 1: -- Controlli campagna per lista Sales Navigator.
 2: ALTER TABLE lead_lists ADD COLUMN is_active INTEGER NOT NULL DEFAULT 1;
 3: ALTER TABLE lead_lists ADD COLUMN priority INTEGER NOT NULL DEFAULT 100;
 4: ALTER TABLE lead_lists ADD COLUMN daily_invite_cap INTEGER;
 5: ALTER TABLE lead_lists ADD COLUMN daily_message_cap INTEGER;
 6: 
 7: CREATE TABLE IF NOT EXISTS list_daily_stats (
 8:     date TEXT NOT NULL,
 9:     list_name TEXT NOT NULL,
10:     invites_sent INTEGER NOT NULL DEFAULT 0,
11:     messages_sent INTEGER NOT NULL DEFAULT 0,
12:     PRIMARY KEY (date, list_name)
13: );
14: 
15: CREATE INDEX IF NOT EXISTS idx_list_daily_stats_list_date
16:     ON list_daily_stats(list_name, date);
````

## File: src/db/migrations/005_performance_indexes.sql
````sql
1: -- Indici per scheduler/worker su database con molti lead.
2: CREATE INDEX IF NOT EXISTS idx_leads_status_list_created
3:     ON leads(status, list_name, created_at);
4: 
5: CREATE INDEX IF NOT EXISTS idx_jobs_type_status_next_run
6:     ON jobs(type, status, next_run_at, priority, created_at);
````

## File: src/db/migrations/006_company_targets.sql
````sql
 1: CREATE TABLE IF NOT EXISTS company_targets (
 2:     id INTEGER PRIMARY KEY AUTOINCREMENT,
 3:     list_name TEXT NOT NULL,
 4:     account_name TEXT NOT NULL DEFAULT '',
 5:     website TEXT NOT NULL DEFAULT '',
 6:     source_file TEXT,
 7:     status TEXT NOT NULL DEFAULT 'NEW',
 8:     created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
 9:     updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
10: );
11: 
12: CREATE UNIQUE INDEX IF NOT EXISTS uq_company_targets_list_account_website
13:     ON company_targets(list_name, account_name, website);
14: 
15: CREATE INDEX IF NOT EXISTS idx_company_targets_list_status
16:     ON company_targets(list_name, status, created_at);
````

## File: src/db/migrations/007_company_target_tracking.sql
````sql
1: ALTER TABLE company_targets ADD COLUMN attempts INTEGER NOT NULL DEFAULT 0;
2: ALTER TABLE company_targets ADD COLUMN last_error TEXT;
3: ALTER TABLE company_targets ADD COLUMN processed_at DATETIME;
````

## File: src/db/migrations/008_runtime_locks.sql
````sql
 1: CREATE TABLE IF NOT EXISTS runtime_locks (
 2:     lock_key TEXT PRIMARY KEY,
 3:     owner_id TEXT NOT NULL,
 4:     acquired_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
 5:     heartbeat_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
 6:     expires_at DATETIME NOT NULL,
 7:     metadata_json TEXT NOT NULL DEFAULT '{}',
 8:     updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
 9: );
10: 
11: CREATE INDEX IF NOT EXISTS idx_runtime_locks_expires_at
12:     ON runtime_locks(expires_at);
````

## File: src/db/migrations/009_site_check_tracking.sql
````sql
1: ALTER TABLE leads ADD COLUMN last_site_check_at DATETIME;
2: 
3: CREATE INDEX IF NOT EXISTS idx_leads_status_last_site_check
4:     ON leads(status, last_site_check_at, created_at);
````

## File: src/db/migrations/010_salesnav_lists.sql
````sql
 1: CREATE TABLE IF NOT EXISTS salesnav_lists (
 2:     id INTEGER PRIMARY KEY AUTOINCREMENT,
 3:     name TEXT NOT NULL UNIQUE,
 4:     url TEXT NOT NULL UNIQUE,
 5:     last_synced_at DATETIME,
 6:     created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
 7:     updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
 8: );
 9: 
10: CREATE TABLE IF NOT EXISTS salesnav_list_items (
11:     id INTEGER PRIMARY KEY AUTOINCREMENT,
12:     list_id INTEGER NOT NULL,
13:     lead_id INTEGER NOT NULL,
14:     added_at DATETIME DEFAULT CURRENT_TIMESTAMP,
15:     FOREIGN KEY (list_id) REFERENCES salesnav_lists(id),
16:     FOREIGN KEY (lead_id) REFERENCES leads(id),
17:     UNIQUE(list_id, lead_id)
18: );
19: 
20: CREATE INDEX IF NOT EXISTS idx_salesnav_lists_last_synced_at
21:     ON salesnav_lists(last_synced_at);
22: 
23: CREATE INDEX IF NOT EXISTS idx_salesnav_list_items_list_id
24:     ON salesnav_list_items(list_id);
25: 
26: CREATE INDEX IF NOT EXISTS idx_salesnav_list_items_lead_id
27:     ON salesnav_list_items(lead_id);
````

## File: src/linkedinUrl.ts
````typescript
 1: export function tryParseUrl(raw: string): URL | null {
 2:     const trimmed = raw.trim();
 3:     if (!trimmed) return null;
 4:     try {
 5:         return new URL(trimmed);
 6:     } catch {
 7:         return null;
 8:     }
 9: }
10: 
11: export function isLinkedInHost(hostname: string): boolean {
12:     const host = hostname.toLowerCase();
13:     return host === 'linkedin.com' || host.endsWith('.linkedin.com');
14: }
15: 
16: export function isLinkedInUrl(raw: string): boolean {
17:     const parsed = tryParseUrl(raw);
18:     return !!parsed && isLinkedInHost(parsed.hostname);
19: }
20: 
21: export function isSalesNavigatorUrl(raw: string): boolean {
22:     const parsed = tryParseUrl(raw);
23:     if (!parsed || !isLinkedInHost(parsed.hostname)) return false;
24:     return parsed.pathname.toLowerCase().startsWith('/sales/');
25: }
26: 
27: export function isProfileUrl(raw: string): boolean {
28:     const parsed = tryParseUrl(raw);
29:     if (!parsed || !isLinkedInHost(parsed.hostname)) return false;
30:     const path = parsed.pathname.toLowerCase();
31:     return path.startsWith('/in/') || path.startsWith('/pub/');
32: }
33: 
34: export function normalizeLinkedInUrl(raw: string): string {
35:     const parsed = tryParseUrl(raw);
36:     if (!parsed || !isLinkedInHost(parsed.hostname)) {
37:         return raw.trim();
38:     }
39: 
40:     const normalized = new URL(parsed.toString());
41:     normalized.protocol = 'https:';
42:     normalized.hostname = 'www.linkedin.com';
43:     normalized.hash = '';
44: 
45:     // Canonicalizza i profili alla radice /in/<slug>/ per evitare varianti duplicate.
46:     const parts = normalized.pathname.split('/').filter(Boolean);
47:     if (parts.length >= 2 && parts[0].toLowerCase() === 'in') {
48:         normalized.pathname = `/in/${parts[1]}/`;
49:         normalized.search = '';
50:         return normalized.toString();
51:     }
52: 
53:     normalized.pathname = normalized.pathname.replace(/\/+$/, '');
54:     return normalized.toString();
55: }
````

## File: src/messages.ts
````typescript
 1: import { LeadRecord } from './types/domain';
 2: 
 3: const templates: string[] = [
 4:     `Ciao {{firstName}},\n\npiacere di connetterci qui su LinkedIn.\nSeguo aziende nel tuo settore e ho visto alcuni punti dove spesso si sblocca crescita commerciale con piccoli cambi operativi.\n\nSe ti va, facciamo una call di 15 minuti questa settimana?`,
 5:     `Ciao {{firstName}},\n\ngrazie del collegamento.\nHo dato un'occhiata a {{companyHint}} e credo ci sia spazio per uno scambio utile su acquisizione e pipeline.\n\nTi andrebbe una breve call di 15 minuti?`,
 6:     `Ciao {{firstName}},\n\npiacere di essere in contatto.\nLavoro su progetti che aiutano team come il tuo a migliorare conversione e tempi di risposta commerciale.\n\nSe hai 15 minuti nei prossimi giorni, ti racconto due idee concrete.`,
 7: ];
 8: 
 9: /**
10:  * Restituisce il primo nome da usare nel messaggio.
11:  * Priorità: first_name (da Sales Navigator) → prima parola di account_name → fallback generico.
12:  */
13: function resolveFirstName(lead: LeadRecord): string {
14:     if (lead.first_name && lead.first_name.trim()) {
15:         return lead.first_name.trim();
16:     }
17:     // Fallback: prima parola di account_name se sembra un nome proprio
18:     const clean = lead.account_name.trim();
19:     if (clean) {
20:         const firstWord = clean.split(/\s+/)[0];
21:         // Usa la prima parola solo se non è tutta maiuscola (es. "ACME" → scarta)
22:         if (firstWord !== firstWord.toUpperCase()) {
23:             return firstWord;
24:         }
25:     }
26:     return 'there';
27: }
28: 
29: function getCompanyHint(lead: LeadRecord): string {
30:     if (lead.account_name.trim()) {
31:         return lead.account_name.trim();
32:     }
33:     if (lead.website.trim()) {
34:         return lead.website.trim();
35:     }
36:     return 'la tua realtà';
37: }
38: 
39: function resolveTemplate(template: string, lead: LeadRecord): string {
40:     return template
41:         .replaceAll('{{firstName}}', resolveFirstName(lead))
42:         .replaceAll('{{companyHint}}', getCompanyHint(lead));
43: }
44: 
45: export function buildFollowUpMessage(lead: LeadRecord): string {
46:     const index = lead.id % templates.length;
47:     return resolveTemplate(templates[index], lead);
48: }
````

## File: src/messagingWorkflow.ts
````typescript
1: import { runWorkflow } from './core/orchestrator';
2: 
3: export async function runMessagingWorkflow(): Promise<void> {
4:     await runWorkflow({
5:         workflow: 'message',
6:         dryRun: false,
7:     });
8: }
````

## File: src/models.ts
````typescript
 1: import {
 2:     addLead as addLeadRepository,
 3:     getDailyStat,
 4:     countLeadsByStatuses,
 5:     countWeeklyInvites as countWeeklyInvitesRepository,
 6:     getLeadsByStatus,
 7:     incrementDailyStat,
 8:     setLeadStatus,
 9: } from './core/repositories';
10: import { LeadRecord, LeadStatus } from './types/domain';
11: 
12: export interface Lead extends LeadRecord { }
13: 
14: export async function addLead(lead: Partial<Lead>): Promise<void> {
15:     await addLeadRepository({
16:         accountName: lead.account_name ?? '',
17:         firstName: lead.first_name ?? '',
18:         lastName: lead.last_name ?? '',
19:         jobTitle: lead.job_title ?? '',
20:         website: lead.website ?? '',
21:         linkedinUrl: lead.linkedin_url ?? '',
22:         listName: lead.list_name ?? 'default',
23:     });
24: }
25: 
26: export async function getPendingLeads(limit: number): Promise<Lead[]> {
27:     return getLeadsByStatus('READY_INVITE', limit);
28: }
29: 
30: export async function getInvitedLeads(): Promise<Lead[]> {
31:     return getLeadsByStatus('INVITED', 1000);
32: }
33: 
34: export async function getAcceptedLeads(limit: number): Promise<Lead[]> {
35:     return getLeadsByStatus('READY_MESSAGE', limit);
36: }
37: 
38: export async function updateLeadStatus(id: number, status: LeadStatus): Promise<void> {
39:     await setLeadStatus(id, status);
40: }
41: 
42: export async function countDailyInvites(dateString: string): Promise<number> {
43:     return getDailyStat(dateString, 'invites_sent');
44: }
45: 
46: export async function countWeeklyInvites(weekStartDate: string): Promise<number> {
47:     return countWeeklyInvitesRepository(weekStartDate);
48: }
49: 
50: export async function incrementDailyInvites(dateString: string): Promise<void> {
51:     await incrementDailyStat(dateString, 'invites_sent');
52: }
53: 
54: export async function countReadyToInvite(): Promise<number> {
55:     return countLeadsByStatuses(['READY_INVITE']);
56: }
````

## File: src/noteGenerator.ts
````typescript
 1: /**
 2:  * Generatore di note per gli inviti LinkedIn.
 3:  * Usa template predefiniti variati per evitare pattern ripetitivi.
 4:  * Tutte le note restano sotto i 300 caratteri (limite LinkedIn).
 5:  */
 6: 
 7: const NOTE_TEMPLATES: ReadonlyArray<(firstName: string) => string> = [
 8:     (n) => `Ciao ${n}, ho trovato il tuo profilo interessante e mi piacerebbe aggiungerti alla mia rete. A presto!`,
 9:     (n) => `Ciao ${n}, seguo il tuo lavoro con interesse. Sarebbe un piacere connetterci!`,
10:     (n) => `Salve ${n}, ho visto il tuo profilo e penso potremmo avere interessi in comune. Ti aggiungo volentieri!`,
11:     (n) => `Ciao ${n}, mi piacerebbe connettermi con te per ampliare la mia rete professionale. Buona giornata!`,
12:     (n) => `Ciao ${n}, ho apprezzato il tuo background professionale. Sarebbe bello entrare in contatto!`,
13:     (n) => `Salve ${n}, il tuo profilo ha attirato la mia attenzione. Ti propongo di connetterci!`,
14:     (n) => `Ciao ${n}, credo che possiamo trarre reciproco beneficio da questa connessione. A presto!`,
15:     (n) => `Ciao ${n}, mi farebbe piacere allargare la mia rete con professionisti come te. Collegati con me!`,
16: ];
17: 
18: /**
19:  * Ritorna una nota di invito personalizzata con il nome del lead.
20:  * La selezione del template è pseudo-casuale basata sul nome (deterministico
21:  * nella stessa sessione, variabile tra sessioni diverse).
22:  */
23: export function generateInviteNote(firstName: string): string {
24:     const name = firstName.trim() || 'collega';
25:     const index = Math.floor(Math.random() * NOTE_TEMPLATES.length);
26:     return NOTE_TEMPLATES[index](name);
27: }
````

## File: src/risk/incidentManager.ts
````typescript
 1: import { clearAutomationPause, createIncident, pushOutboxEvent, setAutomationPause, setRuntimeFlag } from '../core/repositories';
 2: import { sendTelegramAlert } from '../telemetry/alerts';
 3: 
 4: export async function quarantineAccount(type: string, details: Record<string, unknown>): Promise<number> {
 5:     const incidentId = await createIncident(type, 'CRITICAL', details);
 6:     await setRuntimeFlag('account_quarantine', 'true');
 7:     await pushOutboxEvent(
 8:         'incident.opened',
 9:         {
10:             incidentId,
11:             type,
12:             severity: 'CRITICAL',
13:             details,
14:         },
15:         `incident.opened:${incidentId}`
16:     );
17:     await sendTelegramAlert(`CRITICAL incident #${incidentId}: ${type}`);
18:     return incidentId;
19: }
20: 
21: export async function setQuarantine(enabled: boolean): Promise<void> {
22:     await setRuntimeFlag('account_quarantine', enabled ? 'true' : 'false');
23: }
24: 
25: export async function pauseAutomation(type: string, details: Record<string, unknown>, minutes: number): Promise<number> {
26:     const incidentId = await createIncident(type, 'WARN', details);
27:     const pausedUntil = await setAutomationPause(minutes, type);
28:     await pushOutboxEvent(
29:         'automation.paused',
30:         {
31:             incidentId,
32:             type,
33:             severity: 'WARN',
34:             pausedUntil,
35:             details,
36:         },
37:         `automation.paused:${incidentId}`
38:     );
39:     await sendTelegramAlert(`WARN incident #${incidentId}: ${type}. Automazione in pausa fino a ${pausedUntil ?? 'manual resume'}`);
40:     return incidentId;
41: }
42: 
43: export async function resumeAutomation(): Promise<void> {
44:     await clearAutomationPause();
45: }
````

## File: src/risk/riskEngine.ts
````typescript
 1: import { config } from '../config';
 2: import { RiskInputs, RiskSnapshot } from '../types/domain';
 3: 
 4: function clampScore(value: number): number {
 5:     return Math.max(0, Math.min(100, Math.round(value)));
 6: }
 7: 
 8: export function evaluateRisk(inputs: RiskInputs): RiskSnapshot {
 9:     const score = clampScore(
10:         inputs.errorRate * 40 +
11:         inputs.selectorFailureRate * 20 +
12:         inputs.pendingRatio * 25 +
13:         Math.min(30, inputs.challengeCount * 20) +
14:         inputs.inviteVelocityRatio * 15
15:     );
16: 
17:     let action: RiskSnapshot['action'] = 'NORMAL';
18:     if (score >= config.riskStopThreshold || inputs.pendingRatio >= config.pendingRatioStop || inputs.challengeCount > 0) {
19:         action = 'STOP';
20:     } else if (score >= config.riskWarnThreshold || inputs.pendingRatio >= config.pendingRatioWarn) {
21:         action = 'WARN';
22:     }
23: 
24:     return {
25:         score,
26:         pendingRatio: inputs.pendingRatio,
27:         errorRate: inputs.errorRate,
28:         selectorFailureRate: inputs.selectorFailureRate,
29:         challengeCount: inputs.challengeCount,
30:         inviteVelocityRatio: inputs.inviteVelocityRatio,
31:         action,
32:     };
33: }
34: 
35: export function calculateDynamicBudget(
36:     softCap: number,
37:     hardCap: number,
38:     alreadyConsumed: number,
39:     riskAction: RiskSnapshot['action']
40: ): number {
41:     if (alreadyConsumed >= hardCap) {
42:         return 0;
43:     }
44: 
45:     let effectiveCap = softCap;
46:     if (riskAction === 'WARN') {
47:         effectiveCap = Math.floor(softCap * 0.5);
48:     }
49:     if (riskAction === 'STOP') {
50:         effectiveCap = 0;
51:     }
52: 
53:     effectiveCap = Math.min(hardCap, Math.max(0, effectiveCap));
54:     return Math.max(0, effectiveCap - alreadyConsumed);
55: }
56: 
57: export interface CooldownDecision {
58:     activate: boolean;
59:     tier: 'none' | 'warn' | 'high';
60:     minutes: number;
61:     reason: string | null;
62: }
63: 
64: export function evaluateCooldownDecision(snapshot: RiskSnapshot): CooldownDecision {
65:     if (!config.cooldownEnabled) {
66:         return { activate: false, tier: 'none', minutes: 0, reason: null };
67:     }
68: 
69:     if (snapshot.action !== 'WARN') {
70:         return { activate: false, tier: 'none', minutes: 0, reason: null };
71:     }
72: 
73:     const high = snapshot.score >= config.cooldownHighScore || snapshot.pendingRatio >= config.cooldownPendingHighThreshold;
74:     if (high) {
75:         return {
76:             activate: true,
77:             tier: 'high',
78:             minutes: config.cooldownHighMinutes,
79:             reason: 'risk_cooldown_high',
80:         };
81:     }
82: 
83:     const warn = snapshot.score >= config.cooldownWarnScore || snapshot.pendingRatio >= config.cooldownPendingThreshold;
84:     if (warn) {
85:         return {
86:             activate: true,
87:             tier: 'warn',
88:             minutes: config.cooldownWarnMinutes,
89:             reason: 'risk_cooldown_warn',
90:         };
91:     }
92: 
93:     return { activate: false, tier: 'none', minutes: 0, reason: null };
94: }
````

## File: src/salesnav/listActions.ts
````typescript
  1: import { getAccountProfileById } from '../accountManager';
  2: import { checkLogin, closeBrowser, humanDelay, humanMouseMove, launchBrowser } from '../browser';
  3: import { normalizeLinkedInUrl } from '../linkedinUrl';
  4: import { navigateToSavedLists, SalesNavSavedList } from './listScraper';
  5: 
  6: export interface SalesNavActionResult {
  7:     ok: boolean;
  8:     accountId: string;
  9:     message: string;
 10:     listName?: string;
 11:     listUrl?: string | null;
 12: }
 13: 
 14: const CREATE_LIST_BUTTON_SELECTOR = [
 15:     'button:has-text("Create list")',
 16:     'button:has-text("Crea lista")',
 17:     'a:has-text("Create list")',
 18:     'a:has-text("Crea lista")',
 19: ].join(', ');
 20: 
 21: const LIST_NAME_INPUT_SELECTOR = [
 22:     'input[placeholder*="List name"]',
 23:     'input[placeholder*="Nome lista"]',
 24:     'input[name*="list"]',
 25:     'input[id*="list"]',
 26: ].join(', ');
 27: 
 28: const CREATE_LIST_CONFIRM_SELECTOR = [
 29:     'button:has-text("Create")',
 30:     'button:has-text("Crea")',
 31:     'button.artdeco-button--primary',
 32: ].join(', ');
 33: 
 34: const SAVE_TO_LIST_BUTTON_SELECTOR = [
 35:     'button:has-text("Save in list")',
 36:     'button:has-text("Salva in lista")',
 37:     'button:has-text("Save")',
 38:     'button:has-text("Salva")',
 39: ].join(', ');
 40: 
 41: const ADD_TO_LIST_CONFIRM_SELECTOR = [
 42:     'button:has-text("Save")',
 43:     'button:has-text("Salva")',
 44:     'button:has-text("Done")',
 45:     'button:has-text("Fatto")',
 46: ].join(', ');
 47: 
 48: function cleanText(value: string): string {
 49:     return value.replace(/\s+/g, ' ').trim();
 50: }
 51: 
 52: function normalizeListName(value: string): string {
 53:     return cleanText(value).toLowerCase();
 54: }
 55: 
 56: function matchSavedListByName(lists: SalesNavSavedList[], listName: string): SalesNavSavedList | null {
 57:     const target = normalizeListName(listName);
 58:     if (!target) return null;
 59: 
 60:     const exact = lists.find((entry) => normalizeListName(entry.name) === target);
 61:     if (exact) return exact;
 62: 
 63:     const partial = lists.find((entry) => {
 64:         const name = normalizeListName(entry.name);
 65:         return name.includes(target) || target.includes(name);
 66:     });
 67:     return partial ?? null;
 68: }
 69: 
 70: async function resolveSavedListUrl(page: import('playwright').Page, listName: string): Promise<string | null> {
 71:     try {
 72:         const lists = await navigateToSavedLists(page);
 73:         const matched = matchSavedListByName(lists, listName);
 74:         return matched?.url ?? null;
 75:     } catch {
 76:         return null;
 77:     }
 78: }
 79: 
 80: export async function createSalesNavList(listName: string, accountId?: string): Promise<SalesNavActionResult> {
 81:     const account = getAccountProfileById(accountId);
 82:     const normalizedListName = cleanText(listName);
 83:     if (!normalizedListName) {
 84:         return { ok: false, accountId: account.id, message: 'Nome lista non valido' };
 85:     }
 86: 
 87:     const session = await launchBrowser({
 88:         sessionDir: account.sessionDir,
 89:         proxy: account.proxy,
 90:     });
 91:     try {
 92:         const loggedIn = await checkLogin(session.page);
 93:         if (!loggedIn) {
 94:             return { ok: false, accountId: account.id, message: 'Sessione non autenticata' };
 95:         }
 96: 
 97:         await session.page.goto('https://www.linkedin.com/sales/lists/people/', { waitUntil: 'domcontentloaded' });
 98:         await humanDelay(session.page, 1400, 2600);
 99: 
100:         const createButton = session.page.locator(CREATE_LIST_BUTTON_SELECTOR).first();
101:         if (await createButton.count() === 0) {
102:             return { ok: false, accountId: account.id, message: 'Bottone Create list non trovato' };
103:         }
104:         await humanMouseMove(session.page, CREATE_LIST_BUTTON_SELECTOR);
105:         await humanDelay(session.page, 150, 350);
106:         await createButton.click();
107:         await humanDelay(session.page, 800, 1600);
108: 
109:         const nameInput = session.page.locator(LIST_NAME_INPUT_SELECTOR).first();
110:         if (await nameInput.count() === 0) {
111:             return { ok: false, accountId: account.id, message: 'Input nome lista non trovato' };
112:         }
113:         await nameInput.fill(normalizedListName);
114:         await humanDelay(session.page, 450, 900);
115: 
116:         const confirmButton = session.page.locator(CREATE_LIST_CONFIRM_SELECTOR).first();
117:         if (await confirmButton.count() === 0) {
118:             return { ok: false, accountId: account.id, message: 'Bottone conferma creazione non trovato' };
119:         }
120:         await humanMouseMove(session.page, CREATE_LIST_CONFIRM_SELECTOR);
121:         await humanDelay(session.page, 120, 320);
122:         await confirmButton.click();
123:         await humanDelay(session.page, 1400, 2600);
124:         const resolvedListUrl = await resolveSavedListUrl(session.page, normalizedListName);
125: 
126:         return {
127:             ok: true,
128:             accountId: account.id,
129:             listName: normalizedListName,
130:             listUrl: resolvedListUrl,
131:             message: `Lista creata (best-effort): ${normalizedListName}`,
132:         };
133:     } finally {
134:         await closeBrowser(session);
135:     }
136: }
137: 
138: export async function addLeadToSalesNavList(leadLinkedinUrl: string, listName: string, accountId?: string): Promise<SalesNavActionResult> {
139:     const account = getAccountProfileById(accountId);
140:     const normalizedListName = cleanText(listName);
141:     const normalizedLeadUrl = normalizeLinkedInUrl(leadLinkedinUrl);
142:     if (!normalizedListName) {
143:         return { ok: false, accountId: account.id, message: 'Nome lista non valido' };
144:     }
145:     if (!normalizedLeadUrl) {
146:         return { ok: false, accountId: account.id, message: 'URL lead non valido' };
147:     }
148: 
149:     const session = await launchBrowser({
150:         sessionDir: account.sessionDir,
151:         proxy: account.proxy,
152:     });
153:     try {
154:         const loggedIn = await checkLogin(session.page);
155:         if (!loggedIn) {
156:             return { ok: false, accountId: account.id, message: 'Sessione non autenticata' };
157:         }
158: 
159:         await session.page.goto(normalizedLeadUrl, { waitUntil: 'domcontentloaded' });
160:         await humanDelay(session.page, 1400, 2600);
161: 
162:         const saveButton = session.page.locator(SAVE_TO_LIST_BUTTON_SELECTOR).first();
163:         if (await saveButton.count() === 0) {
164:             return { ok: false, accountId: account.id, message: 'Bottone Save in list non trovato' };
165:         }
166:         await humanMouseMove(session.page, SAVE_TO_LIST_BUTTON_SELECTOR);
167:         await humanDelay(session.page, 160, 340);
168:         await saveButton.click();
169:         await humanDelay(session.page, 900, 1800);
170: 
171:         const listOption = session.page.locator(`text="${normalizedListName}"`).first();
172:         if (await listOption.count() === 0) {
173:             return {
174:                 ok: false,
175:                 accountId: account.id,
176:                 message: `Lista non trovata nel popup: ${normalizedListName}`,
177:             };
178:         }
179:         await listOption.click();
180:         await humanDelay(session.page, 400, 900);
181: 
182:         const confirmButton = session.page.locator(ADD_TO_LIST_CONFIRM_SELECTOR).first();
183:         if (await confirmButton.count() > 0) {
184:             await humanMouseMove(session.page, ADD_TO_LIST_CONFIRM_SELECTOR);
185:             await humanDelay(session.page, 120, 300);
186:             await confirmButton.click();
187:         }
188:         await humanDelay(session.page, 900, 1800);
189:         const resolvedListUrl = await resolveSavedListUrl(session.page, normalizedListName);
190:         return {
191:             ok: true,
192:             accountId: account.id,
193:             listName: normalizedListName,
194:             listUrl: resolvedListUrl,
195:             message: `Lead aggiunto (best-effort) a lista: ${normalizedListName}`,
196:         };
197:     } finally {
198:         await closeBrowser(session);
199:     }
200: }
````

## File: src/salesnav/listScraper.ts
````typescript
  1: import { Page } from 'playwright';
  2: import { humanDelay, humanMouseMove, simulateHumanReading } from '../browser';
  3: import { isLinkedInUrl, normalizeLinkedInUrl } from '../linkedinUrl';
  4: 
  5: export interface SalesNavSavedList {
  6:     name: string;
  7:     url: string;
  8: }
  9: 
 10: export interface SalesNavLeadCandidate {
 11:     linkedinUrl: string;
 12:     firstName: string;
 13:     lastName: string;
 14:     jobTitle: string;
 15:     accountName: string;
 16:     website: string;
 17: }
 18: 
 19: export interface SalesNavListScrapeOptions {
 20:     listUrl: string;
 21:     maxPages: number;
 22:     leadLimit: number;
 23: }
 24: 
 25: export interface SalesNavListScrapeResult {
 26:     pagesVisited: number;
 27:     candidatesDiscovered: number;
 28:     uniqueCandidates: number;
 29:     leads: SalesNavLeadCandidate[];
 30: }
 31: 
 32: interface RawLeadCandidate {
 33:     href: string;
 34:     anchorText: string;
 35:     lines: string[];
 36: }
 37: 
 38: const SALESNAV_LISTS_URL = 'https://www.linkedin.com/sales/lists/people/';
 39: 
 40: const NEXT_PAGE_SELECTOR = [
 41:     'button[aria-label="Next"]',
 42:     'button[aria-label*="Avanti"]',
 43:     'button.artdeco-pagination__button--next',
 44:     'button:has-text("Next")',
 45:     'button:has-text("Avanti")',
 46: ].join(', ');
 47: 
 48: const SHOW_MORE_SELECTOR = [
 49:     'button:has-text("Show more")',
 50:     'button:has-text("Mostra altri")',
 51:     'button:has-text("Show results")',
 52:     'button:has-text("Mostra risultati")',
 53: ].join(', ');
 54: 
 55: function cleanText(value: string): string {
 56:     return value.replace(/\s+/g, ' ').trim();
 57: }
 58: 
 59: function splitName(fullName: string): { firstName: string; lastName: string } {
 60:     const cleaned = cleanText(fullName)
 61:         .replace(/^(dr|dott|mr|mrs|ms)\.?\s+/i, '')
 62:         .trim();
 63:     if (!cleaned) {
 64:         return { firstName: '', lastName: '' };
 65:     }
 66:     const parts = cleaned.split(' ');
 67:     if (parts.length === 1) {
 68:         return { firstName: parts[0], lastName: '' };
 69:     }
 70:     return {
 71:         firstName: parts[0],
 72:         lastName: parts.slice(1).join(' '),
 73:     };
 74: }
 75: 
 76: function looksLikeNoise(line: string): boolean {
 77:     const normalized = line.toLowerCase();
 78:     if (!normalized) return true;
 79:     return normalized.includes('save')
 80:         || normalized.includes('salva')
 81:         || normalized.includes('message')
 82:         || normalized.includes('messaggio')
 83:         || normalized.includes('connect')
 84:         || normalized.includes('collegati')
 85:         || normalized.includes('mutual')
 86:         || normalized.includes('shared')
 87:         || normalized.includes('lead filter')
 88:         || normalized.includes('filtro')
 89:         || normalized.includes('view profile')
 90:         || normalized.includes('visualizza profilo')
 91:         || normalized.includes('sales navigator');
 92: }
 93: 
 94: function pickJobAndAccount(lines: string[], fullName: string): { jobTitle: string; accountName: string } {
 95:     const normalizedName = cleanText(fullName).toLowerCase();
 96:     const candidates = lines
 97:         .map(cleanText)
 98:         .filter((line) => line.length > 1)
 99:         .filter((line) => line.toLowerCase() !== normalizedName)
100:         .filter((line) => !looksLikeNoise(line));
101: 
102:     let jobTitle = '';
103:     let accountName = '';
104: 
105:     for (const line of candidates) {
106:         if (!jobTitle) {
107:             jobTitle = line;
108:         }
109:         if (!accountName) {
110:             const atMatch = line.match(/\b(?:at|presso)\s+(.+)/i);
111:             if (atMatch?.[1]) {
112:                 accountName = cleanText(atMatch[1]);
113:             }
114:         }
115:     }
116: 
117:     if (!accountName && candidates.length > 1) {
118:         accountName = candidates[1];
119:     }
120:     if (!accountName && candidates.length === 1) {
121:         accountName = candidates[0];
122:     }
123: 
124:     return { jobTitle, accountName };
125: }
126: 
127: function parseRawLeadCandidate(raw: RawLeadCandidate): SalesNavLeadCandidate | null {
128:     const normalizedUrl = normalizeLinkedInUrl(raw.href);
129:     if (!isLinkedInUrl(normalizedUrl)) {
130:         return null;
131:     }
132: 
133:     const fullName = cleanText(raw.anchorText) || cleanText(raw.lines[0] ?? '');
134:     const { firstName, lastName } = splitName(fullName);
135:     const { jobTitle, accountName } = pickJobAndAccount(raw.lines, fullName);
136:     return {
137:         linkedinUrl: normalizedUrl,
138:         firstName,
139:         lastName,
140:         jobTitle,
141:         accountName: accountName || fullName,
142:         website: '',
143:     };
144: }
145: 
146: async function extractSavedLists(page: Page): Promise<SalesNavSavedList[]> {
147:     const rows = await page.evaluate(() => {
148:         const seen = new Set<string>();
149:         const results: Array<{ name: string; url: string }> = [];
150:         const anchors = Array.from(document.querySelectorAll('a[href]')) as HTMLAnchorElement[];
151:         for (const anchor of anchors) {
152:             const href = anchor.href || '';
153:             if (!/linkedin\.com\/sales\/lists\/people\//i.test(href)) continue;
154:             if (href.includes('/sales/lists/people/')) {
155:                 // ignore the root page link itself
156:                 const normalizedHref = href.split('#')[0];
157:                 const pathname = (() => {
158:                     try {
159:                         return new URL(normalizedHref).pathname;
160:                     } catch {
161:                         return '';
162:                     }
163:                 })();
164:                 if (/^\/sales\/lists\/people\/?$/i.test(pathname)) continue;
165:                 if (seen.has(normalizedHref)) continue;
166:                 seen.add(normalizedHref);
167:                 const parentText = (anchor.closest('li, article, div') as HTMLElement | null)?.innerText ?? '';
168:                 const name = (anchor.innerText || parentText || '').replace(/\s+/g, ' ').trim();
169:                 if (!name) continue;
170:                 results.push({ name, url: normalizedHref });
171:             }
172:         }
173:         return results;
174:     });
175: 
176:     const byUrl = new Map<string, SalesNavSavedList>();
177:     for (const row of rows) {
178:         const name = cleanText(row.name);
179:         const url = cleanText(row.url);
180:         if (!name || !url) continue;
181:         byUrl.set(url, { name, url });
182:     }
183:     return Array.from(byUrl.values());
184: }
185: 
186: async function extractRawLeadCandidates(page: Page): Promise<RawLeadCandidate[]> {
187:     return page.evaluate(() => {
188:         const matches: RawLeadCandidate[] = [];
189:         const seen = new Set<string>();
190: 
191:         const anchors = Array.from(document.querySelectorAll('a[href]')) as HTMLAnchorElement[];
192:         for (const anchor of anchors) {
193:             const href = anchor.href || anchor.getAttribute('href') || '';
194:             if (!href) continue;
195:             if (!/linkedin\.com\/(sales\/lead|in\/)/i.test(href)) continue;
196: 
197:             const dedupeKey = href.split('#')[0];
198:             if (seen.has(dedupeKey)) continue;
199:             seen.add(dedupeKey);
200: 
201:             const container = anchor.closest('li, article, .artdeco-entity-lockup, [data-test-search-result]') as HTMLElement | null;
202:             const textSource = container?.innerText ?? anchor.innerText ?? '';
203:             const lines = textSource
204:                 .split('\n')
205:                 .map((line) => line.replace(/\s+/g, ' ').trim())
206:                 .filter((line) => line.length > 0)
207:                 .slice(0, 8);
208: 
209:             matches.push({
210:                 href: dedupeKey,
211:                 anchorText: (anchor.innerText || '').replace(/\s+/g, ' ').trim(),
212:                 lines,
213:             });
214:         }
215: 
216:         return matches;
217:     });
218: }
219: 
220: async function clickShowMoreIfPresent(page: Page): Promise<boolean> {
221:     const button = page.locator(SHOW_MORE_SELECTOR).first();
222:     if (await button.count() === 0) {
223:         return false;
224:     }
225:     const disabled = await button.isDisabled().catch(() => false);
226:     if (disabled) {
227:         return false;
228:     }
229:     await humanMouseMove(page, SHOW_MORE_SELECTOR);
230:     await humanDelay(page, 180, 450);
231:     await button.click();
232:     await humanDelay(page, 1200, 2200);
233:     return true;
234: }
235: 
236: async function goToNextPage(page: Page): Promise<boolean> {
237:     const nextButton = page.locator(NEXT_PAGE_SELECTOR).first();
238:     if (await nextButton.count() === 0) {
239:         return false;
240:     }
241: 
242:     const ariaDisabled = (await nextButton.getAttribute('aria-disabled'))?.toLowerCase() === 'true';
243:     const disabled = ariaDisabled || await nextButton.isDisabled().catch(() => false);
244:     if (disabled) {
245:         return false;
246:     }
247: 
248:     await humanMouseMove(page, NEXT_PAGE_SELECTOR);
249:     await humanDelay(page, 180, 420);
250:     await nextButton.click();
251:     await humanDelay(page, 1300, 2600);
252:     return true;
253: }
254: 
255: export async function navigateToSavedLists(page: Page): Promise<SalesNavSavedList[]> {
256:     await page.goto(SALESNAV_LISTS_URL, { waitUntil: 'domcontentloaded' });
257:     await humanDelay(page, 1800, 3200);
258:     await simulateHumanReading(page);
259:     return extractSavedLists(page);
260: }
261: 
262: export async function scrapeLeadsFromSalesNavList(page: Page, options: SalesNavListScrapeOptions): Promise<SalesNavListScrapeResult> {
263:     const maxPages = Math.max(1, options.maxPages);
264:     const leadLimit = Math.max(1, options.leadLimit);
265: 
266:     await page.goto(options.listUrl, { waitUntil: 'domcontentloaded' });
267:     await humanDelay(page, 1500, 2800);
268: 
269:     const byUrl = new Map<string, SalesNavLeadCandidate>();
270:     let pagesVisited = 0;
271:     let candidatesDiscovered = 0;
272: 
273:     for (let pageNumber = 1; pageNumber <= maxPages; pageNumber++) {
274:         pagesVisited = pageNumber;
275:         await simulateHumanReading(page);
276: 
277:         // Prova 1-2 volte a espandere risultati nella pagina corrente.
278:         for (let i = 0; i < 2; i++) {
279:             const expanded = await clickShowMoreIfPresent(page);
280:             if (!expanded) break;
281:             await simulateHumanReading(page);
282:         }
283: 
284:         const rawCandidates = await extractRawLeadCandidates(page);
285:         candidatesDiscovered += rawCandidates.length;
286:         for (const raw of rawCandidates) {
287:             const parsed = parseRawLeadCandidate(raw);
288:             if (!parsed) continue;
289:             byUrl.set(parsed.linkedinUrl, parsed);
290:             if (byUrl.size >= leadLimit) {
291:                 break;
292:             }
293:         }
294: 
295:         if (byUrl.size >= leadLimit) {
296:             break;
297:         }
298:         if (pageNumber >= maxPages) {
299:             break;
300:         }
301: 
302:         const moved = await goToNextPage(page);
303:         if (!moved) {
304:             break;
305:         }
306:     }
307: 
308:     return {
309:         pagesVisited,
310:         candidatesDiscovered,
311:         uniqueCandidates: byUrl.size,
312:         leads: Array.from(byUrl.values()).slice(0, leadLimit),
313:     };
314: }
````

## File: src/security/filesystem.ts
````typescript
 1: import fs from 'fs';
 2: import path from 'path';
 3: 
 4: function chmodSafe(targetPath: string, mode: number): void {
 5:     if (process.platform === 'win32') {
 6:         return;
 7:     }
 8:     try {
 9:         fs.chmodSync(targetPath, mode);
10:     } catch {
11:         // Best effort: non bloccare runtime in caso di FS non compatibile.
12:     }
13: }
14: 
15: export function ensureDirectoryPrivate(directoryPath: string): void {
16:     if (!fs.existsSync(directoryPath)) {
17:         fs.mkdirSync(directoryPath, { recursive: true });
18:     }
19:     chmodSafe(directoryPath, 0o700);
20: }
21: 
22: export function ensureParentDirectoryPrivate(filePath: string): void {
23:     const directoryPath = path.dirname(filePath);
24:     ensureDirectoryPrivate(directoryPath);
25: }
26: 
27: export function ensureFilePrivate(filePath: string): void {
28:     if (!fs.existsSync(filePath)) {
29:         return;
30:     }
31:     chmodSafe(filePath, 0o600);
32: }
````

## File: src/security/redaction.ts
````typescript
 1: const MAX_RECURSION_DEPTH = 6;
 2: const REDACTED = '[REDACTED]';
 3: 
 4: const SENSITIVE_KEY_PATTERN = /(token|secret|password|pass|key|cookie|authorization|session|bearer)/i;
 5: 
 6: const JWT_PATTERN = /\b[A-Za-z0-9_-]{20,}\.[A-Za-z0-9_-]{20,}\.[A-Za-z0-9_-]{20,}\b/g;
 7: const SUPABASE_KEY_PATTERN = /\bsb_(publishable|secret)_[A-Za-z0-9_-]{20,}\b/gi;
 8: const API_KEY_PATTERN = /\b(sk|pk|rk)_[A-Za-z0-9_-]{16,}\b/gi;
 9: const TELEGRAM_BOT_TOKEN_PATTERN = /\b\d{8,}:[A-Za-z0-9_-]{20,}\b/g;
10: 
11: function sanitizeString(input: string): string {
12:     return input
13:         .replace(JWT_PATTERN, REDACTED)
14:         .replace(SUPABASE_KEY_PATTERN, REDACTED)
15:         .replace(API_KEY_PATTERN, REDACTED)
16:         .replace(TELEGRAM_BOT_TOKEN_PATTERN, REDACTED);
17: }
18: 
19: function sanitizeArray(input: unknown[], depth: number): unknown[] {
20:     if (depth > MAX_RECURSION_DEPTH) {
21:         return ['[MAX_DEPTH_REACHED]'];
22:     }
23:     return input.map((item) => sanitizeForLogs(item, depth + 1));
24: }
25: 
26: function sanitizeObject(input: Record<string, unknown>, depth: number): Record<string, unknown> {
27:     if (depth > MAX_RECURSION_DEPTH) {
28:         return { note: '[MAX_DEPTH_REACHED]' };
29:     }
30: 
31:     const output: Record<string, unknown> = {};
32:     for (const [key, value] of Object.entries(input)) {
33:         if (SENSITIVE_KEY_PATTERN.test(key)) {
34:             output[key] = REDACTED;
35:             continue;
36:         }
37:         output[key] = sanitizeForLogs(value, depth + 1);
38:     }
39:     return output;
40: }
41: 
42: export function sanitizeForLogs<T>(value: T, depth: number = 0): T {
43:     if (value === null || value === undefined) {
44:         return value;
45:     }
46: 
47:     if (typeof value === 'string') {
48:         return sanitizeString(value) as T;
49:     }
50: 
51:     if (typeof value === 'number' || typeof value === 'boolean') {
52:         return value;
53:     }
54: 
55:     if (Array.isArray(value)) {
56:         return sanitizeArray(value, depth) as T;
57:     }
58: 
59:     if (typeof value === 'object') {
60:         return sanitizeObject(value as Record<string, unknown>, depth) as T;
61:     }
62: 
63:     return String(value) as T;
64: }
````

## File: src/sync/eventSync.ts
````typescript
 1: import { config, EventSyncSink } from '../config';
 2: import { SyncStatus, getSyncStatus as getSupabaseSyncStatus, runSupabaseSyncOnce } from './supabaseSyncWorker';
 3: import { WebhookSyncStatus, getWebhookSyncStatus, runWebhookSyncOnce } from './webhookSyncWorker';
 4: 
 5: export interface EventSyncStatus {
 6:     activeSink: EventSyncSink;
 7:     enabled: boolean;
 8:     configured: boolean;
 9:     pendingOutbox: number;
10:     warning: string | null;
11:     supabase: SyncStatus;
12:     webhook: WebhookSyncStatus;
13: }
14: 
15: function buildSinkWarning(supabase: SyncStatus, webhook: WebhookSyncStatus): string | null {
16:     if (config.supabaseSyncEnabled && config.webhookSyncEnabled) {
17:         return `Entrambi i sink sono attivi ma verra usato solo EVENT_SYNC_SINK=${config.eventSyncSink}.`;
18:     }
19:     if (config.eventSyncSink === 'SUPABASE' && !config.supabaseSyncEnabled) {
20:         return 'EVENT_SYNC_SINK=SUPABASE ma SUPABASE_SYNC_ENABLED=false.';
21:     }
22:     if (config.eventSyncSink === 'WEBHOOK' && !config.webhookSyncEnabled) {
23:         return 'EVENT_SYNC_SINK=WEBHOOK ma WEBHOOK_SYNC_ENABLED=false.';
24:     }
25:     if (config.eventSyncSink === 'SUPABASE' && config.supabaseSyncEnabled && !supabase.configured) {
26:         return 'SUPABASE_SYNC_ENABLED=true ma SUPABASE_URL/SUPABASE_SERVICE_ROLE_KEY non configurati.';
27:     }
28:     if (config.eventSyncSink === 'WEBHOOK' && config.webhookSyncEnabled && !webhook.configured) {
29:         return 'WEBHOOK_SYNC_ENABLED=true ma WEBHOOK_SYNC_URL non configurato.';
30:     }
31:     return null;
32: }
33: 
34: export async function getEventSyncStatus(): Promise<EventSyncStatus> {
35:     const [supabase, webhook] = await Promise.all([getSupabaseSyncStatus(), getWebhookSyncStatus()]);
36:     const warning = buildSinkWarning(supabase, webhook);
37: 
38:     if (config.eventSyncSink === 'NONE') {
39:         return {
40:             activeSink: 'NONE',
41:             enabled: false,
42:             configured: true,
43:             pendingOutbox: supabase.pendingOutbox,
44:             warning,
45:             supabase,
46:             webhook,
47:         };
48:     }
49: 
50:     const active = config.eventSyncSink === 'WEBHOOK' ? webhook : supabase;
51:     return {
52:         activeSink: config.eventSyncSink,
53:         enabled: active.enabled,
54:         configured: active.configured,
55:         pendingOutbox: active.pendingOutbox,
56:         warning,
57:         supabase,
58:         webhook,
59:     };
60: }
61: 
62: export async function runEventSyncOnce(): Promise<void> {
63:     if (config.eventSyncSink === 'NONE') {
64:         return;
65:     }
66: 
67:     if (config.eventSyncSink === 'WEBHOOK') {
68:         await runWebhookSyncOnce();
69:         return;
70:     }
71: 
72:     await runSupabaseSyncOnce();
73: }
````

## File: src/sync/supabase.schema.sql
````sql
 1: create table if not exists public.cp_events (
 2:     id bigserial primary key,
 3:     topic text not null,
 4:     payload jsonb not null,
 5:     idempotency_key text not null unique,
 6:     created_at timestamptz not null default now()
 7: );
 8: 
 9: create table if not exists public.cp_daily_kpis (
10:     id bigserial primary key,
11:     local_date date not null,
12:     metric_name text not null,
13:     metric_value numeric not null,
14:     created_at timestamptz not null default now()
15: );
16: 
17: create table if not exists public.cp_incidents (
18:     id bigserial primary key,
19:     incident_type text not null,
20:     severity text not null,
21:     details jsonb not null,
22:     opened_at timestamptz not null default now()
23: );
24: 
25: create table if not exists public.cp_worker_runs (
26:     id bigserial primary key,
27:     worker_name text not null,
28:     status text not null,
29:     details jsonb not null,
30:     created_at timestamptz not null default now()
31: );
````

## File: src/sync/supabaseSyncWorker.ts
````typescript
  1: import { createClient, SupabaseClient } from '@supabase/supabase-js';
  2: import { config } from '../config';
  3: import { sendTelegramAlert } from '../telemetry/alerts';
  4: import { logInfo, logWarn } from '../telemetry/logger';
  5: import {
  6:     countPendingOutboxEvents,
  7:     getPendingOutboxEvents,
  8:     markOutboxDelivered,
  9:     markOutboxPermanentFailure,
 10:     markOutboxRetry,
 11: } from '../core/repositories';
 12: 
 13: let client: SupabaseClient | null = null;
 14: 
 15: function getClient(): SupabaseClient | null {
 16:     if (!config.supabaseSyncEnabled) return null;
 17:     if (!config.supabaseUrl || !config.supabaseServiceRoleKey) return null;
 18:     if (!client) {
 19:         client = createClient(config.supabaseUrl, config.supabaseServiceRoleKey, {
 20:             auth: {
 21:                 persistSession: false,
 22:                 autoRefreshToken: false,
 23:             },
 24:         });
 25:     }
 26:     return client;
 27: }
 28: 
 29: function retryDelayMs(attempt: number): number {
 30:     const base = config.supabaseSyncIntervalMs;
 31:     const jitter = Math.floor(Math.random() * 500);
 32:     return base * Math.pow(2, Math.max(0, attempt - 1)) + jitter;
 33: }
 34: 
 35: function parseOutboxPayload(raw: string): Record<string, unknown> {
 36:     try {
 37:         const parsed = JSON.parse(raw) as unknown;
 38:         if (parsed && typeof parsed === 'object') {
 39:             return parsed as Record<string, unknown>;
 40:         }
 41:     } catch {
 42:         // fallback sotto
 43:     }
 44:     return { raw };
 45: }
 46: 
 47: export interface SyncStatus {
 48:     enabled: boolean;
 49:     configured: boolean;
 50:     pendingOutbox: number;
 51: }
 52: 
 53: export async function getSyncStatus(): Promise<SyncStatus> {
 54:     const pendingOutbox = await countPendingOutboxEvents();
 55:     return {
 56:         enabled: config.supabaseSyncEnabled,
 57:         configured: !!(config.supabaseUrl && config.supabaseServiceRoleKey),
 58:         pendingOutbox,
 59:     };
 60: }
 61: 
 62: export async function runSupabaseSyncOnce(): Promise<void> {
 63:     const supabase = getClient();
 64:     if (!supabase) {
 65:         return;
 66:     }
 67: 
 68:     const events = await getPendingOutboxEvents(config.supabaseSyncBatchSize);
 69:     if (events.length === 0) {
 70:         return;
 71:     }
 72: 
 73:     let sent = 0;
 74:     let failed = 0;
 75:     let permanentFailures = 0;
 76:     for (const event of events) {
 77:         const payload = {
 78:             topic: event.topic,
 79:             payload: parseOutboxPayload(event.payload_json),
 80:             idempotency_key: event.idempotency_key,
 81:             created_at: event.created_at,
 82:         };
 83: 
 84:         const { error } = await supabase.from('cp_events').upsert(payload, {
 85:             onConflict: 'idempotency_key',
 86:             ignoreDuplicates: false,
 87:         });
 88: 
 89:         if (error) {
 90:             failed += 1;
 91:             const attempts = event.attempts + 1;
 92:             if (attempts >= config.supabaseSyncMaxRetries) {
 93:                 permanentFailures += 1;
 94:                 await markOutboxPermanentFailure(event.id, attempts, error.message);
 95:                 await logWarn('supabase.sync.event.permanent_failure', {
 96:                     eventId: event.id,
 97:                     idempotencyKey: event.idempotency_key,
 98:                     attempts,
 99:                     maxRetries: config.supabaseSyncMaxRetries,
100:                     error: error.message,
101:                 });
102:             } else {
103:                 const delay = retryDelayMs(attempts);
104:                 await markOutboxRetry(event.id, attempts, delay, error.message);
105:             }
106:         } else {
107:             sent += 1;
108:             await markOutboxDelivered(event.id);
109:         }
110:     }
111: 
112:     await logInfo('supabase.sync.batch', {
113:         sent,
114:         failed,
115:         permanentFailures,
116:         batchSize: events.length,
117:         maxRetries: config.supabaseSyncMaxRetries,
118:     });
119: 
120:     const pending = await countPendingOutboxEvents();
121:     if (pending > config.outboxAlertBacklog) {
122:         await logWarn('supabase.sync.backlog_high', { pending, threshold: config.outboxAlertBacklog });
123:         await sendTelegramAlert(`Outbox backlog alto: ${pending} eventi pendenti`);
124:     }
125: }
````

## File: src/sync/webhookSyncWorker.ts
````typescript
  1: import { createHmac } from 'crypto';
  2: import { config } from '../config';
  3: import { sendTelegramAlert } from '../telemetry/alerts';
  4: import { logInfo, logWarn } from '../telemetry/logger';
  5: import {
  6:     countPendingOutboxEvents,
  7:     getPendingOutboxEvents,
  8:     markOutboxDelivered,
  9:     markOutboxPermanentFailure,
 10:     markOutboxRetry,
 11: } from '../core/repositories';
 12: 
 13: function retryDelayMs(attempt: number): number {
 14:     const base = config.supabaseSyncIntervalMs;
 15:     const jitter = Math.floor(Math.random() * 500);
 16:     return base * Math.pow(2, Math.max(0, attempt - 1)) + jitter;
 17: }
 18: 
 19: function parseOutboxPayload(raw: string): Record<string, unknown> {
 20:     try {
 21:         const parsed = JSON.parse(raw) as unknown;
 22:         if (parsed && typeof parsed === 'object') {
 23:             return parsed as Record<string, unknown>;
 24:         }
 25:     } catch {
 26:         // fallback sotto
 27:     }
 28:     return { raw };
 29: }
 30: 
 31: function buildWebhookSignature(payload: string): string | null {
 32:     const secret = config.webhookSyncSecret;
 33:     if (!secret) {
 34:         return null;
 35:     }
 36:     const signature = createHmac('sha256', secret).update(payload, 'utf8').digest('hex');
 37:     return `sha256=${signature}`;
 38: }
 39: 
 40: function endpointHost(rawUrl: string): string | null {
 41:     try {
 42:         return new URL(rawUrl).host;
 43:     } catch {
 44:         return null;
 45:     }
 46: }
 47: 
 48: export interface WebhookSyncStatus {
 49:     enabled: boolean;
 50:     configured: boolean;
 51:     pendingOutbox: number;
 52:     endpointHost: string | null;
 53: }
 54: 
 55: export async function getWebhookSyncStatus(): Promise<WebhookSyncStatus> {
 56:     const pendingOutbox = await countPendingOutboxEvents();
 57:     const configured = !!config.webhookSyncUrl;
 58:     return {
 59:         enabled: config.webhookSyncEnabled,
 60:         configured,
 61:         pendingOutbox,
 62:         endpointHost: configured ? endpointHost(config.webhookSyncUrl) : null,
 63:     };
 64: }
 65: 
 66: export async function runWebhookSyncOnce(): Promise<void> {
 67:     if (!config.webhookSyncEnabled || !config.webhookSyncUrl) {
 68:         return;
 69:     }
 70: 
 71:     const events = await getPendingOutboxEvents(config.webhookSyncBatchSize);
 72:     if (events.length === 0) {
 73:         return;
 74:     }
 75: 
 76:     let sent = 0;
 77:     let failed = 0;
 78:     let permanentFailures = 0;
 79: 
 80:     for (const event of events) {
 81:         const payload = {
 82:             topic: event.topic,
 83:             payload: parseOutboxPayload(event.payload_json),
 84:             idempotencyKey: event.idempotency_key,
 85:             createdAt: event.created_at,
 86:         };
 87: 
 88:         const body = JSON.stringify(payload);
 89:         const signature = buildWebhookSignature(body);
 90:         const headers: Record<string, string> = {
 91:             'content-type': 'application/json',
 92:             'x-idempotency-key': event.idempotency_key,
 93:             'x-event-topic': event.topic,
 94:         };
 95:         if (signature) {
 96:             headers['x-signature-sha256'] = signature;
 97:         }
 98: 
 99:         try {
100:             const response = await fetch(config.webhookSyncUrl, {
101:                 method: 'POST',
102:                 headers,
103:                 body,
104:                 signal: AbortSignal.timeout(config.webhookSyncTimeoutMs),
105:             });
106: 
107:             if (!response.ok) {
108:                 failed += 1;
109:                 const responseText = (await response.text().catch(() => '')).slice(0, 500);
110:                 const errorMessage = `HTTP_${response.status}:${response.statusText}${responseText ? `:${responseText}` : ''}`;
111:                 const attempts = event.attempts + 1;
112:                 if (attempts >= config.webhookSyncMaxRetries) {
113:                     permanentFailures += 1;
114:                     await markOutboxPermanentFailure(event.id, attempts, errorMessage);
115:                     await logWarn('webhook.sync.event.permanent_failure', {
116:                         eventId: event.id,
117:                         idempotencyKey: event.idempotency_key,
118:                         attempts,
119:                         maxRetries: config.webhookSyncMaxRetries,
120:                         error: errorMessage,
121:                     });
122:                 } else {
123:                     const delay = retryDelayMs(attempts);
124:                     await markOutboxRetry(event.id, attempts, delay, errorMessage);
125:                 }
126:                 continue;
127:             }
128: 
129:             sent += 1;
130:             await markOutboxDelivered(event.id);
131:         } catch (error) {
132:             failed += 1;
133:             const attempts = event.attempts + 1;
134:             const message = error instanceof Error ? error.message : String(error);
135:             if (attempts >= config.webhookSyncMaxRetries) {
136:                 permanentFailures += 1;
137:                 await markOutboxPermanentFailure(event.id, attempts, message);
138:                 await logWarn('webhook.sync.event.permanent_failure', {
139:                     eventId: event.id,
140:                     idempotencyKey: event.idempotency_key,
141:                     attempts,
142:                     maxRetries: config.webhookSyncMaxRetries,
143:                     error: message,
144:                 });
145:             } else {
146:                 const delay = retryDelayMs(attempts);
147:                 await markOutboxRetry(event.id, attempts, delay, message);
148:             }
149:         }
150:     }
151: 
152:     await logInfo('webhook.sync.batch', {
153:         sent,
154:         failed,
155:         permanentFailures,
156:         batchSize: events.length,
157:         maxRetries: config.webhookSyncMaxRetries,
158:         endpointHost: endpointHost(config.webhookSyncUrl),
159:     });
160: 
161:     const pending = await countPendingOutboxEvents();
162:     if (pending > config.outboxAlertBacklog) {
163:         await logWarn('webhook.sync.backlog_high', { pending, threshold: config.outboxAlertBacklog });
164:         await sendTelegramAlert(`Outbox backlog alto: ${pending} eventi pendenti`);
165:     }
166: }
````

## File: src/telemetry/alerts.ts
````typescript
 1: import { config } from '../config';
 2: 
 3: export async function sendTelegramAlert(message: string): Promise<void> {
 4:     if (!config.telegramBotToken || !config.telegramChatId) {
 5:         return;
 6:     }
 7: 
 8:     const endpoint = `https://api.telegram.org/bot${config.telegramBotToken}/sendMessage`;
 9:     try {
10:         await fetch(endpoint, {
11:             method: 'POST',
12:             headers: { 'Content-Type': 'application/json' },
13:             body: JSON.stringify({
14:                 chat_id: config.telegramChatId,
15:                 text: message,
16:                 disable_web_page_preview: true,
17:             }),
18:         });
19:     } catch (error) {
20:         console.error('[WARN] Invio alert Telegram fallito', error);
21:     }
22: }
````

## File: src/telemetry/logger.ts
````typescript
 1: import { recordRunLog } from '../core/repositories';
 2: import { sanitizeForLogs } from '../security/redaction';
 3: 
 4: export async function logInfo(event: string, payload: Record<string, unknown> = {}): Promise<void> {
 5:     const safePayload = sanitizeForLogs(payload);
 6:     console.log(`[INFO] ${event}`, safePayload);
 7:     await recordRunLog('INFO', event, safePayload);
 8: }
 9: 
10: export async function logWarn(event: string, payload: Record<string, unknown> = {}): Promise<void> {
11:     const safePayload = sanitizeForLogs(payload);
12:     console.warn(`[WARN] ${event}`, safePayload);
13:     await recordRunLog('WARN', event, safePayload);
14: }
15: 
16: export async function logError(event: string, payload: Record<string, unknown> = {}): Promise<void> {
17:     const safePayload = sanitizeForLogs(payload);
18:     console.error(`[ERROR] ${event}`, safePayload);
19:     await recordRunLog('ERROR', event, safePayload);
20: }
````

## File: src/tests/e2eDry.ts
````typescript
 1: import assert from 'assert';
 2: import fs from 'fs';
 3: import path from 'path';
 4: 
 5: async function run(): Promise<void> {
 6:     const testDbPath = path.resolve(process.cwd(), 'data', 'test_e2e_dry.sqlite');
 7:     if (fs.existsSync(testDbPath)) {
 8:         fs.unlinkSync(testDbPath);
 9:     }
10: 
11:     process.env.DB_PATH = testDbPath;
12:     process.env.SUPABASE_SYNC_ENABLED = 'false';
13:     process.env.SELECTOR_CANARY_ENABLED = 'false';
14:     process.env.HOUR_START = '0';
15:     process.env.HOUR_END = '24';
16: 
17:     const dbModule = await import('../db');
18:     const repositories = await import('../core/repositories');
19:     const scheduler = await import('../core/scheduler');
20: 
21:     await dbModule.initDatabase();
22: 
23:     await repositories.addLead({
24:         accountName: 'Dry Run Srl',
25:         firstName: 'Dry',
26:         lastName: 'Run',
27:         jobTitle: 'Test Lead',
28:         website: 'https://example.org',
29:         linkedinUrl: 'https://www.linkedin.com/in/dry-run-lead-test/',
30:         listName: 'dry-list',
31:     });
32:     await repositories.promoteNewLeadsToReadyInvite(10);
33: 
34:     const result = await scheduler.scheduleJobs('invite');
35:     assert.equal(result.queuedInviteJobs >= 1, true);
36:     assert.equal(result.localDate.length, 10);
37: 
38:     await dbModule.closeDatabase();
39:     if (fs.existsSync(testDbPath)) {
40:         fs.unlinkSync(testDbPath);
41:     }
42: }
43: 
44: run()
45:     .then(() => {
46:         console.log('Dry-run scenario passed.');
47:     })
48:     .catch((error) => {
49:         console.error(error);
50:         process.exit(1);
51:     });
````

## File: src/validation/messageValidator.ts
````typescript
 1: import crypto from 'crypto';
 2: import { MessageValidationResult } from '../types/domain';
 3: 
 4: export interface MessageValidationContext {
 5:     duplicateCountLast24h: number;
 6:     maxLen?: number;
 7: }
 8: 
 9: export function extractUnresolvedPlaceholders(message: string): string[] {
10:     const matches = message.match(/\{\{[^}]+\}\}|\[[^\]]+\]/g);
11:     return matches ?? [];
12: }
13: 
14: export function hashMessage(message: string): string {
15:     return crypto.createHash('sha256').update(message).digest('hex');
16: }
17: 
18: export function validateMessageContent(message: string, context: MessageValidationContext): MessageValidationResult {
19:     const reasons: string[] = [];
20:     const trimmed = message.trim();
21:     const maxLen = context.maxLen ?? 550;
22: 
23:     if (!trimmed) {
24:         reasons.push('Messaggio vuoto.');
25:     }
26:     if (trimmed.length > maxLen) {
27:         reasons.push(`Messaggio troppo lungo (${trimmed.length}/${maxLen}).`);
28:     }
29:     const unresolved = extractUnresolvedPlaceholders(trimmed);
30:     if (unresolved.length > 0) {
31:         reasons.push(`Placeholder non risolti: ${unresolved.join(', ')}`);
32:     }
33:     if (context.duplicateCountLast24h >= 3) {
34:         reasons.push('Messaggio troppo ripetitivo nelle ultime 24h.');
35:     }
36: 
37:     return {
38:         valid: reasons.length === 0,
39:         reasons,
40:     };
41: }
````

## File: src/workers/errors.ts
````typescript
 1: export class RetryableWorkerError extends Error {
 2:     public readonly code: string;
 3: 
 4:     constructor(message: string, code: string = 'RETRYABLE') {
 5:         super(message);
 6:         this.name = 'RetryableWorkerError';
 7:         this.code = code;
 8:     }
 9: }
10: 
11: export class ChallengeDetectedError extends Error {
12:     constructor(message: string = 'Challenge/CAPTCHA rilevato') {
13:         super(message);
14:         this.name = 'ChallengeDetectedError';
15:     }
16: }
````

## File: src/workers/randomActivityWorker.ts
````typescript
  1: import { getAccountProfileById } from '../accountManager';
  2: import { checkLogin, closeBrowser, humanDelay, launchBrowser, randomMouseMove, simulateHumanReading } from '../browser';
  3: 
  4: export interface RandomActivityOptions {
  5:     accountId?: string;
  6:     maxActions: number;
  7:     dryRun: boolean;
  8: }
  9: 
 10: export interface RandomActivityReport {
 11:     accountId: string;
 12:     dryRun: boolean;
 13:     actionsRequested: number;
 14:     actionsExecuted: number;
 15:     visitedUrls: string[];
 16:     profileVisits: number;
 17:     errors: number;
 18: }
 19: 
 20: type Activity = 'home' | 'notifications' | 'network' | 'settings' | 'profile_from_page';
 21: 
 22: const STATIC_ACTIVITY_URLS: Record<Exclude<Activity, 'profile_from_page'>, string> = {
 23:     home: 'https://www.linkedin.com/feed/',
 24:     notifications: 'https://www.linkedin.com/notifications/',
 25:     network: 'https://www.linkedin.com/mynetwork/',
 26:     settings: 'https://www.linkedin.com/mypreferences/d/categories/account',
 27: };
 28: 
 29: function pickRandom<T>(items: T[]): T {
 30:     return items[Math.floor(Math.random() * items.length)];
 31: }
 32: 
 33: async function extractProfileUrlsFromCurrentPage(page: import('playwright').Page): Promise<string[]> {
 34:     const urls = await page.evaluate(() => {
 35:         const anchors = Array.from(document.querySelectorAll('a[href]')) as HTMLAnchorElement[];
 36:         return anchors
 37:             .map((anchor) => anchor.href || '')
 38:             .filter((href) => /linkedin\.com\/in\//i.test(href))
 39:             .map((href) => href.split('?')[0])
 40:             .slice(0, 20);
 41:     }).catch(() => [] as string[]);
 42:     return Array.from(new Set(urls));
 43: }
 44: 
 45: async function runSingleActivity(
 46:     page: import('playwright').Page,
 47:     activity: Activity,
 48:     report: RandomActivityReport
 49: ): Promise<void> {
 50:     if (activity === 'profile_from_page') {
 51:         const profiles = await extractProfileUrlsFromCurrentPage(page);
 52:         if (profiles.length === 0) {
 53:             return;
 54:         }
 55:         const profileUrl = pickRandom(profiles);
 56:         await page.goto(profileUrl, { waitUntil: 'domcontentloaded' });
 57:         report.visitedUrls.push(profileUrl);
 58:         report.profileVisits += 1;
 59:         await humanDelay(page, 2000, 4200);
 60:         await simulateHumanReading(page);
 61:         return;
 62:     }
 63: 
 64:     const targetUrl = STATIC_ACTIVITY_URLS[activity];
 65:     await page.goto(targetUrl, { waitUntil: 'domcontentloaded' });
 66:     report.visitedUrls.push(targetUrl);
 67:     await humanDelay(page, 1800, 3600);
 68:     await simulateHumanReading(page);
 69: 
 70:     if (Math.random() < 0.35) {
 71:         await randomMouseMove(page);
 72:     }
 73: }
 74: 
 75: export async function runRandomLinkedinActivity(options: RandomActivityOptions): Promise<RandomActivityReport> {
 76:     const account = getAccountProfileById(options.accountId);
 77:     const actionsRequested = Math.max(1, options.maxActions);
 78: 
 79:     const report: RandomActivityReport = {
 80:         accountId: account.id,
 81:         dryRun: options.dryRun,
 82:         actionsRequested,
 83:         actionsExecuted: 0,
 84:         visitedUrls: [],
 85:         profileVisits: 0,
 86:         errors: 0,
 87:     };
 88: 
 89:     if (options.dryRun) {
 90:         return report;
 91:     }
 92: 
 93:     const session = await launchBrowser({
 94:         sessionDir: account.sessionDir,
 95:         proxy: account.proxy,
 96:     });
 97:     try {
 98:         const loggedIn = await checkLogin(session.page);
 99:         if (!loggedIn) {
100:             return report;
101:         }
102: 
103:         const activityPool: Activity[] = [
104:             'home',
105:             'notifications',
106:             'network',
107:             'settings',
108:             'profile_from_page',
109:         ];
110: 
111:         for (let i = 0; i < actionsRequested; i++) {
112:             const activity = pickRandom(activityPool);
113:             try {
114:                 await runSingleActivity(session.page, activity, report);
115:                 report.actionsExecuted += 1;
116:             } catch {
117:                 report.errors += 1;
118:             }
119:             await humanDelay(session.page, 1200, 2800);
120:         }
121: 
122:         return report;
123:     } finally {
124:         await closeBrowser(session);
125:     }
126: }
````

## File: tsconfig.json
````json
 1: {
 2:     "compilerOptions": {
 3:         "target": "ES2022",
 4:         "module": "CommonJS",
 5:         "outDir": "./dist",
 6:         "rootDir": "./src",
 7:         "strict": true,
 8:         "esModuleInterop": true,
 9:         "skipLibCheck": true,
10:         "forceConsistentCasingInFileNames": true,
11:         "resolveJsonModule": true
12:     },
13:     "include": [
14:         "src/**/*"
15:     ],
16:     "exclude": [
17:         "node_modules",
18:         "dist"
19:     ]
20: }
````

## File: src/core/audit.ts
````typescript
  1: import { checkLogin, closeBrowser, detectChallenge, humanDelay, launchBrowser } from '../browser';
  2: import { getAccountProfileById, pickAccountIdForLead } from '../accountManager';
  3: import { config } from '../config';
  4: import { quarantineAccount } from '../risk/incidentManager';
  5: import { SELECTORS } from '../selectors';
  6: import { LeadRecord } from '../types/domain';
  7: import { reconcileLeadStatus, transitionLead } from './leadStateService';
  8: import {
  9:     countCompanyTargets,
 10:     countCompanyTargetsByStatuses,
 11:     countLeadsByStatuses,
 12:     countPendingOutboxEvents,
 13:     getJobStatusCounts,
 14:     getLeadsByStatusForSiteCheck,
 15:     JobStatusCounts,
 16:     touchLeadSiteCheckAt,
 17: } from './repositories';
 18: import { Page } from 'playwright';
 19: 
 20: export interface FunnelReport {
 21:     totals: {
 22:         leads: number;
 23:         companyTargets: number;
 24:         queuedJobs: number;
 25:         pendingOutbox: number;
 26:     };
 27:     connections: {
 28:         toSend: number;
 29:         invitedPendingAcceptance: number;
 30:         acceptedReadyMessage: number;
 31:         completed: number;
 32:     };
 33:     messages: {
 34:         toSend: number;
 35:         sent: number;
 36:         blockedOrSkipped: number;
 37:     };
 38:     companyTargetStatuses: {
 39:         NEW: number;
 40:         ENRICHED: number;
 41:         NO_MATCH: number;
 42:         ERROR: number;
 43:     };
 44:     leadStatuses: Record<string, number>;
 45:     jobs: JobStatusCounts;
 46: }
 47: 
 48: export interface SiteCheckItem {
 49:     leadId: number;
 50:     status: string;
 51:     linkedinUrl: string;
 52:     siteSignals: {
 53:         pendingInvite: boolean;
 54:         connected: boolean;
 55:         messageButton: boolean;
 56:         canConnect: boolean;
 57:     };
 58:     mismatch: string;
 59:     fixed: boolean;
 60: }
 61: 
 62: export interface SiteCheckReport {
 63:     scanned: number;
 64:     mismatches: number;
 65:     fixed: number;
 66:     items: SiteCheckItem[];
 67: }
 68: 
 69: export interface SiteCheckOptions {
 70:     limitPerStatus: number;
 71:     autoFix: boolean;
 72:     staleDays?: number;
 73: }
 74: 
 75: function isFirstDegreeBadge(text: string | null): boolean {
 76:     if (!text) return true;
 77:     return /1st|1°|1\b/i.test(text);
 78: }
 79: 
 80: async function inspectLeadOnSite(lead: LeadRecord, sessionPage: Page): Promise<{
 81:     pendingInvite: boolean;
 82:     connected: boolean;
 83:     messageButton: boolean;
 84:     canConnect: boolean;
 85: }> {
 86:     await sessionPage.goto(lead.linkedin_url, { waitUntil: 'domcontentloaded' });
 87:     await humanDelay(sessionPage, 1200, 2200);
 88: 
 89:     const messageButton = (await sessionPage.locator(SELECTORS.messageButton).count()) > 0;
 90:     const badgeText = await sessionPage.locator(SELECTORS.distanceBadge).first().textContent().catch(() => '');
 91:     const connected = messageButton && isFirstDegreeBadge(badgeText);
 92:     const pendingInvite = (await sessionPage.locator(SELECTORS.invitePendingIndicators).count()) > 0;
 93:     const canConnect = (await sessionPage.locator(SELECTORS.connectButtonPrimary).count()) > 0;
 94: 
 95:     return {
 96:         pendingInvite,
 97:         connected,
 98:         messageButton,
 99:         canConnect,
100:     };
101: }
102: 
103: async function tryAutoFix(lead: LeadRecord, mismatch: string): Promise<boolean> {
104:     if (mismatch === 'invited_but_connected') {
105:         await transitionLead(lead.id, 'ACCEPTED', 'site_check_autofix_connected');
106:         await transitionLead(lead.id, 'READY_MESSAGE', 'site_check_autofix_ready_message');
107:         return true;
108:     }
109: 
110:     if (mismatch === 'ready_invite_but_pending') {
111:         await transitionLead(lead.id, 'INVITED', 'site_check_autofix_pending');
112:         return true;
113:     }
114: 
115:     if (mismatch === 'ready_invite_but_connected') {
116:         await transitionLead(lead.id, 'INVITED', 'site_check_autofix_connected_promote_invited');
117:         await transitionLead(lead.id, 'ACCEPTED', 'site_check_autofix_connected_promote_accepted');
118:         await transitionLead(lead.id, 'READY_MESSAGE', 'site_check_autofix_connected_promote_ready_message');
119:         return true;
120:     }
121: 
122:     if (mismatch === 'ready_message_but_pending_invite') {
123:         await reconcileLeadStatus(lead.id, 'INVITED', 'site_check_reconcile_ready_message_to_invited_pending');
124:         return true;
125:     }
126: 
127:     if (mismatch === 'messaged_but_pending_invite') {
128:         await reconcileLeadStatus(lead.id, 'INVITED', 'site_check_reconcile_messaged_to_invited_pending');
129:         return true;
130:     }
131: 
132:     if (mismatch === 'invited_but_connect_available') {
133:         await reconcileLeadStatus(lead.id, 'READY_INVITE', 'site_check_reconcile_invited_to_ready_invite_connect_available');
134:         return true;
135:     }
136: 
137:     return false;
138: }
139: 
140: export async function buildFunnelReport(): Promise<FunnelReport> {
141:     const [
142:         newCount,
143:         readyInviteCount,
144:         invitedCount,
145:         acceptedCount,
146:         readyMessageCount,
147:         messagedCount,
148:         blockedCount,
149:         skippedCount,
150:         pendingOutbox,
151:         companyTargets,
152:         companyTargetsNew,
153:         companyTargetsEnriched,
154:         companyTargetsNoMatch,
155:         companyTargetsError,
156:         jobs,
157:     ] = await Promise.all([
158:         countLeadsByStatuses(['NEW']),
159:         countLeadsByStatuses(['READY_INVITE', 'PENDING']),
160:         countLeadsByStatuses(['INVITED']),
161:         countLeadsByStatuses(['ACCEPTED']),
162:         countLeadsByStatuses(['READY_MESSAGE']),
163:         countLeadsByStatuses(['MESSAGED']),
164:         countLeadsByStatuses(['BLOCKED']),
165:         countLeadsByStatuses(['SKIPPED']),
166:         countPendingOutboxEvents(),
167:         countCompanyTargets(),
168:         countCompanyTargetsByStatuses(['NEW']),
169:         countCompanyTargetsByStatuses(['ENRICHED']),
170:         countCompanyTargetsByStatuses(['NO_MATCH']),
171:         countCompanyTargetsByStatuses(['ERROR']),
172:         getJobStatusCounts(),
173:     ]);
174: 
175:     const totalLeads = newCount + readyInviteCount + invitedCount + acceptedCount + readyMessageCount + messagedCount + blockedCount + skippedCount;
176:     const queuedJobs = Object.values(jobs).reduce((acc, value) => acc + value, 0);
177: 
178:     return {
179:         totals: {
180:             leads: totalLeads,
181:             companyTargets,
182:             queuedJobs,
183:             pendingOutbox,
184:         },
185:         connections: {
186:             toSend: newCount + readyInviteCount,
187:             invitedPendingAcceptance: invitedCount,
188:             acceptedReadyMessage: acceptedCount + readyMessageCount,
189:             completed: messagedCount,
190:         },
191:         messages: {
192:             toSend: readyMessageCount,
193:             sent: messagedCount,
194:             blockedOrSkipped: blockedCount + skippedCount,
195:         },
196:         companyTargetStatuses: {
197:             NEW: companyTargetsNew,
198:             ENRICHED: companyTargetsEnriched,
199:             NO_MATCH: companyTargetsNoMatch,
200:             ERROR: companyTargetsError,
201:         },
202:         leadStatuses: {
203:             NEW: newCount,
204:             READY_INVITE: readyInviteCount,
205:             INVITED: invitedCount,
206:             ACCEPTED: acceptedCount,
207:             READY_MESSAGE: readyMessageCount,
208:             MESSAGED: messagedCount,
209:             BLOCKED: blockedCount,
210:             SKIPPED: skippedCount,
211:         },
212:         jobs,
213:     };
214: }
215: 
216: export async function runSiteCheck(options: SiteCheckOptions): Promise<SiteCheckReport> {
217:     const limit = Math.max(1, options.limitPerStatus);
218:     const staleDays = Math.max(0, options.staleDays ?? config.siteCheckStaleDays);
219:     const [readyInviteLeads, invitedLeads, readyMessageLeads, messagedLeads] = await Promise.all([
220:         getLeadsByStatusForSiteCheck('READY_INVITE', limit, staleDays),
221:         getLeadsByStatusForSiteCheck('INVITED', limit, staleDays),
222:         getLeadsByStatusForSiteCheck('READY_MESSAGE', limit, staleDays),
223:         getLeadsByStatusForSiteCheck('MESSAGED', Math.max(5, Math.floor(limit / 2)), staleDays),
224:     ]);
225: 
226:     const candidates = [...readyInviteLeads, ...invitedLeads, ...readyMessageLeads, ...messagedLeads];
227:     if (candidates.length === 0) {
228:         return {
229:             scanned: 0,
230:             mismatches: 0,
231:             fixed: 0,
232:             items: [],
233:         };
234:     }
235: 
236:     const report: SiteCheckReport = {
237:         scanned: 0,
238:         mismatches: 0,
239:         fixed: 0,
240:         items: [],
241:     };
242: 
243:     const leadsByAccount = new Map<string, LeadRecord[]>();
244:     for (const lead of candidates) {
245:         const accountId = pickAccountIdForLead(lead.id);
246:         if (!leadsByAccount.has(accountId)) {
247:             leadsByAccount.set(accountId, []);
248:         }
249:         leadsByAccount.get(accountId)?.push(lead);
250:     }
251: 
252:     let challengeDetected = false;
253:     for (const [accountId, accountLeads] of leadsByAccount) {
254:         const account = getAccountProfileById(accountId);
255:         const session = await launchBrowser({
256:             sessionDir: account.sessionDir,
257:             proxy: account.proxy,
258:         });
259:         try {
260:             const loggedIn = await checkLogin(session.page);
261:             if (!loggedIn) {
262:                 await quarantineAccount('SITE_CHECK_LOGIN_MISSING', {
263:                     reason: 'Sessione non autenticata durante site-check',
264:                     accountId,
265:                 });
266:                 return report;
267:             }
268: 
269:             for (const lead of accountLeads) {
270:                 report.scanned += 1;
271:                 const signals = await inspectLeadOnSite(lead, session.page);
272:                 await touchLeadSiteCheckAt(lead.id);
273: 
274:                 if (await detectChallenge(session.page)) {
275:                     await quarantineAccount('SITE_CHECK_CHALLENGE_DETECTED', {
276:                         leadId: lead.id,
277:                         status: lead.status,
278:                         linkedinUrl: lead.linkedin_url,
279:                         accountId,
280:                     });
281:                     challengeDetected = true;
282:                     break;
283:                 }
284: 
285:                 let mismatch: string | null = null;
286:                 if (lead.status === 'INVITED' && signals.connected) {
287:                     mismatch = 'invited_but_connected';
288:                 } else if (lead.status === 'INVITED' && !signals.pendingInvite && signals.canConnect) {
289:                     mismatch = 'invited_but_connect_available';
290:                 } else if (lead.status === 'READY_INVITE' && signals.pendingInvite) {
291:                     mismatch = 'ready_invite_but_pending';
292:                 } else if (lead.status === 'READY_INVITE' && signals.connected) {
293:                     mismatch = 'ready_invite_but_connected';
294:                 } else if (lead.status === 'READY_MESSAGE' && signals.pendingInvite) {
295:                     mismatch = 'ready_message_but_pending_invite';
296:                 } else if (lead.status === 'READY_MESSAGE' && !signals.connected) {
297:                     mismatch = 'ready_message_but_not_connected';
298:                 } else if (lead.status === 'MESSAGED' && signals.pendingInvite) {
299:                     mismatch = 'messaged_but_pending_invite';
300:                 } else if (lead.status === 'MESSAGED' && !signals.connected) {
301:                     mismatch = 'messaged_but_not_connected';
302:                 }
303: 
304:                 if (!mismatch) {
305:                     continue;
306:                 }
307: 
308:                 report.mismatches += 1;
309:                 let fixed = false;
310:                 if (options.autoFix) {
311:                     fixed = await tryAutoFix(lead, mismatch);
312:                     if (fixed) {
313:                         report.fixed += 1;
314:                     }
315:                 }
316: 
317:                 report.items.push({
318:                     leadId: lead.id,
319:                     status: lead.status,
320:                     linkedinUrl: lead.linkedin_url,
321:                     siteSignals: signals,
322:                     mismatch,
323:                     fixed,
324:                 });
325:             }
326:         } finally {
327:             await closeBrowser(session);
328:         }
329: 
330:         if (challengeDetected) {
331:             break;
332:         }
333:     }
334: 
335:     return report;
336: }
````

## File: src/core/doctor.ts
````typescript
 1: import { config, isWorkingHour } from '../config';
 2: import { checkLogin, closeBrowser, launchBrowser } from '../browser';
 3: import { getRuntimeAccountProfiles } from '../accountManager';
 4: import { getEventSyncStatus } from '../sync/eventSync';
 5: import { getRuntimeFlag, listOpenIncidents } from './repositories';
 6: 
 7: export interface DoctorAccountSessionReport {
 8:     accountId: string;
 9:     sessionDir: string;
10:     sessionLoginOk: boolean;
11: }
12: 
13: export interface DoctorReport {
14:     dbPath: string;
15:     workingHoursOk: boolean;
16:     sessionLoginOk: boolean;
17:     accountSessions: DoctorAccountSessionReport[];
18:     quarantine: boolean;
19:     sync: {
20:         activeSink: 'SUPABASE' | 'WEBHOOK' | 'NONE';
21:         enabled: boolean;
22:         configured: boolean;
23:         pendingOutbox: number;
24:         warning: string | null;
25:     };
26:     openIncidents: number;
27: }
28: 
29: export async function runDoctor(): Promise<DoctorReport> {
30:     const quarantine = (await getRuntimeFlag('account_quarantine')) === 'true';
31:     const sync = await getEventSyncStatus();
32:     const incidents = await listOpenIncidents();
33: 
34:     const accountSessions: DoctorAccountSessionReport[] = [];
35:     const accounts = getRuntimeAccountProfiles();
36:     for (const account of accounts) {
37:         const session = await launchBrowser({
38:             sessionDir: account.sessionDir,
39:             proxy: account.proxy,
40:         });
41:         try {
42:             const sessionLoginOk = await checkLogin(session.page);
43:             accountSessions.push({
44:                 accountId: account.id,
45:                 sessionDir: account.sessionDir,
46:                 sessionLoginOk,
47:             });
48:         } finally {
49:             await closeBrowser(session);
50:         }
51:     }
52:     const sessionLoginOk = accountSessions.every((entry) => entry.sessionLoginOk);
53: 
54:     return {
55:         dbPath: config.dbPath,
56:         workingHoursOk: isWorkingHour(),
57:         sessionLoginOk,
58:         accountSessions,
59:         quarantine,
60:         sync: {
61:             activeSink: sync.activeSink,
62:             enabled: sync.enabled,
63:             configured: sync.configured,
64:             pendingOutbox: sync.pendingOutbox,
65:             warning: sync.warning,
66:         },
67:         openIncidents: incidents.length,
68:     };
69: }
````

## File: src/core/orchestrator.ts
````typescript
  1: import { checkLogin, closeBrowser, launchBrowser, runSelectorCanary } from '../browser';
  2: import { getRuntimeAccountProfiles } from '../accountManager';
  3: import { config, getLocalDateString, isWorkingHour } from '../config';
  4: import { pauseAutomation, quarantineAccount } from '../risk/incidentManager';
  5: import { evaluateCooldownDecision } from '../risk/riskEngine';
  6: import { logInfo, logWarn } from '../telemetry/logger';
  7: import { runEventSyncOnce } from '../sync/eventSync';
  8: import { workflowToJobTypes, scheduleJobs, WorkflowSelection } from './scheduler';
  9: import { runSiteCheck } from './audit';
 10: 
 11: import { runQueuedJobs } from './jobRunner';
 12: import { getAutomationPauseState, getDailyStat, getRuntimeFlag, pushOutboxEvent } from './repositories';
 13: import { evaluateAiGuardian } from '../ai/guardian';
 14: 
 15: export interface RunWorkflowOptions {
 16:     workflow: WorkflowSelection;
 17:     dryRun: boolean;
 18: }
 19: 
 20: async function runCanaryIfNeeded(workflow: WorkflowSelection): Promise<boolean> {
 21:     const touchesUi = workflow === 'all' || workflow === 'invite' || workflow === 'message' || workflow === 'check';
 22:     if (!config.selectorCanaryEnabled || !touchesUi) {
 23:         return true;
 24:     }
 25: 
 26:     const accounts = getRuntimeAccountProfiles();
 27:     for (const account of accounts) {
 28:         const session = await launchBrowser({
 29:             sessionDir: account.sessionDir,
 30:             proxy: account.proxy,
 31:         });
 32:         try {
 33:             const loggedIn = await checkLogin(session.page);
 34:             if (!loggedIn) {
 35:                 return false;
 36:             }
 37:             const canaryOk = await runSelectorCanary(session.page);
 38:             if (!canaryOk) {
 39:                 return false;
 40:             }
 41:         } finally {
 42:             await closeBrowser(session);
 43:         }
 44:     }
 45: 
 46:     return true;
 47: }
 48: 
 49: export async function runWorkflow(options: RunWorkflowOptions): Promise<void> {
 50:     if (!options.dryRun) {
 51:         const quarantine = (await getRuntimeFlag('account_quarantine')) === 'true';
 52:         if (quarantine) {
 53:             await logWarn('workflow.skipped.quarantine', { workflow: options.workflow });
 54:             return;
 55:         }
 56: 
 57:         const pauseState = await getAutomationPauseState();
 58:         if (pauseState.paused) {
 59:             await logWarn('workflow.skipped.paused', {
 60:                 workflow: options.workflow,
 61:                 reason: pauseState.reason,
 62:                 pausedUntil: pauseState.pausedUntil,
 63:                 remainingSeconds: pauseState.remainingSeconds,
 64:             });
 65:             return;
 66:         }
 67:     }
 68: 
 69:     if (!options.dryRun && !isWorkingHour()) {
 70:         await logInfo('workflow.skipped.out_of_hours', {
 71:             startHour: config.workingHoursStart,
 72:             endHour: config.workingHoursEnd,
 73:         });
 74:         return;
 75:     }
 76: 
 77:     if (!options.dryRun) {
 78:         const localDate = getLocalDateString();
 79:         const selectorFailures = await getDailyStat(localDate, 'selector_failures');
 80:         if (selectorFailures >= config.maxSelectorFailuresPerDay) {
 81:             await quarantineAccount('SELECTOR_FAILURE_BURST', {
 82:                 workflow: options.workflow,
 83:                 localDate,
 84:                 selectorFailures,
 85:                 threshold: config.maxSelectorFailuresPerDay,
 86:             });
 87:             return;
 88:         }
 89: 
 90:         const runErrors = await getDailyStat(localDate, 'run_errors');
 91:         if (runErrors >= config.maxRunErrorsPerDay) {
 92:             await pauseAutomation(
 93:                 'RUN_ERRORS_BURST',
 94:                 {
 95:                     workflow: options.workflow,
 96:                     localDate,
 97:                     runErrors,
 98:                     threshold: config.maxRunErrorsPerDay,
 99:                 },
100:                 config.autoPauseMinutesOnFailureBurst
101:             );
102:             await logWarn('workflow.skipped.run_error_burst', {
103:                 workflow: options.workflow,
104:                 localDate,
105:                 runErrors,
106:                 threshold: config.maxRunErrorsPerDay,
107:                 pauseMinutes: config.autoPauseMinutesOnFailureBurst,
108:             });
109:             return;
110:         }
111: 
112:         const canaryOk = await runCanaryIfNeeded(options.workflow);
113:         if (!canaryOk) {
114:             await quarantineAccount('SELECTOR_CANARY_FAILED', { workflow: options.workflow });
115:             return;
116:         }
117:     }
118: 
119:     const schedule = await scheduleJobs(options.workflow, { dryRun: options.dryRun });
120: 
121:     if (options.dryRun) {
122:         console.log('[DRY_RUN] workflow.preview', {
123:             workflow: options.workflow,
124:             localDate: schedule.localDate,
125:             risk: schedule.riskSnapshot,
126:             queuedInviteJobs: schedule.queuedInviteJobs,
127:             queuedCheckJobs: schedule.queuedCheckJobs,
128:             queuedMessageJobs: schedule.queuedMessageJobs,
129:             inviteBudget: schedule.inviteBudget,
130:             messageBudget: schedule.messageBudget,
131:             listBreakdown: schedule.listBreakdown,
132:         });
133:         return;
134:     }
135: 
136:     await pushOutboxEvent(
137:         'scheduler.snapshot',
138:         {
139:             workflow: options.workflow,
140:             localDate: schedule.localDate,
141:             risk: schedule.riskSnapshot,
142:             queuedInviteJobs: schedule.queuedInviteJobs,
143:             queuedCheckJobs: schedule.queuedCheckJobs,
144:             queuedMessageJobs: schedule.queuedMessageJobs,
145:             inviteBudget: schedule.inviteBudget,
146:             messageBudget: schedule.messageBudget,
147:             listBreakdown: schedule.listBreakdown,
148:         },
149:         `scheduler.snapshot:${schedule.localDate}:${options.workflow}`
150:     );
151: 
152:     if (schedule.riskSnapshot.action === 'STOP') {
153:         await quarantineAccount('RISK_STOP_THRESHOLD', {
154:             workflow: options.workflow,
155:             riskSnapshot: schedule.riskSnapshot,
156:         });
157:         return;
158:     }
159: 
160:     const guardian = await evaluateAiGuardian(options.workflow, schedule);
161:     if (guardian.decision) {
162:         await pushOutboxEvent(
163:             'ai.guardian.decision',
164:             {
165:                 workflow: options.workflow,
166:                 localDate: schedule.localDate,
167:                 executed: guardian.executed,
168:                 reason: guardian.reason,
169:                 decision: guardian.decision,
170:             },
171:             `ai.guardian.decision:${schedule.localDate}:${options.workflow}:${Date.now()}`
172:         );
173:         if (guardian.decision.severity === 'critical' && guardian.decision.pauseMinutes > 0) {
174:             await pauseAutomation(
175:                 'AI_GUARDIAN_PREEMPTIVE',
176:                 {
177:                     workflow: options.workflow,
178:                     localDate: schedule.localDate,
179:                     reason: guardian.reason,
180:                     decision: guardian.decision,
181:                 },
182:                 guardian.decision.pauseMinutes
183:             );
184:             await logWarn('ai.guardian.preemptive_pause', {
185:                 workflow: options.workflow,
186:                 localDate: schedule.localDate,
187:                 reason: guardian.reason,
188:                 pauseMinutes: guardian.decision.pauseMinutes,
189:                 summary: guardian.decision.summary,
190:             });
191:             return;
192:         }
193:         if (guardian.decision.severity === 'watch') {
194:             await logWarn('ai.guardian.watch', {
195:                 workflow: options.workflow,
196:                 localDate: schedule.localDate,
197:                 reason: guardian.reason,
198:                 summary: guardian.decision.summary,
199:                 recommendations: guardian.decision.recommendations,
200:             });
201:         } else {
202:             await logInfo('ai.guardian.normal', {
203:                 workflow: options.workflow,
204:                 localDate: schedule.localDate,
205:                 reason: guardian.reason,
206:                 summary: guardian.decision.summary,
207:             });
208:         }
209:     }
210: 
211:     const cooldown = evaluateCooldownDecision(schedule.riskSnapshot);
212:     if (cooldown.activate) {
213:         await pauseAutomation(
214:             'RISK_COOLDOWN',
215:             {
216:                 workflow: options.workflow,
217:                 localDate: schedule.localDate,
218:                 riskSnapshot: schedule.riskSnapshot,
219:                 tier: cooldown.tier,
220:                 reason: cooldown.reason,
221:                 listBreakdown: schedule.listBreakdown,
222:             },
223:             cooldown.minutes
224:         );
225:         await logWarn('risk.cooldown.activated', {
226:             workflow: options.workflow,
227:             localDate: schedule.localDate,
228:             tier: cooldown.tier,
229:             reason: cooldown.reason,
230:             pauseMinutes: cooldown.minutes,
231:             score: schedule.riskSnapshot.score,
232:             pendingRatio: schedule.riskSnapshot.pendingRatio,
233:         });
234:         return;
235:     }
236: 
237:     if (schedule.riskSnapshot.action === 'WARN') {
238:         await logWarn('risk.warn', {
239:             workflow: options.workflow,
240:             score: schedule.riskSnapshot.score,
241:             pendingRatio: schedule.riskSnapshot.pendingRatio,
242:         });
243:     }
244: 
245:     await runQueuedJobs({
246:         localDate: schedule.localDate,
247:         allowedTypes: workflowToJobTypes(options.workflow),
248:         dryRun: options.dryRun,
249:     });
250: 
251:     if (config.postRunStateSyncEnabled) {
252:         const stateSyncReport = await runSiteCheck({
253:             limitPerStatus: config.postRunStateSyncLimit,
254:             autoFix: config.postRunStateSyncFix,
255:         });
256:         await logInfo('state.sync.post_run', {
257:             workflow: options.workflow,
258:             localDate: schedule.localDate,
259:             limitPerStatus: config.postRunStateSyncLimit,
260:             autoFix: config.postRunStateSyncFix,
261:             report: stateSyncReport,
262:         });
263:         await pushOutboxEvent(
264:             'state.sync.post_run',
265:             {
266:                 workflow: options.workflow,
267:                 localDate: schedule.localDate,
268:                 limitPerStatus: config.postRunStateSyncLimit,
269:                 autoFix: config.postRunStateSyncFix,
270:                 report: stateSyncReport,
271:             },
272:             `state.sync.post_run:${schedule.localDate}:${options.workflow}:${Date.now()}`
273:         );
274:     }
275: 
276:     await runEventSyncOnce();
277: }
````

## File: src/db.ts
````typescript
  1: import sqlite3 from 'sqlite3';
  2: import { open, Database } from 'sqlite';
  3: import path from 'path';
  4: import fs from 'fs';
  5: import { config } from './config';
  6: import { ensureFilePrivate, ensureParentDirectoryPrivate } from './security/filesystem';
  7: 
  8: let db: Database | null = null;
  9: 
 10: function resolveMigrationDirectory(): string {
 11:     const cwdMigrations = path.resolve(process.cwd(), 'src', 'db', 'migrations');
 12:     if (fs.existsSync(cwdMigrations)) {
 13:         return cwdMigrations;
 14:     }
 15:     const compiledMigrations = path.resolve(__dirname, 'db', 'migrations');
 16:     if (fs.existsSync(compiledMigrations)) {
 17:         return compiledMigrations;
 18:     }
 19:     throw new Error('Cartella migrazioni non trovata.');
 20: }
 21: 
 22: async function ensureColumn(database: Database, tableName: string, columnName: string, definition: string): Promise<void> {
 23:     const columns = await database.all<{ name: string }[]>(`PRAGMA table_info(${tableName})`);
 24:     const exists = columns.some((column) => column.name === columnName);
 25:     if (!exists) {
 26:         await database.exec(`ALTER TABLE ${tableName} ADD COLUMN ${columnName} ${definition}`);
 27:     }
 28: }
 29: 
 30: async function applyMigrations(database: Database): Promise<void> {
 31:     await database.exec(`
 32:         CREATE TABLE IF NOT EXISTS _migrations (
 33:             id INTEGER PRIMARY KEY AUTOINCREMENT,
 34:             name TEXT NOT NULL UNIQUE,
 35:             applied_at DATETIME DEFAULT CURRENT_TIMESTAMP
 36:         );
 37:     `);
 38: 
 39:     const migrationDir = resolveMigrationDirectory();
 40:     const files = fs
 41:         .readdirSync(migrationDir)
 42:         .filter((file) => file.endsWith('.sql'))
 43:         .sort((a, b) => a.localeCompare(b));
 44: 
 45:     for (const fileName of files) {
 46:         const alreadyApplied = await database.get<{ count: number }>(
 47:             `SELECT COUNT(*) as count FROM _migrations WHERE name = ?`,
 48:             [fileName]
 49:         );
 50:         if ((alreadyApplied?.count ?? 0) > 0) {
 51:             continue;
 52:         }
 53: 
 54:         const sql = fs.readFileSync(path.join(migrationDir, fileName), 'utf8');
 55:         await database.exec('BEGIN');
 56:         try {
 57:             await database.exec(sql);
 58:             await database.run(`INSERT INTO _migrations (name) VALUES (?)`, [fileName]);
 59:             await database.exec('COMMIT');
 60:         } catch (error) {
 61:             await database.exec('ROLLBACK');
 62:             throw error;
 63:         }
 64:     }
 65: 
 66:     // Hardening per DB già esistenti creati prima del sistema migrazioni.
 67:     await ensureColumn(database, 'leads', 'list_name', `TEXT NOT NULL DEFAULT 'default'`);
 68:     await ensureColumn(database, 'leads', 'last_site_check_at', 'DATETIME');
 69:     await ensureColumn(database, 'leads', 'last_error', 'TEXT');
 70:     await ensureColumn(database, 'leads', 'blocked_reason', 'TEXT');
 71:     await ensureColumn(database, 'leads', 'updated_at', 'DATETIME DEFAULT CURRENT_TIMESTAMP');
 72:     await ensureColumn(database, 'lead_lists', 'is_active', 'INTEGER NOT NULL DEFAULT 1');
 73:     await ensureColumn(database, 'lead_lists', 'priority', 'INTEGER NOT NULL DEFAULT 100');
 74:     await ensureColumn(database, 'lead_lists', 'daily_invite_cap', 'INTEGER');
 75:     await ensureColumn(database, 'lead_lists', 'daily_message_cap', 'INTEGER');
 76:     await ensureColumn(database, 'daily_stats', 'messages_sent', 'INTEGER NOT NULL DEFAULT 0');
 77:     await ensureColumn(database, 'daily_stats', 'challenges_count', 'INTEGER NOT NULL DEFAULT 0');
 78:     await ensureColumn(database, 'daily_stats', 'selector_failures', 'INTEGER NOT NULL DEFAULT 0');
 79:     await ensureColumn(database, 'daily_stats', 'run_errors', 'INTEGER NOT NULL DEFAULT 0');
 80:     await ensureColumn(database, 'jobs', 'account_id', `TEXT NOT NULL DEFAULT 'default'`);
 81:     await database.exec(`
 82:         CREATE TABLE IF NOT EXISTS list_daily_stats (
 83:             date TEXT NOT NULL,
 84:             list_name TEXT NOT NULL,
 85:             invites_sent INTEGER NOT NULL DEFAULT 0,
 86:             messages_sent INTEGER NOT NULL DEFAULT 0,
 87:             PRIMARY KEY (date, list_name)
 88:         );
 89:     `);
 90:     await database.exec(`CREATE INDEX IF NOT EXISTS idx_list_daily_stats_list_date ON list_daily_stats(list_name, date);`);
 91:     await database.exec(`CREATE INDEX IF NOT EXISTS idx_leads_status_list_created ON leads(status, list_name, created_at);`);
 92:     await database.exec(`CREATE INDEX IF NOT EXISTS idx_leads_status_last_site_check ON leads(status, last_site_check_at, created_at);`);
 93:     await database.exec(`CREATE INDEX IF NOT EXISTS idx_jobs_type_status_next_run ON jobs(type, status, next_run_at, priority, created_at);`);
 94:     await database.exec(`CREATE INDEX IF NOT EXISTS idx_jobs_account_status_next_run ON jobs(account_id, status, next_run_at, priority, created_at);`);
 95:     await database.exec(`
 96:         CREATE TABLE IF NOT EXISTS company_targets (
 97:             id INTEGER PRIMARY KEY AUTOINCREMENT,
 98:             list_name TEXT NOT NULL,
 99:             account_name TEXT NOT NULL DEFAULT '',
100:             website TEXT NOT NULL DEFAULT '',
101:             source_file TEXT,
102:             status TEXT NOT NULL DEFAULT 'NEW',
103:             created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
104:             updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
105:         );
106:     `);
107:     await ensureColumn(database, 'company_targets', 'attempts', 'INTEGER NOT NULL DEFAULT 0');
108:     await ensureColumn(database, 'company_targets', 'last_error', 'TEXT');
109:     await ensureColumn(database, 'company_targets', 'processed_at', 'DATETIME');
110:     await database.exec(`
111:         CREATE UNIQUE INDEX IF NOT EXISTS uq_company_targets_list_account_website
112:             ON company_targets(list_name, account_name, website);
113:     `);
114:     await database.exec(`
115:         CREATE INDEX IF NOT EXISTS idx_company_targets_list_status
116:             ON company_targets(list_name, status, created_at);
117:     `);
118:     await database.exec(`
119:         CREATE TABLE IF NOT EXISTS runtime_locks (
120:             lock_key TEXT PRIMARY KEY,
121:             owner_id TEXT NOT NULL,
122:             acquired_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
123:             heartbeat_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
124:             expires_at DATETIME NOT NULL,
125:             metadata_json TEXT NOT NULL DEFAULT '{}',
126:             updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
127:         );
128:     `);
129:     await database.exec(`CREATE INDEX IF NOT EXISTS idx_runtime_locks_expires_at ON runtime_locks(expires_at);`);
130: }
131: 
132: export async function getDatabase(): Promise<Database> {
133:     if (db) return db;
134: 
135:     ensureParentDirectoryPrivate(config.dbPath);
136: 
137:     db = await open({
138:         filename: config.dbPath,
139:         driver: sqlite3.Database,
140:     });
141: 
142:     await db.exec(`PRAGMA journal_mode = WAL;`);
143:     await db.exec(`PRAGMA busy_timeout = 5000;`);
144:     await db.exec(`PRAGMA synchronous = NORMAL;`);
145:     ensureFilePrivate(config.dbPath);
146: 
147:     return db;
148: }
149: 
150: export async function initDatabase(): Promise<void> {
151:     const database = await getDatabase();
152:     await applyMigrations(database);
153: }
154: 
155: export async function closeDatabase(): Promise<void> {
156:     if (db) {
157:         await db.close();
158:         db = null;
159:     }
160: }
````

## File: src/proxyManager.ts
````typescript
  1: import fs from 'fs';
  2: import path from 'path';
  3: import { config } from './config';
  4: 
  5: export interface ProxyConfig {
  6:     server: string;
  7:     username?: string;
  8:     password?: string;
  9: }
 10: 
 11: interface ProxyPoolCache {
 12:     proxies: ProxyConfig[];
 13:     signature: string;
 14: }
 15: 
 16: export interface ProxyPoolStatus {
 17:     configured: boolean;
 18:     total: number;
 19:     ready: number;
 20:     cooling: number;
 21:     rotationCursor: number;
 22: }
 23: 
 24: const proxyFailureUntil = new Map<string, number>();
 25: let rotationCursor = 0;
 26: let cachedPool: ProxyPoolCache = { proxies: [], signature: '' };
 27: 
 28: function normalizeProxyServer(value: string): string {
 29:     const trimmed = value.trim();
 30:     if (!trimmed) return '';
 31:     if (/^[a-zA-Z][a-zA-Z\d+.-]*:\/\//.test(trimmed)) {
 32:         return trimmed;
 33:     }
 34:     return `http://${trimmed}`;
 35: }
 36: 
 37: function isLikelyHostPortUserPass(value: string): boolean {
 38:     if (value.includes('://')) return false;
 39:     const parts = value.split(':');
 40:     return parts.length === 4 && !parts[0].includes('/') && !parts[1].includes('/');
 41: }
 42: 
 43: function parseProxyEntry(rawValue: string): ProxyConfig | null {
 44:     const raw = rawValue.trim();
 45:     if (!raw || raw.startsWith('#')) return null;
 46: 
 47:     if (isLikelyHostPortUserPass(raw)) {
 48:         const [host, port, username, password] = raw.split(':');
 49:         return {
 50:             server: `http://${host}:${port}`,
 51:             username: username || undefined,
 52:             password: password || undefined,
 53:         };
 54:     }
 55: 
 56:     const normalized = normalizeProxyServer(raw);
 57:     try {
 58:         const parsed = new URL(normalized);
 59:         const username = parsed.username ? decodeURIComponent(parsed.username) : undefined;
 60:         const password = parsed.password ? decodeURIComponent(parsed.password) : undefined;
 61:         return {
 62:             server: `${parsed.protocol}//${parsed.host}`,
 63:             username,
 64:             password,
 65:         };
 66:     } catch {
 67:         return null;
 68:     }
 69: }
 70: 
 71: function applyGlobalCredentials(proxy: ProxyConfig): ProxyConfig {
 72:     const username = proxy.username ?? config.proxyUsername;
 73:     const password = proxy.password ?? config.proxyPassword;
 74:     return {
 75:         server: proxy.server,
 76:         username: username || undefined,
 77:         password: password || undefined,
 78:     };
 79: }
 80: 
 81: function proxyKey(proxy: ProxyConfig): string {
 82:     return [proxy.server, proxy.username ?? '', proxy.password ?? ''].join('|');
 83: }
 84: 
 85: function signatureForPool(proxyListPath: string | null, proxyUrl: string): string {
 86:     if (proxyListPath) {
 87:         try {
 88:             const stats = fs.statSync(proxyListPath);
 89:             return `${proxyListPath}:${stats.mtimeMs}:${stats.size}`;
 90:         } catch {
 91:             return `${proxyListPath}:missing`;
 92:         }
 93:     }
 94:     return `single:${proxyUrl}:${config.proxyUsername}:${config.proxyPassword}`;
 95: }
 96: 
 97: function loadProxiesFromList(proxyListPath: string): ProxyConfig[] {
 98:     let content = '';
 99:     try {
100:         content = fs.readFileSync(proxyListPath, 'utf8');
101:     } catch {
102:         return [];
103:     }
104: 
105:     const lines = content.split(/\r?\n/);
106:     const proxies: ProxyConfig[] = [];
107:     const seen = new Set<string>();
108:     for (const line of lines) {
109:         const parsed = parseProxyEntry(line);
110:         if (!parsed) continue;
111:         const normalized = applyGlobalCredentials(parsed);
112:         const key = proxyKey(normalized);
113:         if (seen.has(key)) continue;
114:         seen.add(key);
115:         proxies.push(normalized);
116:     }
117:     return proxies;
118: }
119: 
120: function resolveProxyListPath(): string | null {
121:     if (!config.proxyListPath) return null;
122:     const raw = config.proxyListPath.trim();
123:     if (!raw) return null;
124:     return path.isAbsolute(raw) ? raw : path.resolve(process.cwd(), raw);
125: }
126: 
127: function loadProxyPool(): ProxyConfig[] {
128:     const proxyListPath = resolveProxyListPath();
129:     const signature = signatureForPool(proxyListPath, config.proxyUrl);
130:     if (cachedPool.signature === signature) {
131:         return cachedPool.proxies;
132:     }
133: 
134:     let proxies: ProxyConfig[] = [];
135:     if (proxyListPath) {
136:         proxies = loadProxiesFromList(proxyListPath);
137:     } else if (config.proxyUrl) {
138:         const parsed = parseProxyEntry(config.proxyUrl);
139:         if (parsed) {
140:             proxies = [applyGlobalCredentials(parsed)];
141:         }
142:     }
143: 
144:     cachedPool = {
145:         proxies,
146:         signature,
147:     };
148:     if (rotationCursor >= proxies.length) {
149:         rotationCursor = 0;
150:     }
151:     return proxies;
152: }
153: 
154: function orderByRotation(pool: ProxyConfig[]): ProxyConfig[] {
155:     if (pool.length <= 1) {
156:         return pool.slice();
157:     }
158: 
159:     const start = rotationCursor % pool.length;
160:     rotationCursor = (start + 1) % pool.length;
161: 
162:     const ordered: ProxyConfig[] = [];
163:     for (let i = 0; i < pool.length; i++) {
164:         ordered.push(pool[(start + i) % pool.length]);
165:     }
166:     return ordered;
167: }
168: 
169: function splitByCooldown(orderedPool: ProxyConfig[]): { ready: ProxyConfig[]; cooling: ProxyConfig[] } {
170:     const now = Date.now();
171:     const ready: ProxyConfig[] = [];
172:     const cooling: ProxyConfig[] = [];
173: 
174:     for (const proxy of orderedPool) {
175:         const cooldownUntil = proxyFailureUntil.get(proxyKey(proxy)) ?? 0;
176:         if (cooldownUntil > now) {
177:             cooling.push(proxy);
178:         } else {
179:             ready.push(proxy);
180:         }
181:     }
182: 
183:     return { ready, cooling };
184: }
185: 
186: /**
187:  * Restituisce una chain di proxy ordinata:
188:  * - round-robin sul pool
189:  * - prima i proxy non in cooldown
190:  * - poi eventuali proxy in cooldown (fallback estremo)
191:  */
192: export function getProxyFailoverChain(): ProxyConfig[] {
193:     const pool = loadProxyPool();
194:     if (pool.length === 0) return [];
195: 
196:     const rotated = orderByRotation(pool);
197:     const { ready, cooling } = splitByCooldown(rotated);
198:     if (ready.length > 0) {
199:         return ready.concat(cooling);
200:     }
201:     return rotated;
202: }
203: 
204: /**
205:  * Retrocompatibilità: restituisce il primo proxy disponibile.
206:  */
207: export function getProxy(): ProxyConfig | undefined {
208:     const chain = getProxyFailoverChain();
209:     return chain[0];
210: }
211: 
212: export function markProxyFailed(proxy: ProxyConfig): void {
213:     const cooldownMs = config.proxyFailureCooldownMinutes * 60_000;
214:     proxyFailureUntil.set(proxyKey(proxy), Date.now() + cooldownMs);
215: }
216: 
217: export function markProxyHealthy(proxy: ProxyConfig): void {
218:     proxyFailureUntil.delete(proxyKey(proxy));
219: }
220: 
221: export function getProxyPoolStatus(): ProxyPoolStatus {
222:     const pool = loadProxyPool();
223:     if (pool.length === 0) {
224:         return {
225:             configured: false,
226:             total: 0,
227:             ready: 0,
228:             cooling: 0,
229:             rotationCursor: 0,
230:         };
231:     }
232: 
233:     const now = Date.now();
234:     let ready = 0;
235:     let cooling = 0;
236:     for (const proxy of pool) {
237:         const cooldownUntil = proxyFailureUntil.get(proxyKey(proxy)) ?? 0;
238:         if (cooldownUntil > now) {
239:             cooling += 1;
240:         } else {
241:             ready += 1;
242:         }
243:     }
244: 
245:     return {
246:         configured: true,
247:         total: pool.length,
248:         ready,
249:         cooling,
250:         rotationCursor,
251:     };
252: }
````

## File: src/types/domain.ts
````typescript
  1: export type LeadStatus =
  2:     | 'NEW'
  3:     | 'READY_INVITE'
  4:     | 'INVITED'
  5:     | 'ACCEPTED'
  6:     | 'READY_MESSAGE'
  7:     | 'MESSAGED'
  8:     | 'SKIPPED'
  9:     | 'BLOCKED'
 10:     | 'PENDING'; // compat legacy
 11: 
 12: export type JobType = 'INVITE' | 'ACCEPTANCE_CHECK' | 'MESSAGE';
 13: 
 14: export type JobStatus = 'QUEUED' | 'RUNNING' | 'SUCCEEDED' | 'FAILED' | 'DEAD_LETTER' | 'PAUSED';
 15: 
 16: export interface LeadRecord {
 17:     id: number;
 18:     account_name: string;
 19:     first_name: string;
 20:     last_name: string;
 21:     job_title: string;
 22:     website: string;
 23:     linkedin_url: string;
 24:     status: LeadStatus;
 25:     list_name: string;
 26:     invited_at: string | null;
 27:     accepted_at: string | null;
 28:     messaged_at: string | null;
 29:     last_site_check_at?: string | null;
 30:     last_error: string | null;
 31:     blocked_reason: string | null;
 32:     created_at: string;
 33:     updated_at: string | null;
 34: }
 35: 
 36: export interface JobRecord {
 37:     id: number;
 38:     type: JobType;
 39:     status: JobStatus;
 40:     account_id: string;
 41:     payload_json: string;
 42:     idempotency_key: string;
 43:     priority: number;
 44:     attempts: number;
 45:     max_attempts: number;
 46:     next_run_at: string;
 47:     locked_at: string | null;
 48:     last_error: string | null;
 49:     created_at: string;
 50:     updated_at: string | null;
 51: }
 52: 
 53: export interface InviteJobPayload {
 54:     leadId: number;
 55:     localDate: string;
 56: }
 57: 
 58: export interface AcceptanceJobPayload {
 59:     leadId: number;
 60: }
 61: 
 62: export interface MessageJobPayload {
 63:     leadId: number;
 64:     acceptedAtDate: string;
 65: }
 66: 
 67: export type JobPayload = InviteJobPayload | AcceptanceJobPayload | MessageJobPayload;
 68: 
 69: export interface RiskInputs {
 70:     pendingRatio: number;
 71:     errorRate: number;
 72:     selectorFailureRate: number;
 73:     challengeCount: number;
 74:     inviteVelocityRatio: number;
 75: }
 76: 
 77: export interface RiskSnapshot {
 78:     score: number;
 79:     pendingRatio: number;
 80:     errorRate: number;
 81:     selectorFailureRate: number;
 82:     challengeCount: number;
 83:     inviteVelocityRatio: number;
 84:     action: 'NORMAL' | 'WARN' | 'STOP';
 85: }
 86: 
 87: export interface IncidentRecord {
 88:     id: number;
 89:     type: string;
 90:     severity: 'INFO' | 'WARN' | 'CRITICAL';
 91:     status: 'OPEN' | 'ACK' | 'RESOLVED';
 92:     details_json: string;
 93:     opened_at: string;
 94:     acknowledged_at: string | null;
 95:     resolved_at: string | null;
 96: }
 97: 
 98: export interface OutboxEventRecord {
 99:     id: number;
100:     topic: string;
101:     payload_json: string;
102:     idempotency_key: string;
103:     attempts: number;
104:     next_retry_at: string;
105:     delivered_at: string | null;
106:     last_error: string | null;
107:     created_at: string;
108: }
109: 
110: export interface MessageValidationResult {
111:     valid: boolean;
112:     reasons: string[];
113: }
````

## File: src/workers/acceptanceWorker.ts
````typescript
 1: import { detectChallenge, humanDelay } from '../browser';
 2: import { transitionLead } from '../core/leadStateService';
 3: import { getLeadById } from '../core/repositories';
 4: import { SELECTORS } from '../selectors';
 5: import { AcceptanceJobPayload } from '../types/domain';
 6: import { WorkerContext } from './context';
 7: import { ChallengeDetectedError } from './errors';
 8: import { isSalesNavigatorUrl } from '../linkedinUrl';
 9: 
10: function isFirstDegreeBadge(text: string | null): boolean {
11:     if (!text) return true;
12:     return /1st|1°|1\b/i.test(text);
13: }
14: 
15: export async function processAcceptanceJob(payload: AcceptanceJobPayload, context: WorkerContext): Promise<void> {
16:     const lead = await getLeadById(payload.leadId);
17:     if (!lead || lead.status !== 'INVITED') {
18:         return;
19:     }
20: 
21:     if (isSalesNavigatorUrl(lead.linkedin_url)) {
22:         await transitionLead(lead.id, 'BLOCKED', 'salesnav_url_requires_profile_check');
23:         return;
24:     }
25: 
26:     await context.session.page.goto(lead.linkedin_url, { waitUntil: 'domcontentloaded' });
27:     await humanDelay(context.session.page, 2000, 4000);
28: 
29:     if (await detectChallenge(context.session.page)) {
30:         throw new ChallengeDetectedError();
31:     }
32: 
33:     const msgBtn = context.session.page.locator(SELECTORS.messageButton).first();
34:     if (await msgBtn.count() === 0) {
35:         return;
36:     }
37: 
38:     const pendingInvite = (await context.session.page.locator(SELECTORS.invitePendingIndicators).count()) > 0;
39:     const canConnect = (await context.session.page.locator(SELECTORS.connectButtonPrimary).count()) > 0;
40:     const badgeText = await context.session.page.locator(SELECTORS.distanceBadge).first().textContent().catch(() => '');
41:     const connectedWithoutBadge = !pendingInvite && !canConnect;
42:     if (!isFirstDegreeBadge(badgeText) && !connectedWithoutBadge) {
43:         return;
44:     }
45: 
46:     await transitionLead(lead.id, 'ACCEPTED', 'acceptance_detected');
47:     await transitionLead(lead.id, 'READY_MESSAGE', 'message_queue_ready');
48: }
````

## File: src/workers/context.ts
````typescript
1: import { BrowserSession } from '../browser';
2: 
3: export interface WorkerContext {
4:     session: BrowserSession;
5:     dryRun: boolean;
6:     localDate: string;
7:     accountId: string;
8: }
````

## File: src/workers/messageWorker.ts
````typescript
 1: import { detectChallenge, humanDelay, humanMouseMove, humanType, simulateHumanReading } from '../browser';
 2: import { transitionLead } from '../core/leadStateService';
 3: import { countRecentMessageHash, getLeadById, incrementDailyStat, incrementListDailyStat, storeMessageHash } from '../core/repositories';
 4: import { SELECTORS } from '../selectors';
 5: import { MessageJobPayload } from '../types/domain';
 6: import { hashMessage, validateMessageContent } from '../validation/messageValidator';
 7: import { WorkerContext } from './context';
 8: import { ChallengeDetectedError, RetryableWorkerError } from './errors';
 9: import { isSalesNavigatorUrl } from '../linkedinUrl';
10: import { buildPersonalizedFollowUpMessage } from '../ai/messagePersonalizer';
11: import { logInfo } from '../telemetry/logger';
12: 
13: export async function processMessageJob(payload: MessageJobPayload, context: WorkerContext): Promise<void> {
14:     const lead = await getLeadById(payload.leadId);
15:     if (!lead || lead.status !== 'READY_MESSAGE') {
16:         return;
17:     }
18: 
19:     if (isSalesNavigatorUrl(lead.linkedin_url)) {
20:         await transitionLead(lead.id, 'BLOCKED', 'salesnav_url_requires_profile_message');
21:         return;
22:     }
23: 
24:     const personalized = await buildPersonalizedFollowUpMessage(lead);
25:     const message = personalized.message;
26:     const messageHash = hashMessage(message);
27:     const duplicateCount = await countRecentMessageHash(messageHash, 24);
28:     const validation = validateMessageContent(message, { duplicateCountLast24h: duplicateCount });
29:     if (!validation.valid) {
30:         await transitionLead(lead.id, 'BLOCKED', 'message_validation_failed', {
31:             reasons: validation.reasons,
32:         });
33:         return;
34:     }
35: 
36:     await context.session.page.goto(lead.linkedin_url, { waitUntil: 'domcontentloaded' });
37:     await humanDelay(context.session.page, 2500, 5000);
38:     await simulateHumanReading(context.session.page);
39: 
40:     if (await detectChallenge(context.session.page)) {
41:         throw new ChallengeDetectedError();
42:     }
43: 
44:     const msgBtn = context.session.page.locator(SELECTORS.messageButton).first();
45:     if (await msgBtn.count() === 0) {
46:         throw new RetryableWorkerError('Bottone messaggio non trovato', 'MESSAGE_BUTTON_NOT_FOUND');
47:     }
48: 
49:     await humanMouseMove(context.session.page, SELECTORS.messageButton);
50:     await humanDelay(context.session.page, 120, 320);
51:     await msgBtn.click();
52:     await humanDelay(context.session.page, 1200, 2200);
53: 
54:     const textbox = context.session.page.locator(SELECTORS.messageTextbox).first();
55:     if (await textbox.count() === 0) {
56:         await incrementDailyStat(context.localDate, 'selector_failures');
57:         throw new RetryableWorkerError('Textbox messaggio non trovata', 'TEXTBOX_NOT_FOUND');
58:     }
59:     await humanType(context.session.page, SELECTORS.messageTextbox, message);
60:     await humanDelay(context.session.page, 800, 1600);
61: 
62:     if (!context.dryRun) {
63:         const sendBtn = context.session.page.locator(SELECTORS.messageSendButton).first();
64:         if (await sendBtn.count() === 0 || (await sendBtn.isDisabled())) {
65:             await incrementDailyStat(context.localDate, 'selector_failures');
66:             throw new RetryableWorkerError('Bottone invio non disponibile', 'SEND_NOT_AVAILABLE');
67:         }
68:         await humanMouseMove(context.session.page, SELECTORS.messageSendButton);
69:         await humanDelay(context.session.page, 100, 300);
70:         await sendBtn.click();
71:     }
72: 
73:     await transitionLead(lead.id, 'MESSAGED', context.dryRun ? 'message_dry_run' : 'message_sent');
74:     await logInfo('message.generated', {
75:         leadId: lead.id,
76:         source: personalized.source,
77:         model: personalized.model,
78:         messageLength: message.length,
79:     });
80:     await storeMessageHash(lead.id, messageHash);
81:     await incrementDailyStat(context.localDate, 'messages_sent');
82:     await incrementListDailyStat(context.localDate, lead.list_name, 'messages_sent');
83: }
````

## File: src/browser.ts
````typescript
  1: import { chromium, BrowserContext, Page } from 'playwright';
  2: import { config } from './config';
  3: import { ensureDirectoryPrivate } from './security/filesystem';
  4: import { SELECTORS } from './selectors';
  5: import { getProxyFailoverChain, markProxyFailed, markProxyHealthy, ProxyConfig } from './proxyManager';
  6: 
  7: // ─── User-Agent pool (Chrome reali su Windows/macOS/Linux) ──────────────────
  8: const USER_AGENTS = [
  9:     'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36',
 10:     'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36',
 11:     'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36',
 12:     'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
 13:     'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36',
 14:     'Mozilla/5.0 (Windows NT 11.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36',
 15: ];
 16: 
 17: // ─── Viewport pool (risoluzioni comuni reali) ────────────────────────────────
 18: const VIEWPORTS = [
 19:     { width: 1366, height: 768 },
 20:     { width: 1920, height: 1080 },
 21:     { width: 1440, height: 900 },
 22:     { width: 1536, height: 864 },
 23:     { width: 1280, height: 720 },
 24: ];
 25: 
 26: function randomElement<T>(arr: ReadonlyArray<T>): T {
 27:     return arr[Math.floor(Math.random() * arr.length)];
 28: }
 29: 
 30: // ─── Anti-fingerprinting patch (sostituisce playwright-stealth) ──────────────
 31: const STEALTH_INIT_SCRIPT = `
 32: (function () {
 33:     // Rimuove navigator.webdriver
 34:     Object.defineProperty(navigator, 'webdriver', { get: () => undefined, configurable: true });
 35: 
 36:     // Imposta lingue italiane/inglesi realistiche
 37:     Object.defineProperty(navigator, 'languages', { get: () => ['it-IT', 'it', 'en-US', 'en'], configurable: true });
 38: 
 39:     // Sovrascrive platform in base all'UA (approssimato)
 40:     const ua = navigator.userAgent;
 41:     const platform = ua.includes('Win') ? 'Win32' : ua.includes('Mac') ? 'MacIntel' : 'Linux x86_64';
 42:     Object.defineProperty(navigator, 'platform', { get: () => platform, configurable: true });
 43: 
 44:     // Evita rilevamento via plugin vuoti
 45:     Object.defineProperty(navigator, 'plugins', { get: () => [1, 2, 3, 4, 5], configurable: true });
 46: 
 47:     // Rimuove automationControlled da Chrome
 48:     if (window.chrome) {
 49:         Object.defineProperty(window, 'chrome', {
 50:             get: () => ({ runtime: {}, loadTimes: () => {}, csi: () => {} }),
 51:             configurable: true,
 52:         });
 53:     }
 54: 
 55:     // Permessi realistici
 56:     const originalQuery = window.navigator.permissions?.query?.bind(navigator.permissions);
 57:     if (originalQuery) {
 58:         Object.defineProperty(navigator.permissions, 'query', {
 59:             value: (parameters: PermissionDescriptor) =>
 60:                 parameters.name === 'notifications'
 61:                     ? Promise.resolve({ state: Notification.permission } as PermissionStatus)
 62:                     : originalQuery(parameters),
 63:             configurable: true,
 64:         });
 65:     }
 66: })();
 67: `;
 68: 
 69: export interface BrowserSession {
 70:     browser: BrowserContext;
 71:     page: Page;
 72: }
 73: 
 74: export interface LaunchBrowserOptions {
 75:     headless?: boolean;
 76:     proxy?: ProxyConfig;
 77:     sessionDir?: string;
 78: }
 79: 
 80: export async function launchBrowser(options: LaunchBrowserOptions = {}): Promise<BrowserSession> {
 81:     const sessionDir = options.sessionDir ?? config.sessionDir;
 82:     ensureDirectoryPrivate(sessionDir);
 83: 
 84:     const userAgent = randomElement(USER_AGENTS);
 85:     const viewport = randomElement(VIEWPORTS);
 86:     const proxyChain = options.proxy ? [options.proxy] : getProxyFailoverChain();
 87:     const launchPlan: Array<ProxyConfig | undefined> = proxyChain.length > 0 ? proxyChain : [undefined];
 88:     let lastError: unknown = null;
 89: 
 90:     for (let attempt = 0; attempt < launchPlan.length; attempt++) {
 91:         const selectedProxy = launchPlan[attempt];
 92:         const contextOptions: Parameters<typeof chromium.launchPersistentContext>[1] = {
 93:             headless: options.headless ?? config.headless,
 94:             viewport,
 95:             userAgent,
 96:             locale: 'it-IT',
 97:             timezoneId: config.timezone,
 98:         };
 99: 
100:         if (selectedProxy) {
101:             contextOptions.proxy = {
102:                 server: selectedProxy.server,
103:                 username: selectedProxy.username,
104:                 password: selectedProxy.password,
105:             };
106:         }
107: 
108:         try {
109:             const browser = await chromium.launchPersistentContext(sessionDir, contextOptions);
110: 
111:             // Applica patch anti-fingerprinting su tutte le pagine (incluse future)
112:             await browser.addInitScript({ content: STEALTH_INIT_SCRIPT });
113: 
114:             const existingPage = browser.pages()[0];
115:             const page = existingPage ?? await browser.newPage();
116:             if (selectedProxy) {
117:                 markProxyHealthy(selectedProxy);
118:             }
119:             return { browser, page };
120:         } catch (error) {
121:             lastError = error;
122:             if (selectedProxy) {
123:                 markProxyFailed(selectedProxy);
124:                 if (attempt < launchPlan.length - 1) {
125:                     console.warn(
126:                         `[PROXY] Launch fallito su ${selectedProxy.server}, provo il prossimo (${attempt + 2}/${launchPlan.length}).`
127:                     );
128:                 }
129:             }
130:         }
131:     }
132: 
133:     if (lastError instanceof Error) {
134:         throw lastError;
135:     }
136:     throw new Error('Impossibile avviare il browser context.');
137: }
138: 
139: export async function closeBrowser(session: BrowserSession): Promise<void> {
140:     await session.browser.close();
141: }
142: 
143: async function hasLinkedinAuthCookie(page: Page): Promise<boolean> {
144:     try {
145:         const cookies = await page.context().cookies('https://www.linkedin.com');
146:         return cookies.some((cookie) => cookie.name === 'li_at' && cookie.value.trim().length > 0);
147:     } catch {
148:         return false;
149:     }
150: }
151: 
152: export async function isLoggedIn(page: Page): Promise<boolean> {
153:     if (await hasLinkedinAuthCookie(page)) {
154:         return true;
155:     }
156: 
157:     const count = await page.locator(SELECTORS.globalNav).count();
158:     if (count > 0) {
159:         return true;
160:     }
161: 
162:     const currentUrl = page.url().toLowerCase();
163:     if (currentUrl.includes('/login') || currentUrl.includes('/checkpoint') || currentUrl.includes('/challenge')) {
164:         return false;
165:     }
166: 
167:     const loginForm = await page.locator('form[action*="login"], input[name="session_key"]').count();
168:     return loginForm === 0;
169: }
170: 
171: export async function checkLogin(page: Page): Promise<boolean> {
172:     await page.goto('https://www.linkedin.com/', { waitUntil: 'load' });
173:     await humanDelay(page, 2000, 4000);
174:     return isLoggedIn(page);
175: }
176: 
177: export async function detectChallenge(page: Page): Promise<boolean> {
178:     const currentUrl = page.url().toLowerCase();
179:     const challengeInUrl = ['checkpoint', 'challenge', 'captcha', 'security-verification'].some((token) =>
180:         currentUrl.includes(token)
181:     );
182:     if (challengeInUrl) {
183:         return true;
184:     }
185: 
186:     const selectorMatches = await page.locator(SELECTORS.challengeSignals).count();
187:     if (selectorMatches > 0) {
188:         return true;
189:     }
190: 
191:     const pageText = (await page.textContent('body').catch(() => ''))?.toLowerCase() ?? '';
192:     if (!pageText) {
193:         return false;
194:     }
195:     return /temporarily blocked|temporaneamente bloccato|restricted your account|account limitato/.test(pageText);
196: }
197: 
198: // ─── Log-normale (Box-Muller) ─────────────────────────────────────────────────
199: function randomLogNormal(mean: number, stdDev: number): number {
200:     let u = 0, v = 0;
201:     while (u === 0) u = Math.random();
202:     while (v === 0) v = Math.random();
203:     const z = Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
204:     const mu = Math.log(mean) - 0.5 * Math.log(1 + (stdDev / mean) ** 2);
205:     const sigma = Math.sqrt(Math.log(1 + (stdDev / mean) ** 2));
206:     return Math.exp(mu + sigma * z);
207: }
208: 
209: /**
210:  * Pausa con distribuzione log-normale invece di uniforme:
211:  * più realistica perché i tempi di reazione umani seguono questa distribuzione.
212:  */
213: export async function humanDelay(page: Page, min: number = 1500, max: number = 3500): Promise<void> {
214:     const mean = (min + max) / 2;
215:     const std = (max - min) / 4;
216:     const raw = randomLogNormal(mean, std);
217:     const delay = Math.round(Math.min(max * 1.5, Math.max(min, raw)));
218:     await page.waitForTimeout(delay);
219: }
220: 
221: /**
222:  * Simula movimenti del mouse con traiettoria curva in 3 tappe prima di
223:  * arrivare sull'elemento target. Riduce il pattern "click istantaneo".
224:  */
225: export async function humanMouseMove(page: Page, targetSelector: string): Promise<void> {
226:     try {
227:         const box = await page.locator(targetSelector).first().boundingBox();
228:         if (!box) return;
229: 
230:         const startX = 100 + Math.random() * 300;
231:         const startY = 100 + Math.random() * 200;
232:         await page.mouse.move(startX, startY, { steps: 10 });
233:         await page.waitForTimeout(40 + Math.random() * 80);
234: 
235:         // Tappa intermedia con offset casuale (curva naturalistica)
236:         const midX = startX + (box.x - startX) * 0.35 + (Math.random() * 30 - 15);
237:         const midY = startY + (box.y - startY) * 0.35 + (Math.random() * 20 - 10);
238:         await page.mouse.move(midX, midY, { steps: 8 });
239:         await page.waitForTimeout(30 + Math.random() * 60);
240: 
241:         // Target finale (centro dell'elemento con micro-offset)
242:         const finalX = box.x + box.width / 2 + (Math.random() * 6 - 3);
243:         const finalY = box.y + box.height / 2 + (Math.random() * 4 - 2);
244:         // Piccola probabilità di overshoot + correzione, per ridurre pattern troppo perfetti.
245:         if (Math.random() < 0.18) {
246:             const overshootX = finalX + (Math.random() * 18 - 9);
247:             const overshootY = finalY + (Math.random() * 14 - 7);
248:             await page.mouse.move(overshootX, overshootY, { steps: 8 });
249:             await page.waitForTimeout(25 + Math.random() * 70);
250:         }
251:         await page.mouse.move(finalX, finalY, { steps: 12 });
252:     } catch {
253:         // Se l'elemento non è visibile, ignora silenziosamente
254:     }
255: }
256: 
257: /**
258:  * Movimento cursor casuale non legato a click, utile per spezzare pattern
259:  * durante pause lunghe tra job.
260:  */
261: export async function randomMouseMove(page: Page): Promise<void> {
262:     try {
263:         const viewport = page.viewportSize() ?? { width: 1280, height: 800 };
264:         const startX = Math.random() * viewport.width;
265:         const startY = Math.random() * viewport.height;
266:         const endX = Math.random() * viewport.width;
267:         const endY = Math.random() * viewport.height;
268: 
269:         await page.mouse.move(startX, startY, { steps: 6 });
270:         await page.waitForTimeout(30 + Math.random() * 80);
271: 
272:         const midX = startX + (endX - startX) * 0.5 + (Math.random() * 20 - 10);
273:         const midY = startY + (endY - startY) * 0.5 + (Math.random() * 20 - 10);
274:         await page.mouse.move(midX, midY, { steps: 5 });
275:         await page.waitForTimeout(20 + Math.random() * 60);
276:         if (Math.random() < 0.14) {
277:             const overshootX = endX + (Math.random() * 24 - 12);
278:             const overshootY = endY + (Math.random() * 18 - 9);
279:             await page.mouse.move(overshootX, overshootY, { steps: 6 });
280:             await page.waitForTimeout(20 + Math.random() * 60);
281:         }
282:         await page.mouse.move(endX, endY, { steps: 8 });
283:     } catch {
284:         // Non bloccante: se il mouse move fallisce, continua.
285:     }
286: }
287: 
288: /**
289:  * Digita il testo carattere per carattere con delay variabile.
290:  * Include il 3% di probabilità di errore di battitura + correzione (Backspace),
291:  * simulando il comportamento di un utente reale.
292:  */
293: export async function humanType(page: Page, selector: string, text: string): Promise<void> {
294:     const element = page.locator(selector).first();
295:     await element.click();
296:     await humanDelay(page, 200, 500);
297: 
298:     for (let i = 0; i < text.length; i++) {
299:         // 3% di probabilità di digita-sbaglio → correzione
300:         if (Math.random() < 0.03 && text.length > 3) {
301:             const wrongChar = String.fromCharCode(97 + Math.floor(Math.random() * 26));
302:             await element.pressSequentially(wrongChar, { delay: Math.floor(Math.random() * 130) + 40 });
303:             await page.waitForTimeout(280 + Math.random() * 420);
304:             await element.press('Backspace');
305:             await page.waitForTimeout(180 + Math.random() * 250);
306:         }
307: 
308:         await element.pressSequentially(text[i], { delay: Math.floor(Math.random() * 150) + 40 });
309: 
310:         // Pausa più lunga occasionale (come quando si pensa alla prossima parola)
311:         if (Math.random() < 0.04) {
312:             await humanDelay(page, 400, 1100);
313:         }
314:     }
315: }
316: 
317: /**
318:  * Scrolling variabile con 3-7 movimenti, velocità diversa e 30% di probabilità
319:  * di tornare in cima (comportamento dei lettori reali).
320:  */
321: export async function simulateHumanReading(page: Page): Promise<void> {
322:     const scrollCount = 3 + Math.floor(Math.random() * 5); // 3-7 scroll
323:     for (let i = 0; i < scrollCount; i++) {
324:         const deltaY = 150 + Math.random() * 380;
325:         await page.evaluate((dy: number) => window.scrollBy({ top: dy, behavior: 'smooth' }), deltaY);
326:         await humanDelay(page, 700, 2200);
327:     }
328:     // 30% di probabilità di tornare in cima
329:     if (Math.random() < 0.3) {
330:         await page.evaluate(() => window.scrollTo({ top: 0, behavior: 'smooth' }));
331:         await humanDelay(page, 500, 1400);
332:     }
333: }
334: 
335: /**
336:  * Pausa randomizzata tra un job e il successivo per evitare il pattern burst.
337:  * Range: 30–90 secondi di base, con picco occasionale ("pausa caffè").
338:  */
339: export async function interJobDelay(page: Page): Promise<void> {
340:     const base = Math.floor(Math.random() * 60_000) + 30_000;
341:     const longBreak = Math.random() < 0.08 ? Math.floor(Math.random() * 240_000) + 180_000 : 0;
342:     const totalDelay = base + longBreak;
343: 
344:     if (Math.random() < 0.35) {
345:         await randomMouseMove(page);
346:     }
347: 
348:     const split = Math.floor(totalDelay * (0.4 + Math.random() * 0.2));
349:     await page.waitForTimeout(Math.max(0, split));
350: 
351:     if (Math.random() < 0.25) {
352:         await randomMouseMove(page);
353:     }
354: 
355:     await page.waitForTimeout(Math.max(0, totalDelay - split));
356: }
357: 
358: export async function runSelectorCanary(page: Page): Promise<boolean> {
359:     await page.goto('https://www.linkedin.com/feed/', { waitUntil: 'domcontentloaded' });
360:     await humanDelay(page, 1200, 2000);
361:     const navOk = await page.locator(SELECTORS.globalNav).count();
362:     return navOk > 0;
363: }
````

## File: src/config.ts
````typescript
  1: import path from 'path';
  2: import fs from 'fs';
  3: import dotenv from 'dotenv';
  4: 
  5: const envPath = path.resolve(process.cwd(), '.env');
  6: if (fs.existsSync(envPath)) {
  7:     dotenv.config({ path: envPath });
  8: }
  9: 
 10: function parseIntEnv(name: string, fallback: number): number {
 11:     const raw = process.env[name];
 12:     if (!raw) return fallback;
 13:     const parsed = Number.parseInt(raw, 10);
 14:     return Number.isFinite(parsed) ? parsed : fallback;
 15: }
 16: 
 17: function parseFloatEnv(name: string, fallback: number): number {
 18:     const raw = process.env[name];
 19:     if (!raw) return fallback;
 20:     const parsed = Number.parseFloat(raw);
 21:     return Number.isFinite(parsed) ? parsed : fallback;
 22: }
 23: 
 24: function parseBoolEnv(name: string, fallback: boolean): boolean {
 25:     const raw = process.env[name];
 26:     if (raw === undefined) return fallback;
 27:     return raw.toLowerCase() === 'true';
 28: }
 29: 
 30: function parseStringEnv(name: string, fallback: string = ''): string {
 31:     const raw = process.env[name];
 32:     if (raw === undefined) return fallback;
 33:     return raw.trim();
 34: }
 35: 
 36: function resolvePathValue(rawPath: string): string {
 37:     return path.isAbsolute(rawPath) ? rawPath : path.resolve(process.cwd(), rawPath);
 38: }
 39: 
 40: export type EventSyncSink = 'SUPABASE' | 'WEBHOOK' | 'NONE';
 41: 
 42: export interface AccountProfileConfig {
 43:     id: string;
 44:     sessionDir: string;
 45:     proxyUrl: string;
 46:     proxyUsername: string;
 47:     proxyPassword: string;
 48: }
 49: 
 50: function parseEventSyncSinkEnv(name: string, fallback: EventSyncSink): EventSyncSink {
 51:     const raw = parseStringEnv(name, fallback).toUpperCase();
 52:     if (raw === 'SUPABASE' || raw === 'WEBHOOK' || raw === 'NONE') {
 53:         return raw;
 54:     }
 55:     return fallback;
 56: }
 57: 
 58: function resolvePathFromEnv(name: string, fallbackRelativePath: string): string {
 59:     const raw = process.env[name];
 60:     if (!raw) {
 61:         return path.resolve(process.cwd(), fallbackRelativePath);
 62:     }
 63:     return path.isAbsolute(raw) ? raw : path.resolve(process.cwd(), raw);
 64: }
 65: 
 66: function parseAccountProfileFromEnv(slot: 1 | 2): AccountProfileConfig | null {
 67:     const sessionDirRaw = parseStringEnv(`ACCOUNT_${slot}_SESSION_DIR`);
 68:     if (!sessionDirRaw) {
 69:         return null;
 70:     }
 71: 
 72:     const fallbackId = `account${slot}`;
 73:     const id = parseStringEnv(`ACCOUNT_${slot}_ID`, fallbackId) || fallbackId;
 74:     return {
 75:         id,
 76:         sessionDir: resolvePathValue(sessionDirRaw),
 77:         proxyUrl: parseStringEnv(`ACCOUNT_${slot}_PROXY_URL`),
 78:         proxyUsername: parseStringEnv(`ACCOUNT_${slot}_PROXY_USERNAME`),
 79:         proxyPassword: parseStringEnv(`ACCOUNT_${slot}_PROXY_PASSWORD`),
 80:     };
 81: }
 82: 
 83: export interface AppConfig {
 84:     timezone: string;
 85:     headless: boolean;
 86:     workingHoursStart: number;
 87:     workingHoursEnd: number;
 88:     maxConcurrentJobs: number;
 89:     jobStuckMinutes: number;
 90:     retryMaxAttempts: number;
 91:     retryBaseMs: number;
 92:     workflowLoopIntervalMs: number;
 93:     companyEnrichmentEnabled: boolean;
 94:     companyEnrichmentBatch: number;
 95:     companyEnrichmentMaxProfilesPerCompany: number;
 96:     maxConsecutiveJobFailures: number;
 97:     maxSelectorFailuresPerDay: number;
 98:     maxRunErrorsPerDay: number;
 99:     autoPauseMinutesOnFailureBurst: number;
100:     retentionDays: number;
101:     softInviteCap: number;
102:     hardInviteCap: number;
103:     weeklyInviteLimit: number;
104:     softMsgCap: number;
105:     hardMsgCap: number;
106:     messageScheduleMinDelayHours: number;
107:     messageScheduleMaxDelayHours: number;
108:     riskWarnThreshold: number;
109:     riskStopThreshold: number;
110:     pendingRatioWarn: number;
111:     pendingRatioStop: number;
112:     adaptiveCapsEnabled: boolean;
113:     adaptiveCapsPendingWarn: number;
114:     adaptiveCapsPendingStop: number;
115:     adaptiveCapsBlockedWarn: number;
116:     adaptiveCapsMinFactor: number;
117:     adaptiveCapsWarnFactor: number;
118:     cooldownEnabled: boolean;
119:     cooldownWarnScore: number;
120:     cooldownHighScore: number;
121:     cooldownPendingThreshold: number;
122:     cooldownPendingHighThreshold: number;
123:     cooldownWarnMinutes: number;
124:     cooldownHighMinutes: number;
125:     noBurstEnabled: boolean;
126:     noBurstMinDelaySec: number;
127:     noBurstMaxDelaySec: number;
128:     noBurstLongBreakEvery: number;
129:     noBurstLongBreakMinSec: number;
130:     noBurstLongBreakMaxSec: number;
131:     autoSiteCheckEnabled: boolean;
132:     autoSiteCheckLimit: number;
133:     autoSiteCheckFix: boolean;
134:     autoSiteCheckIntervalHours: number;
135:     siteCheckStaleDays: number;
136:     postRunStateSyncEnabled: boolean;
137:     postRunStateSyncLimit: number;
138:     postRunStateSyncFix: boolean;
139:     selectorCanaryEnabled: boolean;
140:     outboxAlertBacklog: number;
141:     sessionDir: string;
142:     multiAccountEnabled: boolean;
143:     accountProfiles: AccountProfileConfig[];
144:     dbPath: string;
145:     eventSyncSink: EventSyncSink;
146:     supabaseSyncEnabled: boolean;
147:     supabaseUrl: string;
148:     supabaseServiceRoleKey: string;
149:     supabaseSyncBatchSize: number;
150:     supabaseSyncIntervalMs: number;
151:     supabaseSyncMaxRetries: number;
152:     webhookSyncEnabled: boolean;
153:     webhookSyncUrl: string;
154:     webhookSyncSecret: string;
155:     webhookSyncBatchSize: number;
156:     webhookSyncTimeoutMs: number;
157:     webhookSyncMaxRetries: number;
158:     openaiApiKey: string;
159:     openaiBaseUrl: string;
160:     aiModel: string;
161:     aiRequestTimeoutMs: number;
162:     aiPersonalizationEnabled: boolean;
163:     aiMessageMaxChars: number;
164:     aiGuardianEnabled: boolean;
165:     aiGuardianMinIntervalMinutes: number;
166:     aiGuardianPauseMinutes: number;
167:     telegramBotToken: string;
168:     telegramChatId: string;
169:     proxyUrl: string;
170:     proxyUsername: string;
171:     proxyPassword: string;
172:     proxyListPath: string;
173:     proxyFailureCooldownMinutes: number;
174:     proxyRotateEveryJobs: number;
175:     proxyRotateEveryMinutes: number;
176:     inviteWithNote: boolean;
177:     inviteNoteMode: 'template' | 'ai';
178:     salesNavSyncEnabled: boolean;
179:     salesNavSyncListName: string;
180:     salesNavSyncListUrl: string;
181:     salesNavSyncMaxPages: number;
182:     salesNavSyncIntervalHours: number;
183:     salesNavSyncLimit: number;
184:     salesNavSyncAccountId: string;
185:     randomActivityEnabled: boolean;
186:     randomActivityProbability: number;
187:     randomActivityMaxActions: number;
188: }
189: 
190: const configuredAccountProfiles: AccountProfileConfig[] = [parseAccountProfileFromEnv(1), parseAccountProfileFromEnv(2)]
191:     .filter((profile): profile is AccountProfileConfig => profile !== null);
192: 
193: export const config: AppConfig = {
194:     timezone: process.env.TIMEZONE ?? 'Europe/Rome',
195:     headless: parseBoolEnv('HEADLESS', false),
196:     workingHoursStart: parseIntEnv('HOUR_START', 9),
197:     workingHoursEnd: parseIntEnv('HOUR_END', 18),
198:     maxConcurrentJobs: Math.max(1, parseIntEnv('MAX_CONCURRENT_JOBS', 1)),
199:     jobStuckMinutes: Math.max(1, parseIntEnv('JOB_STUCK_MINUTES', 30)),
200:     retryMaxAttempts: Math.max(1, parseIntEnv('RETRY_MAX_ATTEMPTS', 3)),
201:     retryBaseMs: Math.max(100, parseIntEnv('RETRY_BASE_MS', 1200)),
202:     workflowLoopIntervalMs: Math.max(10_000, parseIntEnv('WORKFLOW_LOOP_INTERVAL_MS', 900000)),
203:     companyEnrichmentEnabled: parseBoolEnv('COMPANY_ENRICHMENT_ENABLED', true),
204:     companyEnrichmentBatch: Math.max(1, parseIntEnv('COMPANY_ENRICHMENT_BATCH', 5)),
205:     companyEnrichmentMaxProfilesPerCompany: Math.max(1, parseIntEnv('COMPANY_ENRICHMENT_MAX_PROFILES_PER_COMPANY', 3)),
206:     maxConsecutiveJobFailures: Math.max(1, parseIntEnv('MAX_CONSECUTIVE_JOB_FAILURES', 4)),
207:     maxSelectorFailuresPerDay: Math.max(1, parseIntEnv('MAX_SELECTOR_FAILURES_PER_DAY', 8)),
208:     maxRunErrorsPerDay: Math.max(1, parseIntEnv('MAX_RUN_ERRORS_PER_DAY', 20)),
209:     autoPauseMinutesOnFailureBurst: Math.max(1, parseIntEnv('AUTO_PAUSE_MINUTES_ON_FAILURE_BURST', 180)),
210:     retentionDays: Math.max(7, parseIntEnv('RETENTION_DAYS', 45)),
211:     softInviteCap: Math.max(1, parseIntEnv('SOFT_INVITE_CAP', 25)),
212:     hardInviteCap: Math.max(1, parseIntEnv('HARD_INVITE_CAP', 35)),
213:     weeklyInviteLimit: Math.max(1, parseIntEnv('WEEKLY_INVITE_LIMIT', 120)),
214:     softMsgCap: Math.max(1, parseIntEnv('SOFT_MSG_CAP', 40)),
215:     hardMsgCap: Math.max(1, parseIntEnv('HARD_MSG_CAP', 60)),
216:     messageScheduleMinDelayHours: Math.max(0, parseIntEnv('MESSAGE_SCHEDULE_MIN_DELAY_HOURS', 0)),
217:     messageScheduleMaxDelayHours: Math.max(0, parseIntEnv('MESSAGE_SCHEDULE_MAX_DELAY_HOURS', 0)),
218:     riskWarnThreshold: parseIntEnv('RISK_WARN_THRESHOLD', 60),
219:     riskStopThreshold: parseIntEnv('RISK_STOP_THRESHOLD', 80),
220:     pendingRatioWarn: parseFloatEnv('PENDING_RATIO_WARN', 0.65),
221:     pendingRatioStop: parseFloatEnv('PENDING_RATIO_STOP', 0.8),
222:     adaptiveCapsEnabled: parseBoolEnv('ADAPTIVE_CAPS_ENABLED', true),
223:     adaptiveCapsPendingWarn: Math.min(1, Math.max(0, parseFloatEnv('ADAPTIVE_CAPS_PENDING_WARN', 0.55))),
224:     adaptiveCapsPendingStop: Math.min(1, Math.max(0, parseFloatEnv('ADAPTIVE_CAPS_PENDING_STOP', 0.72))),
225:     adaptiveCapsBlockedWarn: Math.min(1, Math.max(0, parseFloatEnv('ADAPTIVE_CAPS_BLOCKED_WARN', 0.25))),
226:     adaptiveCapsMinFactor: Math.min(1, Math.max(0.05, parseFloatEnv('ADAPTIVE_CAPS_MIN_FACTOR', 0.25))),
227:     adaptiveCapsWarnFactor: Math.min(1, Math.max(0.05, parseFloatEnv('ADAPTIVE_CAPS_WARN_FACTOR', 0.85))),
228:     cooldownEnabled: parseBoolEnv('COOLDOWN_ENABLED', true),
229:     cooldownWarnScore: Math.max(0, parseIntEnv('COOLDOWN_WARN_SCORE', 68)),
230:     cooldownHighScore: Math.max(0, parseIntEnv('COOLDOWN_HIGH_SCORE', 75)),
231:     cooldownPendingThreshold: Math.min(1, Math.max(0, parseFloatEnv('COOLDOWN_PENDING_THRESHOLD', 0.65))),
232:     cooldownPendingHighThreshold: Math.min(1, Math.max(0, parseFloatEnv('COOLDOWN_PENDING_HIGH_THRESHOLD', 0.75))),
233:     cooldownWarnMinutes: Math.max(10, parseIntEnv('COOLDOWN_WARN_MINUTES', 2880)),
234:     cooldownHighMinutes: Math.max(10, parseIntEnv('COOLDOWN_HIGH_MINUTES', 4320)),
235:     noBurstEnabled: parseBoolEnv('NO_BURST_ENABLED', true),
236:     noBurstMinDelaySec: Math.max(0, parseIntEnv('NO_BURST_MIN_DELAY_SEC', 8)),
237:     noBurstMaxDelaySec: Math.max(0, parseIntEnv('NO_BURST_MAX_DELAY_SEC', 25)),
238:     noBurstLongBreakEvery: Math.max(0, parseIntEnv('NO_BURST_LONG_BREAK_EVERY', 7)),
239:     noBurstLongBreakMinSec: Math.max(0, parseIntEnv('NO_BURST_LONG_BREAK_MIN_SEC', 120)),
240:     noBurstLongBreakMaxSec: Math.max(0, parseIntEnv('NO_BURST_LONG_BREAK_MAX_SEC', 360)),
241:     autoSiteCheckEnabled: parseBoolEnv('AUTO_SITE_CHECK_ENABLED', true),
242:     autoSiteCheckLimit: Math.max(1, parseIntEnv('AUTO_SITE_CHECK_LIMIT', 20)),
243:     autoSiteCheckFix: parseBoolEnv('AUTO_SITE_CHECK_FIX', true),
244:     autoSiteCheckIntervalHours: Math.max(1, parseIntEnv('AUTO_SITE_CHECK_INTERVAL_HOURS', 24)),
245:     siteCheckStaleDays: Math.max(0, parseIntEnv('SITE_CHECK_STALE_DAYS', 2)),
246:     postRunStateSyncEnabled: parseBoolEnv('POST_RUN_STATE_SYNC_ENABLED', true),
247:     postRunStateSyncLimit: Math.max(1, parseIntEnv('POST_RUN_STATE_SYNC_LIMIT', 8)),
248:     postRunStateSyncFix: parseBoolEnv('POST_RUN_STATE_SYNC_FIX', true),
249:     selectorCanaryEnabled: parseBoolEnv('SELECTOR_CANARY_ENABLED', true),
250:     outboxAlertBacklog: Math.max(1, parseIntEnv('OUTBOX_ALERT_BACKLOG', 1000)),
251:     sessionDir: resolvePathFromEnv('SESSION_DIR', path.join('data', 'session')),
252:     multiAccountEnabled: parseBoolEnv('MULTI_ACCOUNT_ENABLED', configuredAccountProfiles.length > 1),
253:     accountProfiles: configuredAccountProfiles,
254:     dbPath: resolvePathFromEnv('DB_PATH', path.join('data', 'linkedin_bot.sqlite')),
255:     eventSyncSink: parseEventSyncSinkEnv('EVENT_SYNC_SINK', 'SUPABASE'),
256:     supabaseSyncEnabled: parseBoolEnv('SUPABASE_SYNC_ENABLED', true),
257:     supabaseUrl: parseStringEnv('SUPABASE_URL'),
258:     supabaseServiceRoleKey: parseStringEnv('SUPABASE_SERVICE_ROLE_KEY'),
259:     supabaseSyncBatchSize: Math.max(1, parseIntEnv('SUPABASE_SYNC_BATCH_SIZE', 100)),
260:     supabaseSyncIntervalMs: Math.max(1000, parseIntEnv('SUPABASE_SYNC_INTERVAL_MS', 15000)),
261:     supabaseSyncMaxRetries: Math.max(1, parseIntEnv('SUPABASE_SYNC_MAX_RETRIES', 8)),
262:     webhookSyncEnabled: parseBoolEnv('WEBHOOK_SYNC_ENABLED', false),
263:     webhookSyncUrl: parseStringEnv('WEBHOOK_SYNC_URL'),
264:     webhookSyncSecret: parseStringEnv('WEBHOOK_SYNC_SECRET'),
265:     webhookSyncBatchSize: Math.max(1, parseIntEnv('WEBHOOK_SYNC_BATCH_SIZE', 100)),
266:     webhookSyncTimeoutMs: Math.max(1000, parseIntEnv('WEBHOOK_SYNC_TIMEOUT_MS', 10000)),
267:     webhookSyncMaxRetries: Math.max(1, parseIntEnv('WEBHOOK_SYNC_MAX_RETRIES', 8)),
268:     openaiApiKey: parseStringEnv('OPENAI_API_KEY'),
269:     openaiBaseUrl: parseStringEnv('OPENAI_BASE_URL', 'https://api.openai.com/v1'),
270:     aiModel: parseStringEnv('AI_MODEL', 'gpt-4.1-mini'),
271:     aiRequestTimeoutMs: Math.max(1000, parseIntEnv('AI_REQUEST_TIMEOUT_MS', 12000)),
272:     aiPersonalizationEnabled: parseBoolEnv('AI_PERSONALIZATION_ENABLED', false),
273:     aiMessageMaxChars: Math.max(120, parseIntEnv('AI_MESSAGE_MAX_CHARS', 450)),
274:     aiGuardianEnabled: parseBoolEnv('AI_GUARDIAN_ENABLED', false),
275:     aiGuardianMinIntervalMinutes: Math.max(1, parseIntEnv('AI_GUARDIAN_MIN_INTERVAL_MINUTES', 60)),
276:     aiGuardianPauseMinutes: Math.max(10, parseIntEnv('AI_GUARDIAN_PAUSE_MINUTES', 180)),
277:     telegramBotToken: parseStringEnv('TELEGRAM_BOT_TOKEN'),
278:     telegramChatId: parseStringEnv('TELEGRAM_CHAT_ID'),
279:     proxyUrl: parseStringEnv('PROXY_URL'),
280:     proxyUsername: parseStringEnv('PROXY_USERNAME'),
281:     proxyPassword: parseStringEnv('PROXY_PASSWORD'),
282:     proxyListPath: parseStringEnv('PROXY_LIST'),
283:     proxyFailureCooldownMinutes: Math.max(1, parseIntEnv('PROXY_FAILURE_COOLDOWN_MINUTES', 30)),
284:     proxyRotateEveryJobs: Math.max(0, parseIntEnv('PROXY_ROTATE_EVERY_JOBS', 0)),
285:     proxyRotateEveryMinutes: Math.max(0, parseIntEnv('PROXY_ROTATE_EVERY_MINUTES', 0)),
286:     inviteWithNote: parseBoolEnv('INVITE_WITH_NOTE', false),
287:     inviteNoteMode: (parseStringEnv('INVITE_NOTE_MODE', 'template') === 'ai' ? 'ai' : 'template') as 'template' | 'ai',
288:     salesNavSyncEnabled: parseBoolEnv('SALESNAV_SYNC_ENABLED', false),
289:     salesNavSyncListName: parseStringEnv('SALESNAV_SYNC_LIST_NAME', 'default'),
290:     salesNavSyncListUrl: parseStringEnv('SALESNAV_SYNC_LIST_URL'),
291:     salesNavSyncMaxPages: Math.max(1, parseIntEnv('SALESNAV_SYNC_MAX_PAGES', 3)),
292:     salesNavSyncIntervalHours: Math.max(1, parseIntEnv('SALESNAV_SYNC_INTERVAL_HOURS', 24)),
293:     salesNavSyncLimit: Math.max(1, parseIntEnv('SALESNAV_SYNC_LIMIT', 30)),
294:     salesNavSyncAccountId: parseStringEnv('SALESNAV_SYNC_ACCOUNT_ID'),
295:     randomActivityEnabled: parseBoolEnv('RANDOM_ACTIVITY_ENABLED', false),
296:     randomActivityProbability: Math.min(1, Math.max(0, parseFloatEnv('RANDOM_ACTIVITY_PROBABILITY', 0.15))),
297:     randomActivityMaxActions: Math.max(1, parseIntEnv('RANDOM_ACTIVITY_MAX_ACTIONS', 3)),
298: };
299: 
300: // Retrocompatibilità con vecchi moduli ancora presenti nel repository.
301: export const legacyLimits = {
302:     dailyInviteLimit: config.hardInviteCap,
303:     weeklyInviteLimit: config.weeklyInviteLimit,
304:     dailyMsgLimit: config.hardMsgCap,
305: };
306: 
307: export function isWorkingHour(now: Date = new Date()): boolean {
308:     const hour = getHourInTimezone(now, config.timezone);
309:     return hour >= config.workingHoursStart && hour < config.workingHoursEnd;
310: }
311: 
312: export function getLocalDateString(now: Date = new Date(), timezone: string = config.timezone): string {
313:     const formatter = new Intl.DateTimeFormat('en-CA', {
314:         timeZone: timezone,
315:         year: 'numeric',
316:         month: '2-digit',
317:         day: '2-digit',
318:     });
319:     return formatter.format(now);
320: }
321: 
322: export function getHourInTimezone(now: Date, timezone: string): number {
323:     const formatter = new Intl.DateTimeFormat('en-GB', {
324:         timeZone: timezone,
325:         hour: '2-digit',
326:         hour12: false,
327:     });
328:     const formatted = formatter.format(now);
329:     return Number.parseInt(formatted, 10);
330: }
331: 
332: export function getWeekStartDate(now: Date = new Date(), timezone: string = config.timezone): string {
333:     const localDate = getLocalDateString(now, timezone);
334:     const [year, month, day] = localDate.split('-').map((value) => Number.parseInt(value, 10));
335:     const anchor = new Date(Date.UTC(year, month - 1, day));
336:     const weekday = anchor.getUTCDay();
337:     const delta = weekday === 0 ? -6 : 1 - weekday;
338:     anchor.setUTCDate(anchor.getUTCDate() + delta);
339:     const anchorYear = anchor.getUTCFullYear();
340:     const anchorMonth = String(anchor.getUTCMonth() + 1).padStart(2, '0');
341:     const anchorDay = String(anchor.getUTCDate()).padStart(2, '0');
342:     return `${anchorYear}-${anchorMonth}-${anchorDay}`;
343: }
````

## File: src/core/jobRunner.ts
````typescript
  1: import { BrowserSession, closeBrowser, interJobDelay, launchBrowser, checkLogin } from '../browser';
  2: import { getRuntimeAccountProfiles, isMultiAccountRuntimeEnabled, RuntimeAccountProfile } from '../accountManager';
  3: import { config } from '../config';
  4: import { pauseAutomation, quarantineAccount } from '../risk/incidentManager';
  5: import { logError, logInfo, logWarn } from '../telemetry/logger';
  6: import { JobType } from '../types/domain';
  7: import { WorkerContext } from '../workers/context';
  8: import { processAcceptanceJob } from '../workers/acceptanceWorker';
  9: import { processInviteJob } from '../workers/inviteWorker';
 10: import { processMessageJob } from '../workers/messageWorker';
 11: import { ChallengeDetectedError } from '../workers/errors';
 12: import {
 13:     createJobAttempt,
 14:     getAutomationPauseState,
 15:     getRuntimeFlag,
 16:     incrementDailyStat,
 17:     lockNextQueuedJob,
 18:     markJobRetryOrDeadLetter,
 19:     markJobSucceeded,
 20:     parseJobPayload,
 21:     pushOutboxEvent,
 22: } from './repositories';
 23: 
 24: export interface RunJobsOptions {
 25:     localDate: string;
 26:     allowedTypes: JobType[];
 27:     dryRun: boolean;
 28: }
 29: 
 30: function retryDelayMs(attempt: number): number {
 31:     const jitter = Math.floor(Math.random() * 250);
 32:     return config.retryBaseMs * Math.pow(2, Math.max(0, attempt - 1)) + jitter;
 33: }
 34: 
 35: async function rotateSessionWithLoginCheck(
 36:     session: BrowserSession,
 37:     workerContext: WorkerContext,
 38:     reason: string,
 39:     account: RuntimeAccountProfile,
 40: ): Promise<BrowserSession | null> {
 41:     await logInfo('job_runner.session_rotate.start', { reason, accountId: account.id });
 42:     await closeBrowser(session);
 43: 
 44:     const rotated = await launchBrowser({
 45:         sessionDir: account.sessionDir,
 46:         proxy: account.proxy,
 47:     });
 48:     const loggedIn = await checkLogin(rotated.page);
 49:     if (!loggedIn) {
 50:         await closeBrowser(rotated);
 51:         await quarantineAccount('LOGIN_MISSING', {
 52:             message: 'Sessione non autenticata su LinkedIn dopo rotazione proxy/sessione',
 53:             reason,
 54:             accountId: account.id,
 55:         });
 56:         return null;
 57:     }
 58: 
 59:     workerContext.session = rotated;
 60:     await logInfo('job_runner.session_rotate.ok', { reason, accountId: account.id });
 61:     return rotated;
 62: }
 63: 
 64: async function runQueuedJobsForAccount(
 65:     options: RunJobsOptions,
 66:     account: RuntimeAccountProfile,
 67:     includeLegacyDefaultQueue: boolean
 68: ): Promise<void> {
 69:     let session = await launchBrowser({
 70:         sessionDir: account.sessionDir,
 71:         proxy: account.proxy,
 72:     });
 73:     let sessionClosed = false;
 74:     try {
 75:         const loggedIn = await checkLogin(session.page);
 76:         if (!loggedIn) {
 77:             await quarantineAccount('LOGIN_MISSING', {
 78:                 message: 'Sessione non autenticata su LinkedIn',
 79:                 accountId: account.id,
 80:             });
 81:             return;
 82:         }
 83: 
 84:         const workerContext: WorkerContext = {
 85:             session,
 86:             dryRun: options.dryRun,
 87:             localDate: options.localDate,
 88:             accountId: account.id,
 89:         };
 90:         let consecutiveFailures = 0;
 91:         let processedOnCurrentSession = 0;
 92:         const rotateEveryJobs = config.proxyRotateEveryJobs;
 93:         const rotateEveryMinutes = config.proxyRotateEveryMinutes;
 94:         const rotateEveryMs = rotateEveryMinutes > 0 ? rotateEveryMinutes * 60_000 : 0;
 95:         let sessionStartedAtMs = Date.now();
 96: 
 97:         while (true) {
 98:             const pauseState = await getAutomationPauseState();
 99:             if (pauseState.paused) {
100:                 await logWarn('job_runner.skipped_paused', {
101:                     accountId: account.id,
102:                     reason: pauseState.reason,
103:                     pausedUntil: pauseState.pausedUntil,
104:                     remainingSeconds: pauseState.remainingSeconds,
105:                 });
106:                 break;
107:             }
108: 
109:             const job = await lockNextQueuedJob(options.allowedTypes, account.id, includeLegacyDefaultQueue);
110:             if (!job) break;
111: 
112:             await logInfo('job.started', {
113:                 jobId: job.id,
114:                 type: job.type,
115:                 attempt: job.attempts + 1,
116:                 accountId: account.id,
117:                 jobAccountId: job.account_id,
118:             });
119: 
120:             try {
121:                 if (job.type === 'INVITE') {
122:                     const parsed = parseJobPayload<{ leadId: number; localDate: string }>(job);
123:                     await processInviteJob(parsed.payload, workerContext);
124:                 } else if (job.type === 'ACCEPTANCE_CHECK') {
125:                     const parsed = parseJobPayload<{ leadId: number }>(job);
126:                     await processAcceptanceJob(parsed.payload, workerContext);
127:                 } else if (job.type === 'MESSAGE') {
128:                     const parsed = parseJobPayload<{ leadId: number; acceptedAtDate: string }>(job);
129:                     await processMessageJob(parsed.payload, workerContext);
130:                 }
131: 
132:                 await markJobSucceeded(job.id);
133:                 await createJobAttempt(job.id, true, null, null, null);
134:                 await pushOutboxEvent(
135:                     'job.succeeded',
136:                     { jobId: job.id, type: job.type, dryRun: options.dryRun, accountId: account.id },
137:                     `job.succeeded:${job.id}:${job.type}`
138:                 );
139:                 consecutiveFailures = 0;
140: 
141:                 // Pausa umana tra un job e il successivo (anti-burst)
142:                 await interJobDelay(session.page);
143:                 processedOnCurrentSession += 1;
144:             } catch (error) {
145:                 const message = error instanceof Error ? error.message : String(error);
146:                 const attempts = job.attempts + 1;
147: 
148:                 await createJobAttempt(job.id, false, error instanceof Error ? error.name : 'UNKNOWN_ERROR', message, null);
149:                 await incrementDailyStat(options.localDate, 'run_errors');
150: 
151:                 if (error instanceof ChallengeDetectedError) {
152:                     await incrementDailyStat(options.localDate, 'challenges_count');
153:                     await quarantineAccount('CHALLENGE_DETECTED', {
154:                         jobId: job.id,
155:                         jobType: job.type,
156:                         message,
157:                         accountId: account.id,
158:                     });
159:                     await markJobRetryOrDeadLetter(job.id, attempts, attempts, 0, message);
160:                     await logError('job.challenge_detected', { jobId: job.id, type: job.type, message, accountId: account.id });
161:                     break;
162:                 }
163: 
164:                 processedOnCurrentSession += 1;
165: 
166:                 const nextDelay = retryDelayMs(attempts);
167:                 const status = await markJobRetryOrDeadLetter(job.id, attempts, job.max_attempts, nextDelay, message);
168:                 await pushOutboxEvent(
169:                     'job.failed',
170:                     {
171:                         jobId: job.id,
172:                         type: job.type,
173:                         attempts,
174:                         status,
175:                         error: message,
176:                         accountId: account.id,
177:                     },
178:                     `job.failed:${job.id}:${attempts}`
179:                 );
180: 
181:                 await logWarn('job.failed', {
182:                     jobId: job.id,
183:                     type: job.type,
184:                     status,
185:                     attempts,
186:                     message,
187:                     accountId: account.id,
188:                 });
189: 
190:                 consecutiveFailures += 1;
191:                 if (consecutiveFailures >= config.maxConsecutiveJobFailures) {
192:                     await pauseAutomation(
193:                         'CONSECUTIVE_JOB_FAILURES',
194:                         {
195:                             threshold: config.maxConsecutiveJobFailures,
196:                             consecutiveFailures,
197:                             lastJobId: job.id,
198:                             lastJobType: job.type,
199:                             lastError: message,
200:                             accountId: account.id,
201:                         },
202:                         config.autoPauseMinutesOnFailureBurst
203:                     );
204:                     await logWarn('job_runner.paused.failure_burst', {
205:                         threshold: config.maxConsecutiveJobFailures,
206:                         consecutiveFailures,
207:                         pauseMinutes: config.autoPauseMinutesOnFailureBurst,
208:                         accountId: account.id,
209:                     });
210:                     break;
211:                 }
212:             }
213: 
214:             const rotateReasons: string[] = [];
215:             if (rotateEveryJobs > 0 && processedOnCurrentSession >= rotateEveryJobs) {
216:                 rotateReasons.push(`threshold_${rotateEveryJobs}_jobs`);
217:             }
218:             if (rotateEveryMs > 0 && Date.now() - sessionStartedAtMs >= rotateEveryMs) {
219:                 rotateReasons.push(`threshold_${rotateEveryMinutes}_minutes`);
220:             }
221: 
222:             if (rotateReasons.length > 0) {
223:                 const rotated = await rotateSessionWithLoginCheck(
224:                     session,
225:                     workerContext,
226:                     rotateReasons.join('+'),
227:                     account
228:                 );
229:                 if (!rotated) {
230:                     sessionClosed = true;
231:                     return;
232:                 }
233:                 session = rotated;
234:                 processedOnCurrentSession = 0;
235:                 sessionStartedAtMs = Date.now();
236:             }
237:         }
238:     } finally {
239:         if (!sessionClosed) {
240:             await closeBrowser(session);
241:         }
242:     }
243: }
244: 
245: export async function runQueuedJobs(options: RunJobsOptions): Promise<void> {
246:     const quarantineFlag = await getRuntimeFlag('account_quarantine');
247:     if (quarantineFlag === 'true') {
248:         await logWarn('job_runner.skipped_quarantine', { reason: 'account_quarantine=true' });
249:         return;
250:     }
251: 
252:     const accounts = getRuntimeAccountProfiles();
253:     for (let index = 0; index < accounts.length; index++) {
254:         const account = accounts[index];
255:         const includeLegacyDefaultQueue = isMultiAccountRuntimeEnabled() && index === 0 && account.id !== 'default';
256:         await logInfo('job_runner.account.start', {
257:             accountId: account.id,
258:             includeLegacyDefaultQueue,
259:             sessionDir: account.sessionDir,
260:         });
261: 
262:         await runQueuedJobsForAccount(options, account, includeLegacyDefaultQueue);
263: 
264:         await logInfo('job_runner.account.done', { accountId: account.id });
265:         const latestQuarantineFlag = await getRuntimeFlag('account_quarantine');
266:         if (latestQuarantineFlag === 'true') {
267:             break;
268:         }
269:     }
270: }
````

## File: src/core/repositories.ts
````typescript
   1: import { Database } from 'sqlite';
   2: import { getDatabase } from '../db';
   3: import {
   4:     JobRecord,
   5:     JobStatus,
   6:     JobType,
   7:     LeadRecord,
   8:     LeadStatus,
   9:     OutboxEventRecord,
  10:     RiskInputs,
  11: } from '../types/domain';
  12: import { normalizeLinkedInUrl } from '../linkedinUrl';
  13: 
  14: function parsePayload<T>(raw: string): T {
  15:     try {
  16:         return JSON.parse(raw) as T;
  17:     } catch {
  18:         return {} as T;
  19:     }
  20: }
  21: 
  22: async function withTransaction<T>(database: Database, callback: () => Promise<T>): Promise<T> {
  23:     await database.exec('BEGIN IMMEDIATE');
  24:     try {
  25:         const result = await callback();
  26:         await database.exec('COMMIT');
  27:         return result;
  28:     } catch (error) {
  29:         await database.exec('ROLLBACK');
  30:         throw error;
  31:     }
  32: }
  33: 
  34: function normalizeLegacyStatus(status: LeadStatus): LeadStatus {
  35:     if (status === 'PENDING') {
  36:         return 'READY_INVITE';
  37:     }
  38:     return status;
  39: }
  40: 
  41: export async function ensureLeadList(listName: string): Promise<void> {
  42:     const db = await getDatabase();
  43:     await db.run(`INSERT OR IGNORE INTO lead_lists (name, source) VALUES (?, 'import')`, [listName]);
  44: }
  45: 
  46: export async function syncLeadListsFromLeads(): Promise<void> {
  47:     const db = await getDatabase();
  48:     await db.run(
  49:         `
  50:         INSERT OR IGNORE INTO lead_lists (name, source)
  51:         SELECT DISTINCT list_name, 'legacy'
  52:         FROM leads
  53:         WHERE TRIM(COALESCE(list_name, '')) <> ''
  54:     `
  55:     );
  56: }
  57: 
  58: export async function listLeadCampaignConfigs(onlyActive: boolean = false): Promise<LeadListCampaignConfig[]> {
  59:     const db = await getDatabase();
  60:     const rows = onlyActive
  61:         ? await db.all<LeadListRow[]>(
  62:             `
  63:             SELECT name, source, is_active, priority, daily_invite_cap, daily_message_cap, created_at
  64:             FROM lead_lists
  65:             WHERE is_active = 1
  66:             ORDER BY priority ASC, created_at ASC, name ASC
  67:         `
  68:         )
  69:         : await db.all<LeadListRow[]>(
  70:             `
  71:             SELECT name, source, is_active, priority, daily_invite_cap, daily_message_cap, created_at
  72:             FROM lead_lists
  73:             ORDER BY is_active DESC, priority ASC, created_at ASC, name ASC
  74:         `
  75:         );
  76: 
  77:     return rows.map(normalizeLeadListRow);
  78: }
  79: 
  80: export async function updateLeadCampaignConfig(listName: string, patch: UpdateLeadListCampaignInput): Promise<LeadListCampaignConfig> {
  81:     await ensureLeadList(listName);
  82: 
  83:     const setParts: string[] = [];
  84:     const params: unknown[] = [];
  85: 
  86:     if (Object.prototype.hasOwnProperty.call(patch, 'isActive')) {
  87:         setParts.push('is_active = ?');
  88:         params.push(patch.isActive ? 1 : 0);
  89:     }
  90:     if (Object.prototype.hasOwnProperty.call(patch, 'priority')) {
  91:         setParts.push('priority = ?');
  92:         params.push(Math.max(1, patch.priority ?? 100));
  93:     }
  94:     if (Object.prototype.hasOwnProperty.call(patch, 'dailyInviteCap')) {
  95:         setParts.push('daily_invite_cap = ?');
  96:         params.push(patch.dailyInviteCap === null ? null : Math.max(0, patch.dailyInviteCap ?? 0));
  97:     }
  98:     if (Object.prototype.hasOwnProperty.call(patch, 'dailyMessageCap')) {
  99:         setParts.push('daily_message_cap = ?');
 100:         params.push(patch.dailyMessageCap === null ? null : Math.max(0, patch.dailyMessageCap ?? 0));
 101:     }
 102: 
 103:     if (setParts.length > 0) {
 104:         const db = await getDatabase();
 105:         await db.run(
 106:             `
 107:             UPDATE lead_lists
 108:             SET ${setParts.join(', ')}
 109:             WHERE name = ?
 110:         `,
 111:             [...params, listName]
 112:         );
 113:     }
 114: 
 115:     const configs = await listLeadCampaignConfigs(false);
 116:     const updated = configs.find((config) => config.name === listName);
 117:     if (!updated) {
 118:         throw new Error(`Configurazione lista ${listName} non trovata dopo update.`);
 119:     }
 120:     return updated;
 121: }
 122: 
 123: export async function upsertSalesNavList(name: string, url: string): Promise<SalesNavListRecord> {
 124:     const db = await getDatabase();
 125:     const normalizedName = name.trim();
 126:     const normalizedUrl = normalizeLinkedInUrl(url.trim());
 127:     if (!normalizedName || !normalizedUrl) {
 128:         throw new Error('upsertSalesNavList: name/url mancanti');
 129:     }
 130: 
 131:     await db.run(
 132:         `
 133:         INSERT INTO salesnav_lists (name, url)
 134:         VALUES (?, ?)
 135:         ON CONFLICT(name) DO UPDATE SET
 136:             url = excluded.url,
 137:             updated_at = CURRENT_TIMESTAMP
 138:     `,
 139:         [normalizedName, normalizedUrl]
 140:     );
 141: 
 142:     const row = await db.get<SalesNavListRecord>(
 143:         `SELECT id, name, url, last_synced_at, created_at, updated_at FROM salesnav_lists WHERE name = ?`,
 144:         [normalizedName]
 145:     );
 146:     if (!row) {
 147:         throw new Error(`Lista SalesNav non trovata dopo upsert: ${normalizedName}`);
 148:     }
 149:     return row;
 150: }
 151: 
 152: export async function markSalesNavListSynced(listId: number): Promise<void> {
 153:     const db = await getDatabase();
 154:     await db.run(
 155:         `
 156:         UPDATE salesnav_lists
 157:         SET last_synced_at = CURRENT_TIMESTAMP,
 158:             updated_at = CURRENT_TIMESTAMP
 159:         WHERE id = ?
 160:     `,
 161:         [listId]
 162:     );
 163: }
 164: 
 165: export async function linkLeadToSalesNavList(listId: number, leadId: number): Promise<void> {
 166:     const db = await getDatabase();
 167:     await db.run(
 168:         `
 169:         INSERT OR IGNORE INTO salesnav_list_items (list_id, lead_id)
 170:         VALUES (?, ?)
 171:     `,
 172:         [listId, leadId]
 173:     );
 174: }
 175: 
 176: export async function listSalesNavLists(limit: number = 200): Promise<SalesNavListSummary[]> {
 177:     const db = await getDatabase();
 178:     const safeLimit = Math.max(1, limit);
 179:     return db.all<SalesNavListSummary[]>(
 180:         `
 181:         SELECT
 182:             l.id,
 183:             l.name,
 184:             l.url,
 185:             l.last_synced_at,
 186:             l.created_at,
 187:             l.updated_at,
 188:             COUNT(i.id) as leads_count
 189:         FROM salesnav_lists l
 190:         LEFT JOIN salesnav_list_items i ON i.list_id = l.id
 191:         GROUP BY l.id, l.name, l.url, l.last_synced_at, l.created_at, l.updated_at
 192:         ORDER BY
 193:             CASE WHEN l.last_synced_at IS NULL THEN 0 ELSE 1 END ASC,
 194:             l.last_synced_at ASC,
 195:             l.name ASC
 196:         LIMIT ?
 197:     `,
 198:         [safeLimit]
 199:     );
 200: }
 201: 
 202: export async function getSalesNavListByName(name: string): Promise<SalesNavListRecord | null> {
 203:     const db = await getDatabase();
 204:     const normalizedName = name.trim();
 205:     if (!normalizedName) return null;
 206:     const row = await db.get<SalesNavListRecord>(
 207:         `SELECT id, name, url, last_synced_at, created_at, updated_at FROM salesnav_lists WHERE name = ? LIMIT 1`,
 208:         [normalizedName]
 209:     );
 210:     return row ?? null;
 211: }
 212: 
 213: export interface AddLeadInput {
 214:     accountName: string;
 215:     firstName: string;
 216:     lastName: string;
 217:     jobTitle: string;
 218:     website: string;
 219:     linkedinUrl: string;
 220:     listName: string;
 221: }
 222: 
 223: export interface UpsertSalesNavigatorLeadInput {
 224:     accountName: string;
 225:     firstName: string;
 226:     lastName: string;
 227:     jobTitle: string;
 228:     website: string;
 229:     linkedinUrl: string;
 230:     listName: string;
 231: }
 232: 
 233: export interface UpsertSalesNavigatorLeadResult {
 234:     leadId: number;
 235:     action: 'inserted' | 'updated' | 'unchanged';
 236: }
 237: 
 238: export interface SalesNavListRecord {
 239:     id: number;
 240:     name: string;
 241:     url: string;
 242:     last_synced_at: string | null;
 243:     created_at: string;
 244:     updated_at: string;
 245: }
 246: 
 247: export interface SalesNavListSummary extends SalesNavListRecord {
 248:     leads_count: number;
 249: }
 250: 
 251: interface LeadListRow {
 252:     name: string;
 253:     source: string;
 254:     is_active: number;
 255:     priority: number;
 256:     daily_invite_cap: number | null;
 257:     daily_message_cap: number | null;
 258:     created_at: string;
 259: }
 260: 
 261: export interface LeadListCampaignConfig {
 262:     name: string;
 263:     source: string;
 264:     isActive: boolean;
 265:     priority: number;
 266:     dailyInviteCap: number | null;
 267:     dailyMessageCap: number | null;
 268:     createdAt: string;
 269: }
 270: 
 271: export interface UpdateLeadListCampaignInput {
 272:     isActive?: boolean;
 273:     priority?: number;
 274:     dailyInviteCap?: number | null;
 275:     dailyMessageCap?: number | null;
 276: }
 277: 
 278: export interface AddCompanyTargetInput {
 279:     listName: string;
 280:     accountName: string;
 281:     website: string;
 282:     sourceFile?: string | null;
 283: }
 284: 
 285: export type CompanyTargetStatus = 'NEW' | 'ENRICHED' | 'NO_MATCH' | 'ERROR';
 286: 
 287: export interface CompanyTargetRecord {
 288:     id: number;
 289:     list_name: string;
 290:     account_name: string;
 291:     website: string;
 292:     source_file: string | null;
 293:     status: CompanyTargetStatus;
 294:     attempts: number;
 295:     last_error: string | null;
 296:     processed_at: string | null;
 297:     created_at: string;
 298:     updated_at: string;
 299: }
 300: 
 301: export interface DailyStatsSnapshot {
 302:     date: string;
 303:     invitesSent: number;
 304:     messagesSent: number;
 305:     challengesCount: number;
 306:     selectorFailures: number;
 307:     runErrors: number;
 308: }
 309: 
 310: export interface JobStatusCounts {
 311:     QUEUED: number;
 312:     RUNNING: number;
 313:     SUCCEEDED: number;
 314:     FAILED: number;
 315:     DEAD_LETTER: number;
 316:     PAUSED: number;
 317: }
 318: 
 319: export interface AutomationPauseState {
 320:     paused: boolean;
 321:     pausedUntil: string | null;
 322:     reason: string | null;
 323:     remainingSeconds: number | null;
 324: }
 325: 
 326: export interface PrivacyCleanupStats {
 327:     runLogs: number;
 328:     jobAttempts: number;
 329:     leadEvents: number;
 330:     messageHistory: number;
 331:     deliveredOutboxEvents: number;
 332:     resolvedIncidents: number;
 333: }
 334: 
 335: export interface ListLeadStatusCount {
 336:     list_name: string;
 337:     status: LeadStatus;
 338:     total: number;
 339: }
 340: 
 341: export interface RuntimeLockRecord {
 342:     lock_key: string;
 343:     owner_id: string;
 344:     acquired_at: string;
 345:     heartbeat_at: string;
 346:     expires_at: string;
 347:     metadata_json: string;
 348:     updated_at: string;
 349: }
 350: 
 351: export interface AcquireRuntimeLockResult {
 352:     acquired: boolean;
 353:     lock: RuntimeLockRecord | null;
 354: }
 355: 
 356: function normalizeLeadListRow(row: LeadListRow): LeadListCampaignConfig {
 357:     return {
 358:         name: row.name,
 359:         source: row.source,
 360:         isActive: row.is_active === 1,
 361:         priority: row.priority,
 362:         dailyInviteCap: row.daily_invite_cap,
 363:         dailyMessageCap: row.daily_message_cap,
 364:         createdAt: row.created_at,
 365:     };
 366: }
 367: 
 368: export async function addLead(input: AddLeadInput): Promise<boolean> {
 369:     const db = await getDatabase();
 370:     await ensureLeadList(input.listName);
 371: 
 372:     const result = await db.run(
 373:         `
 374:         INSERT OR IGNORE INTO leads
 375:             (account_name, first_name, last_name, job_title, website, linkedin_url, status, list_name)
 376:         VALUES (?, ?, ?, ?, ?, ?, 'NEW', ?)
 377:     `,
 378:         [
 379:             input.accountName,
 380:             input.firstName,
 381:             input.lastName,
 382:             input.jobTitle,
 383:             input.website,
 384:             input.linkedinUrl,
 385:             input.listName,
 386:         ]
 387:     );
 388: 
 389:     // Mantiene la relazione lista<->lead anche quando il lead esiste già.
 390:     const leadRow = await db.get<{ id: number }>(`SELECT id FROM leads WHERE linkedin_url = ?`, [input.linkedinUrl]);
 391:     const listRow = await db.get<{ id: number }>(`SELECT id FROM lead_lists WHERE name = ?`, [input.listName]);
 392:     if (leadRow?.id && listRow?.id) {
 393:         await db.run(`INSERT OR IGNORE INTO list_leads (list_id, lead_id) VALUES (?, ?)`, [listRow.id, leadRow.id]);
 394:     }
 395: 
 396:     return (result.changes ?? 0) > 0;
 397: }
 398: 
 399: function normalizeTextValue(value: string): string {
 400:     return (value ?? '').trim();
 401: }
 402: 
 403: function mergedLeadValue(current: string, incoming: string): string {
 404:     const normalizedIncoming = normalizeTextValue(incoming);
 405:     if (!normalizedIncoming) {
 406:         return current;
 407:     }
 408:     if (normalizeTextValue(current) === normalizedIncoming) {
 409:         return current;
 410:     }
 411:     return normalizedIncoming;
 412: }
 413: 
 414: export async function getLeadByLinkedinUrl(linkedinUrl: string): Promise<LeadRecord | null> {
 415:     const db = await getDatabase();
 416:     const normalizedUrl = normalizeLinkedInUrl(linkedinUrl);
 417:     const lead = await db.get<LeadRecord>(`SELECT * FROM leads WHERE linkedin_url = ?`, [normalizedUrl]);
 418:     if (!lead) return null;
 419:     lead.status = normalizeLegacyStatus(lead.status);
 420:     return lead;
 421: }
 422: 
 423: export async function upsertSalesNavigatorLead(input: UpsertSalesNavigatorLeadInput): Promise<UpsertSalesNavigatorLeadResult> {
 424:     const db = await getDatabase();
 425:     const listName = normalizeTextValue(input.listName) || 'default';
 426:     const linkedinUrl = normalizeLinkedInUrl(input.linkedinUrl);
 427: 
 428:     return withTransaction(db, async () => {
 429:         await ensureLeadList(listName);
 430:         const existing = await db.get<LeadRecord>(`SELECT * FROM leads WHERE linkedin_url = ?`, [linkedinUrl]);
 431: 
 432:         const normalizedAccountName = normalizeTextValue(input.accountName);
 433:         const normalizedFirstName = normalizeTextValue(input.firstName);
 434:         const normalizedLastName = normalizeTextValue(input.lastName);
 435:         const normalizedJobTitle = normalizeTextValue(input.jobTitle);
 436:         const normalizedWebsite = normalizeTextValue(input.website);
 437: 
 438:         let leadId = 0;
 439:         let action: UpsertSalesNavigatorLeadResult['action'] = 'unchanged';
 440: 
 441:         if (!existing) {
 442:             const insertResult = await db.run(
 443:                 `
 444:                 INSERT INTO leads
 445:                     (account_name, first_name, last_name, job_title, website, linkedin_url, status, list_name)
 446:                 VALUES (?, ?, ?, ?, ?, ?, 'NEW', ?)
 447:             `,
 448:                 [
 449:                     normalizedAccountName,
 450:                     normalizedFirstName,
 451:                     normalizedLastName,
 452:                     normalizedJobTitle,
 453:                     normalizedWebsite,
 454:                     linkedinUrl,
 455:                     listName,
 456:                 ]
 457:             );
 458:             leadId = insertResult.lastID ?? 0;
 459:             action = 'inserted';
 460:         } else {
 461:             leadId = existing.id;
 462:             const nextAccountName = mergedLeadValue(existing.account_name, normalizedAccountName);
 463:             const nextFirstName = mergedLeadValue(existing.first_name, normalizedFirstName);
 464:             const nextLastName = mergedLeadValue(existing.last_name, normalizedLastName);
 465:             const nextJobTitle = mergedLeadValue(existing.job_title, normalizedJobTitle);
 466:             const nextWebsite = normalizeTextValue(existing.website)
 467:                 ? existing.website
 468:                 : mergedLeadValue(existing.website, normalizedWebsite);
 469:             const nextListName = listName;
 470: 
 471:             const changed = nextAccountName !== existing.account_name
 472:                 || nextFirstName !== existing.first_name
 473:                 || nextLastName !== existing.last_name
 474:                 || nextJobTitle !== existing.job_title
 475:                 || nextWebsite !== existing.website
 476:                 || nextListName !== existing.list_name;
 477: 
 478:             if (changed) {
 479:                 await db.run(
 480:                     `
 481:                     UPDATE leads
 482:                     SET account_name = ?,
 483:                         first_name = ?,
 484:                         last_name = ?,
 485:                         job_title = ?,
 486:                         website = ?,
 487:                         list_name = ?,
 488:                         updated_at = CURRENT_TIMESTAMP
 489:                     WHERE id = ?
 490:                 `,
 491:                     [
 492:                         nextAccountName,
 493:                         nextFirstName,
 494:                         nextLastName,
 495:                         nextJobTitle,
 496:                         nextWebsite,
 497:                         nextListName,
 498:                         leadId,
 499:                     ]
 500:                 );
 501:                 action = 'updated';
 502:             }
 503:         }
 504: 
 505:         const linkedLead = leadId > 0
 506:             ? { id: leadId }
 507:             : await db.get<{ id: number }>(`SELECT id FROM leads WHERE linkedin_url = ?`, [linkedinUrl]);
 508:         const listRow = await db.get<{ id: number }>(`SELECT id FROM lead_lists WHERE name = ?`, [listName]);
 509:         if (linkedLead?.id && listRow?.id) {
 510:             await db.run(`INSERT OR IGNORE INTO list_leads (list_id, lead_id) VALUES (?, ?)`, [listRow.id, linkedLead.id]);
 511:         }
 512: 
 513:         return {
 514:             leadId: linkedLead?.id ?? leadId,
 515:             action,
 516:         };
 517:     });
 518: }
 519: 
 520: export async function addCompanyTarget(input: AddCompanyTargetInput): Promise<boolean> {
 521:     const db = await getDatabase();
 522:     await ensureLeadList(input.listName);
 523: 
 524:     const normalizedAccountName = (input.accountName ?? '').trim();
 525:     const normalizedWebsite = (input.website ?? '').trim();
 526:     if (!normalizedAccountName && !normalizedWebsite) {
 527:         return false;
 528:     }
 529: 
 530:     const result = await db.run(
 531:         `
 532:         INSERT OR IGNORE INTO company_targets (list_name, account_name, website, source_file, status)
 533:         VALUES (?, ?, ?, ?, 'NEW')
 534:     `,
 535:         [input.listName, normalizedAccountName, normalizedWebsite, input.sourceFile ?? null]
 536:     );
 537:     return (result.changes ?? 0) > 0;
 538: }
 539: 
 540: export async function countCompanyTargets(listName?: string): Promise<number> {
 541:     const db = await getDatabase();
 542:     const row = listName
 543:         ? await db.get<{ total: number }>(
 544:             `SELECT COUNT(*) as total FROM company_targets WHERE list_name = ?`,
 545:             [listName]
 546:         )
 547:         : await db.get<{ total: number }>(
 548:             `SELECT COUNT(*) as total FROM company_targets`
 549:         );
 550:     return row?.total ?? 0;
 551: }
 552: 
 553: export async function listCompanyTargets(listName: string | null, limit: number): Promise<CompanyTargetRecord[]> {
 554:     const db = await getDatabase();
 555:     const safeLimit = Math.max(1, limit);
 556:     if (listName) {
 557:         return db.all<CompanyTargetRecord[]>(
 558:             `
 559:             SELECT id, list_name, account_name, website, source_file, status, attempts, last_error, processed_at, created_at, updated_at
 560:             FROM company_targets
 561:             WHERE list_name = ?
 562:             ORDER BY updated_at DESC, created_at DESC
 563:             LIMIT ?
 564:         `,
 565:             [listName, safeLimit]
 566:         );
 567:     }
 568: 
 569:     return db.all<CompanyTargetRecord[]>(
 570:         `
 571:         SELECT id, list_name, account_name, website, source_file, status, attempts, last_error, processed_at, created_at, updated_at
 572:         FROM company_targets
 573:         ORDER BY updated_at DESC, created_at DESC
 574:         LIMIT ?
 575:     `,
 576:         [safeLimit]
 577:     );
 578: }
 579: 
 580: export async function getCompanyTargetsForEnrichment(limit: number): Promise<CompanyTargetRecord[]> {
 581:     const db = await getDatabase();
 582:     const safeLimit = Math.max(1, limit);
 583:     return db.all<CompanyTargetRecord[]>(
 584:         `
 585:         SELECT id, list_name, account_name, website, source_file, status, attempts, last_error, processed_at, created_at, updated_at
 586:         FROM company_targets
 587:         WHERE status IN ('NEW', 'ERROR')
 588:         ORDER BY status DESC, created_at ASC
 589:         LIMIT ?
 590:     `,
 591:         [safeLimit]
 592:     );
 593: }
 594: 
 595: export async function setCompanyTargetStatus(
 596:     targetId: number,
 597:     status: CompanyTargetStatus,
 598:     lastError: string | null = null
 599: ): Promise<void> {
 600:     const db = await getDatabase();
 601:     await db.run(
 602:         `
 603:         UPDATE company_targets
 604:         SET status = ?,
 605:             attempts = attempts + 1,
 606:             last_error = ?,
 607:             processed_at = CURRENT_TIMESTAMP,
 608:             updated_at = CURRENT_TIMESTAMP
 609:         WHERE id = ?
 610:     `,
 611:         [status, lastError, targetId]
 612:     );
 613: }
 614: 
 615: export async function countCompanyTargetsByStatuses(statuses: CompanyTargetStatus[]): Promise<number> {
 616:     if (statuses.length === 0) return 0;
 617:     const db = await getDatabase();
 618:     const placeholders = statuses.map(() => '?').join(', ');
 619:     const row = await db.get<{ total: number }>(
 620:         `SELECT COUNT(*) as total FROM company_targets WHERE status IN (${placeholders})`,
 621:         statuses
 622:     );
 623:     return row?.total ?? 0;
 624: }
 625: 
 626: export async function promoteNewLeadsToReadyInvite(limit: number): Promise<number> {
 627:     const db = await getDatabase();
 628:     const leads = await db.all<{ id: number }[]>(
 629:         `SELECT id FROM leads WHERE status = 'NEW' ORDER BY created_at ASC LIMIT ?`,
 630:         [limit]
 631:     );
 632:     if (leads.length === 0) return 0;
 633: 
 634:     const ids = leads.map((lead) => lead.id);
 635:     const placeholders = ids.map(() => '?').join(', ');
 636:     const result = await db.run(
 637:         `UPDATE leads SET status = 'READY_INVITE', updated_at = CURRENT_TIMESTAMP WHERE id IN (${placeholders})`,
 638:         ids
 639:     );
 640:     return result.changes ?? 0;
 641: }
 642: 
 643: export async function getLeadById(leadId: number): Promise<LeadRecord | null> {
 644:     const db = await getDatabase();
 645:     const lead = await db.get<LeadRecord>(`SELECT * FROM leads WHERE id = ?`, [leadId]);
 646:     if (!lead) return null;
 647:     lead.status = normalizeLegacyStatus(lead.status);
 648:     return lead;
 649: }
 650: 
 651: export async function getLeadsWithSalesNavigatorUrls(limit: number): Promise<LeadRecord[]> {
 652:     const db = await getDatabase();
 653:     const safeLimit = Math.max(1, limit);
 654:     const leads = await db.all<LeadRecord[]>(
 655:         `
 656:         SELECT *
 657:         FROM leads
 658:         WHERE linkedin_url LIKE '%linkedin.com/sales/%'
 659:           AND status IN ('NEW', 'READY_INVITE', 'INVITED', 'ACCEPTED', 'READY_MESSAGE', 'BLOCKED', 'PENDING')
 660:         ORDER BY updated_at DESC, created_at ASC
 661:         LIMIT ?
 662:     `,
 663:         [safeLimit]
 664:     );
 665:     return leads.map((lead) => ({ ...lead, status: normalizeLegacyStatus(lead.status) }));
 666: }
 667: 
 668: export interface UpdateLeadLinkedinUrlResult {
 669:     updated: boolean;
 670:     conflictLeadId: number | null;
 671: }
 672: 
 673: export async function updateLeadLinkedinUrl(leadId: number, nextLinkedinUrl: string): Promise<UpdateLeadLinkedinUrlResult> {
 674:     const db = await getDatabase();
 675:     const normalizedUrl = normalizeLinkedInUrl(nextLinkedinUrl);
 676: 
 677:     try {
 678:         const result = await db.run(
 679:             `
 680:             UPDATE leads
 681:             SET linkedin_url = ?,
 682:                 updated_at = CURRENT_TIMESTAMP
 683:             WHERE id = ?
 684:         `,
 685:             [normalizedUrl, leadId]
 686:         );
 687:         return {
 688:             updated: (result.changes ?? 0) > 0,
 689:             conflictLeadId: null,
 690:         };
 691:     } catch (error) {
 692:         const message = error instanceof Error ? error.message : String(error);
 693:         if (!/UNIQUE constraint failed:\s*leads\.linkedin_url/i.test(message)) {
 694:             throw error;
 695:         }
 696:         const conflict = await db.get<{ id: number }>(
 697:             `SELECT id FROM leads WHERE linkedin_url = ? LIMIT 1`,
 698:             [normalizedUrl]
 699:         );
 700:         return {
 701:             updated: false,
 702:             conflictLeadId: conflict?.id ?? null,
 703:         };
 704:     }
 705: }
 706: 
 707: export async function getLeadsByStatus(status: LeadStatus, limit: number): Promise<LeadRecord[]> {
 708:     const db = await getDatabase();
 709:     const normalized = normalizeLegacyStatus(status);
 710:     const leads = await db.all<LeadRecord[]>(
 711:         `SELECT * FROM leads WHERE status = ? ORDER BY created_at ASC LIMIT ?`,
 712:         [normalized, limit]
 713:     );
 714:     return leads.map((lead) => ({ ...lead, status: normalizeLegacyStatus(lead.status) }));
 715: }
 716: 
 717: export async function getLeadsByStatusForSiteCheck(status: LeadStatus, limit: number, staleDays: number): Promise<LeadRecord[]> {
 718:     const db = await getDatabase();
 719:     const normalized = normalizeLegacyStatus(status);
 720:     const safeLimit = Math.max(1, limit);
 721:     const safeStaleDays = Math.max(0, staleDays);
 722:     const leads = await db.all<LeadRecord[]>(
 723:         `
 724:         SELECT *
 725:         FROM leads
 726:         WHERE status = ?
 727:           AND (
 728:             last_site_check_at IS NULL
 729:             OR last_site_check_at <= DATETIME('now', '-' || ? || ' days')
 730:           )
 731:         ORDER BY
 732:             CASE WHEN last_site_check_at IS NULL THEN 0 ELSE 1 END ASC,
 733:             last_site_check_at ASC,
 734:             created_at ASC
 735:         LIMIT ?
 736:     `,
 737:         [normalized, safeStaleDays, safeLimit]
 738:     );
 739:     return leads.map((lead) => ({ ...lead, status: normalizeLegacyStatus(lead.status) }));
 740: }
 741: 
 742: export async function getLeadsByStatusForList(status: LeadStatus, listName: string, limit: number): Promise<LeadRecord[]> {
 743:     const db = await getDatabase();
 744:     const normalized = normalizeLegacyStatus(status);
 745:     const leads = await db.all<LeadRecord[]>(
 746:         `
 747:         SELECT *
 748:         FROM leads
 749:         WHERE status = ?
 750:           AND list_name = ?
 751:         ORDER BY created_at ASC
 752:         LIMIT ?
 753:     `,
 754:         [normalized, listName, limit]
 755:     );
 756:     return leads.map((lead) => ({ ...lead, status: normalizeLegacyStatus(lead.status) }));
 757: }
 758: 
 759: export async function touchLeadSiteCheckAt(leadId: number): Promise<void> {
 760:     const db = await getDatabase();
 761:     await db.run(
 762:         `
 763:         UPDATE leads
 764:         SET last_site_check_at = CURRENT_TIMESTAMP,
 765:             updated_at = CURRENT_TIMESTAMP
 766:         WHERE id = ?
 767:     `,
 768:         [leadId]
 769:     );
 770: }
 771: 
 772: export async function countLeadsByStatuses(statuses: LeadStatus[]): Promise<number> {
 773:     if (statuses.length === 0) return 0;
 774:     const db = await getDatabase();
 775:     const normalized = statuses.map((status) => normalizeLegacyStatus(status));
 776:     const placeholders = normalized.map(() => '?').join(', ');
 777:     const row = await db.get<{ total: number }>(
 778:         `SELECT COUNT(*) as total FROM leads WHERE status IN (${placeholders})`,
 779:         normalized
 780:     );
 781:     return row?.total ?? 0;
 782: }
 783: 
 784: export async function getLeadStatusCountsForLists(listNames: string[]): Promise<ListLeadStatusCount[]> {
 785:     if (listNames.length === 0) {
 786:         return [];
 787:     }
 788: 
 789:     const db = await getDatabase();
 790:     const placeholders = listNames.map(() => '?').join(', ');
 791:     return db.all<ListLeadStatusCount[]>(
 792:         `
 793:         SELECT list_name, status, COUNT(*) as total
 794:         FROM leads
 795:         WHERE list_name IN (${placeholders})
 796:         GROUP BY list_name, status
 797:     `,
 798:         listNames
 799:     );
 800: }
 801: 
 802: export async function setLeadStatus(leadId: number, status: LeadStatus, errorMessage?: string, blockedReason?: string): Promise<void> {
 803:     const db = await getDatabase();
 804:     const normalized = normalizeLegacyStatus(status);
 805:     const timestampColumn = normalized === 'INVITED' ? 'invited_at' : normalized === 'ACCEPTED' ? 'accepted_at' : normalized === 'MESSAGED' ? 'messaged_at' : null;
 806: 
 807:     if (timestampColumn) {
 808:         await db.run(
 809:             `
 810:             UPDATE leads
 811:             SET status = ?, ${timestampColumn} = CURRENT_TIMESTAMP, last_error = ?, blocked_reason = ?, updated_at = CURRENT_TIMESTAMP
 812:             WHERE id = ?
 813:         `,
 814:             [normalized, errorMessage ?? null, blockedReason ?? null, leadId]
 815:         );
 816:         return;
 817:     }
 818: 
 819:     await db.run(
 820:         `
 821:         UPDATE leads
 822:         SET status = ?, last_error = ?, blocked_reason = ?, updated_at = CURRENT_TIMESTAMP
 823:         WHERE id = ?
 824:     `,
 825:         [normalized, errorMessage ?? null, blockedReason ?? null, leadId]
 826:     );
 827: }
 828: 
 829: export async function appendLeadEvent(
 830:     leadId: number,
 831:     fromStatus: LeadStatus,
 832:     toStatus: LeadStatus,
 833:     reason: string,
 834:     metadata: Record<string, unknown>
 835: ): Promise<void> {
 836:     const db = await getDatabase();
 837:     await db.run(
 838:         `
 839:         INSERT INTO lead_events (lead_id, from_status, to_status, reason, metadata_json)
 840:         VALUES (?, ?, ?, ?, ?)
 841:     `,
 842:         [leadId, normalizeLegacyStatus(fromStatus), normalizeLegacyStatus(toStatus), reason, JSON.stringify(metadata)]
 843:     );
 844: }
 845: 
 846: export async function getDailyStat(dateString: string, field: 'invites_sent' | 'messages_sent' | 'challenges_count' | 'selector_failures' | 'run_errors'): Promise<number> {
 847:     const db = await getDatabase();
 848:     const row = await db.get<Record<string, number>>(
 849:         `SELECT ${field} FROM daily_stats WHERE date = ?`,
 850:         [dateString]
 851:     );
 852:     return row?.[field] ?? 0;
 853: }
 854: 
 855: export async function getDailyStatsSnapshot(dateString: string): Promise<DailyStatsSnapshot> {
 856:     const db = await getDatabase();
 857:     const row = await db.get<{
 858:         invites_sent: number;
 859:         messages_sent: number;
 860:         challenges_count: number;
 861:         selector_failures: number;
 862:         run_errors: number;
 863:     }>(
 864:         `SELECT invites_sent, messages_sent, challenges_count, selector_failures, run_errors FROM daily_stats WHERE date = ?`,
 865:         [dateString]
 866:     );
 867: 
 868:     return {
 869:         date: dateString,
 870:         invitesSent: row?.invites_sent ?? 0,
 871:         messagesSent: row?.messages_sent ?? 0,
 872:         challengesCount: row?.challenges_count ?? 0,
 873:         selectorFailures: row?.selector_failures ?? 0,
 874:         runErrors: row?.run_errors ?? 0,
 875:     };
 876: }
 877: 
 878: export async function getListDailyStat(
 879:     dateString: string,
 880:     listName: string,
 881:     field: 'invites_sent' | 'messages_sent'
 882: ): Promise<number> {
 883:     const db = await getDatabase();
 884:     const row = await db.get<Record<string, number>>(
 885:         `SELECT ${field} FROM list_daily_stats WHERE date = ? AND list_name = ?`,
 886:         [dateString, listName]
 887:     );
 888:     return row?.[field] ?? 0;
 889: }
 890: 
 891: export async function incrementDailyStat(
 892:     dateString: string,
 893:     field: 'invites_sent' | 'messages_sent' | 'challenges_count' | 'selector_failures' | 'run_errors',
 894:     amount: number = 1
 895: ): Promise<void> {
 896:     const db = await getDatabase();
 897:     await db.run(
 898:         `
 899:         INSERT INTO daily_stats (date, ${field}) VALUES (?, ?)
 900:         ON CONFLICT(date) DO UPDATE SET ${field} = ${field} + ?
 901:     `,
 902:         [dateString, amount, amount]
 903:     );
 904: }
 905: 
 906: export async function incrementListDailyStat(
 907:     dateString: string,
 908:     listName: string,
 909:     field: 'invites_sent' | 'messages_sent',
 910:     amount: number = 1
 911: ): Promise<void> {
 912:     const db = await getDatabase();
 913:     await db.run(
 914:         `
 915:         INSERT INTO list_daily_stats (date, list_name, ${field}) VALUES (?, ?, ?)
 916:         ON CONFLICT(date, list_name) DO UPDATE SET ${field} = ${field} + ?
 917:     `,
 918:         [dateString, listName, amount, amount]
 919:     );
 920: }
 921: 
 922: export async function countWeeklyInvites(weekStartDate: string): Promise<number> {
 923:     const db = await getDatabase();
 924:     const row = await db.get<{ total: number }>(
 925:         `SELECT COALESCE(SUM(invites_sent), 0) as total FROM daily_stats WHERE date >= ?`,
 926:         [weekStartDate]
 927:     );
 928:     return row?.total ?? 0;
 929: }
 930: 
 931: export async function enqueueJob(
 932:     type: JobType,
 933:     payload: Record<string, unknown>,
 934:     idempotencyKey: string,
 935:     priority: number,
 936:     maxAttempts: number,
 937:     initialDelaySeconds: number = 0,
 938:     accountId: string = 'default'
 939: ): Promise<boolean> {
 940:     const db = await getDatabase();
 941:     const safeDelay = Math.max(0, Math.floor(initialDelaySeconds));
 942:     const normalizedAccountId = accountId.trim() || 'default';
 943:     const result = await db.run(
 944:         `
 945:         INSERT OR IGNORE INTO jobs (type, status, account_id, payload_json, idempotency_key, priority, max_attempts, next_run_at)
 946:         VALUES (?, 'QUEUED', ?, ?, ?, ?, ?, DATETIME('now', '+' || ? || ' seconds'))
 947:     `,
 948:         [type, normalizedAccountId, JSON.stringify(payload), idempotencyKey, priority, maxAttempts, safeDelay]
 949:     );
 950:     return (result.changes ?? 0) > 0;
 951: }
 952: 
 953: export async function lockNextQueuedJob(
 954:     allowedTypes: JobType[],
 955:     accountId?: string,
 956:     includeLegacyDefaultQueue: boolean = false
 957: ): Promise<JobRecord | null> {
 958:     if (allowedTypes.length === 0) {
 959:         return null;
 960:     }
 961:     const db = await getDatabase();
 962:     return withTransaction(db, async () => {
 963:         const placeholders = allowedTypes.map(() => '?').join(', ');
 964:         const whereClauses = [
 965:             `status = 'QUEUED'`,
 966:             `next_run_at <= CURRENT_TIMESTAMP`,
 967:             `type IN (${placeholders})`,
 968:         ];
 969:         const params: unknown[] = [...allowedTypes];
 970: 
 971:         const normalizedAccountId = accountId?.trim();
 972:         if (normalizedAccountId) {
 973:             if (includeLegacyDefaultQueue && normalizedAccountId !== 'default') {
 974:                 whereClauses.push(`account_id IN (?, 'default')`);
 975:                 params.push(normalizedAccountId);
 976:             } else {
 977:                 whereClauses.push(`account_id = ?`);
 978:                 params.push(normalizedAccountId);
 979:             }
 980:         }
 981: 
 982:         const job = await db.get<JobRecord>(
 983:             `
 984:             SELECT * FROM jobs
 985:             WHERE ${whereClauses.join('\n              AND ')}
 986:             ORDER BY priority ASC, created_at ASC
 987:             LIMIT 1
 988:         `,
 989:             params
 990:         );
 991: 
 992:         if (!job) return null;
 993: 
 994:         const updateResult = await db.run(
 995:             `
 996:             UPDATE jobs
 997:             SET status = 'RUNNING', locked_at = CURRENT_TIMESTAMP, updated_at = CURRENT_TIMESTAMP
 998:             WHERE id = ? AND status = 'QUEUED'
 999:         `,
1000:             [job.id]
1001:         );
1002:         if ((updateResult.changes ?? 0) === 0) {
1003:             return null;
1004:         }
1005: 
1006:         return {
1007:             ...job,
1008:             status: 'RUNNING',
1009:             payload_json: job.payload_json,
1010:         };
1011:     });
1012: }
1013: 
1014: export async function markJobSucceeded(jobId: number): Promise<void> {
1015:     const db = await getDatabase();
1016:     await db.run(
1017:         `
1018:         UPDATE jobs
1019:         SET status = 'SUCCEEDED', locked_at = NULL, updated_at = CURRENT_TIMESTAMP
1020:         WHERE id = ?
1021:     `,
1022:         [jobId]
1023:     );
1024: }
1025: 
1026: export async function markJobRetryOrDeadLetter(
1027:     jobId: number,
1028:     attempts: number,
1029:     maxAttempts: number,
1030:     nextRetryDelayMs: number,
1031:     errorMessage: string
1032: ): Promise<JobStatus> {
1033:     const db = await getDatabase();
1034:     if (attempts >= maxAttempts) {
1035:         await db.run(
1036:             `
1037:             UPDATE jobs
1038:             SET status = 'DEAD_LETTER',
1039:                 attempts = ?,
1040:                 last_error = ?,
1041:                 locked_at = NULL,
1042:                 updated_at = CURRENT_TIMESTAMP
1043:             WHERE id = ?
1044:         `,
1045:             [attempts, errorMessage, jobId]
1046:         );
1047:         return 'DEAD_LETTER';
1048:     }
1049: 
1050:     const seconds = Math.max(1, Math.ceil(nextRetryDelayMs / 1000));
1051:     await db.run(
1052:         `
1053:         UPDATE jobs
1054:         SET status = 'QUEUED',
1055:             attempts = ?,
1056:             last_error = ?,
1057:             next_run_at = DATETIME('now', '+' || ? || ' seconds'),
1058:             locked_at = NULL,
1059:             updated_at = CURRENT_TIMESTAMP
1060:         WHERE id = ?
1061:     `,
1062:         [attempts, errorMessage, seconds, jobId]
1063:     );
1064:     return 'QUEUED';
1065: }
1066: 
1067: export async function createJobAttempt(
1068:     jobId: number,
1069:     success: boolean,
1070:     errorCode: string | null,
1071:     errorMessage: string | null,
1072:     evidencePath: string | null
1073: ): Promise<void> {
1074:     const db = await getDatabase();
1075:     await db.run(
1076:         `
1077:         INSERT INTO job_attempts (job_id, finished_at, success, error_code, error_message, evidence_path)
1078:         VALUES (?, CURRENT_TIMESTAMP, ?, ?, ?, ?)
1079:     `,
1080:         [jobId, success ? 1 : 0, errorCode, errorMessage, evidencePath]
1081:     );
1082: }
1083: 
1084: export async function createIncident(
1085:     type: string,
1086:     severity: 'INFO' | 'WARN' | 'CRITICAL',
1087:     details: Record<string, unknown>
1088: ): Promise<number> {
1089:     const db = await getDatabase();
1090:     const result = await db.run(
1091:         `
1092:         INSERT INTO account_incidents (type, severity, status, details_json)
1093:         VALUES (?, ?, 'OPEN', ?)
1094:     `,
1095:         [type, severity, JSON.stringify(details)]
1096:     );
1097:     return result.lastID ?? 0;
1098: }
1099: 
1100: export async function listOpenIncidents(): Promise<Array<{ id: number; type: string; severity: string; opened_at: string }>> {
1101:     const db = await getDatabase();
1102:     return db.all(`SELECT id, type, severity, opened_at FROM account_incidents WHERE status = 'OPEN' ORDER BY opened_at DESC`);
1103: }
1104: 
1105: export async function resolveIncident(incidentId: number): Promise<void> {
1106:     const db = await getDatabase();
1107:     await db.run(
1108:         `
1109:         UPDATE account_incidents
1110:         SET status = 'RESOLVED', resolved_at = CURRENT_TIMESTAMP
1111:         WHERE id = ?
1112:     `,
1113:         [incidentId]
1114:     );
1115: }
1116: 
1117: export async function pushOutboxEvent(topic: string, payload: Record<string, unknown>, idempotencyKey: string): Promise<void> {
1118:     const db = await getDatabase();
1119:     await db.run(
1120:         `
1121:         INSERT OR IGNORE INTO outbox_events (topic, payload_json, idempotency_key)
1122:         VALUES (?, ?, ?)
1123:     `,
1124:         [topic, JSON.stringify(payload), idempotencyKey]
1125:     );
1126: }
1127: 
1128: export async function getPendingOutboxEvents(limit: number): Promise<OutboxEventRecord[]> {
1129:     const db = await getDatabase();
1130:     return db.all<OutboxEventRecord[]>(
1131:         `
1132:         SELECT * FROM outbox_events
1133:         WHERE delivered_at IS NULL
1134:           AND next_retry_at <= CURRENT_TIMESTAMP
1135:         ORDER BY created_at ASC
1136:         LIMIT ?
1137:     `,
1138:         [limit]
1139:     );
1140: }
1141: 
1142: export async function markOutboxDelivered(eventId: number): Promise<void> {
1143:     const db = await getDatabase();
1144:     await db.run(
1145:         `
1146:         UPDATE outbox_events
1147:         SET delivered_at = CURRENT_TIMESTAMP,
1148:             last_error = NULL
1149:         WHERE id = ?
1150:     `,
1151:         [eventId]
1152:     );
1153: }
1154: 
1155: export async function markOutboxRetry(eventId: number, attempts: number, retryDelayMs: number, errorMessage: string): Promise<void> {
1156:     const db = await getDatabase();
1157:     const seconds = Math.max(1, Math.ceil(retryDelayMs / 1000));
1158:     await db.run(
1159:         `
1160:         UPDATE outbox_events
1161:         SET attempts = ?,
1162:             next_retry_at = DATETIME('now', '+' || ? || ' seconds'),
1163:             last_error = ?
1164:         WHERE id = ?
1165:     `,
1166:         [attempts, seconds, errorMessage, eventId]
1167:     );
1168: }
1169: 
1170: export async function markOutboxPermanentFailure(eventId: number, attempts: number, errorMessage: string): Promise<void> {
1171:     const db = await getDatabase();
1172:     await db.run(
1173:         `
1174:         UPDATE outbox_events
1175:         SET attempts = ?,
1176:             delivered_at = CURRENT_TIMESTAMP,
1177:             last_error = ?
1178:         WHERE id = ?
1179:     `,
1180:         [attempts, `PERMANENT_FAILURE: ${errorMessage}`, eventId]
1181:     );
1182: }
1183: 
1184: export async function countPendingOutboxEvents(): Promise<number> {
1185:     const db = await getDatabase();
1186:     const row = await db.get<{ total: number }>(`SELECT COUNT(*) as total FROM outbox_events WHERE delivered_at IS NULL`);
1187:     return row?.total ?? 0;
1188: }
1189: 
1190: export async function getJobStatusCounts(): Promise<JobStatusCounts> {
1191:     const db = await getDatabase();
1192:     const rows = await db.all<{ status: JobStatus; total: number }[]>(
1193:         `SELECT status, COUNT(*) as total FROM jobs GROUP BY status`
1194:     );
1195: 
1196:     const counts: JobStatusCounts = {
1197:         QUEUED: 0,
1198:         RUNNING: 0,
1199:         SUCCEEDED: 0,
1200:         FAILED: 0,
1201:         DEAD_LETTER: 0,
1202:         PAUSED: 0,
1203:     };
1204: 
1205:     for (const row of rows) {
1206:         if (row.status in counts) {
1207:             counts[row.status] = row.total;
1208:         }
1209:     }
1210: 
1211:     return counts;
1212: }
1213: 
1214: export async function getRuntimeLock(lockKey: string): Promise<RuntimeLockRecord | null> {
1215:     const db = await getDatabase();
1216:     const row = await db.get<RuntimeLockRecord>(`SELECT * FROM runtime_locks WHERE lock_key = ?`, [lockKey]);
1217:     return row ?? null;
1218: }
1219: 
1220: export async function acquireRuntimeLock(
1221:     lockKey: string,
1222:     ownerId: string,
1223:     ttlSeconds: number,
1224:     metadata: Record<string, unknown> = {}
1225: ): Promise<AcquireRuntimeLockResult> {
1226:     const db = await getDatabase();
1227:     const safeTtl = Math.max(1, ttlSeconds);
1228:     const metadataJson = JSON.stringify(metadata);
1229: 
1230:     return withTransaction(db, async () => {
1231:         const existing = await db.get<RuntimeLockRecord>(
1232:             `SELECT * FROM runtime_locks WHERE lock_key = ?`,
1233:             [lockKey]
1234:         );
1235: 
1236:         if (!existing) {
1237:             await db.run(
1238:                 `
1239:                 INSERT INTO runtime_locks (lock_key, owner_id, metadata_json, expires_at)
1240:                 VALUES (?, ?, ?, DATETIME('now', '+' || ? || ' seconds'))
1241:             `,
1242:                 [lockKey, ownerId, metadataJson, safeTtl]
1243:             );
1244:             const inserted = await db.get<RuntimeLockRecord>(`SELECT * FROM runtime_locks WHERE lock_key = ?`, [lockKey]);
1245:             return {
1246:                 acquired: true,
1247:                 lock: inserted ?? null,
1248:             };
1249:         }
1250: 
1251:         if (existing.owner_id === ownerId) {
1252:             await db.run(
1253:                 `
1254:                 UPDATE runtime_locks
1255:                 SET heartbeat_at = CURRENT_TIMESTAMP,
1256:                     expires_at = DATETIME('now', '+' || ? || ' seconds'),
1257:                     metadata_json = ?,
1258:                     updated_at = CURRENT_TIMESTAMP
1259:                 WHERE lock_key = ?
1260:             `,
1261:                 [safeTtl, metadataJson, lockKey]
1262:             );
1263:             const renewed = await db.get<RuntimeLockRecord>(`SELECT * FROM runtime_locks WHERE lock_key = ?`, [lockKey]);
1264:             return {
1265:                 acquired: true,
1266:                 lock: renewed ?? null,
1267:             };
1268:         }
1269: 
1270:         const isStaleRow = await db.get<{ stale: number }>(
1271:             `
1272:             SELECT CASE WHEN expires_at <= CURRENT_TIMESTAMP THEN 1 ELSE 0 END AS stale
1273:             FROM runtime_locks
1274:             WHERE lock_key = ?
1275:         `,
1276:             [lockKey]
1277:         );
1278: 
1279:         if ((isStaleRow?.stale ?? 0) === 1) {
1280:             await db.run(
1281:                 `
1282:                 UPDATE runtime_locks
1283:                 SET owner_id = ?,
1284:                     acquired_at = CURRENT_TIMESTAMP,
1285:                     heartbeat_at = CURRENT_TIMESTAMP,
1286:                     expires_at = DATETIME('now', '+' || ? || ' seconds'),
1287:                     metadata_json = ?,
1288:                     updated_at = CURRENT_TIMESTAMP
1289:                 WHERE lock_key = ?
1290:             `,
1291:                 [ownerId, safeTtl, metadataJson, lockKey]
1292:             );
1293:             const takenOver = await db.get<RuntimeLockRecord>(`SELECT * FROM runtime_locks WHERE lock_key = ?`, [lockKey]);
1294:             return {
1295:                 acquired: true,
1296:                 lock: takenOver ?? null,
1297:             };
1298:         }
1299: 
1300:         return {
1301:             acquired: false,
1302:             lock: existing,
1303:         };
1304:     });
1305: }
1306: 
1307: export async function heartbeatRuntimeLock(lockKey: string, ownerId: string, ttlSeconds: number): Promise<boolean> {
1308:     const db = await getDatabase();
1309:     const safeTtl = Math.max(1, ttlSeconds);
1310:     const result = await db.run(
1311:         `
1312:         UPDATE runtime_locks
1313:         SET heartbeat_at = CURRENT_TIMESTAMP,
1314:             expires_at = DATETIME('now', '+' || ? || ' seconds'),
1315:             updated_at = CURRENT_TIMESTAMP
1316:         WHERE lock_key = ?
1317:           AND owner_id = ?
1318:     `,
1319:         [safeTtl, lockKey, ownerId]
1320:     );
1321:     return (result.changes ?? 0) > 0;
1322: }
1323: 
1324: export async function releaseRuntimeLock(lockKey: string, ownerId: string): Promise<boolean> {
1325:     const db = await getDatabase();
1326:     const result = await db.run(
1327:         `
1328:         DELETE FROM runtime_locks
1329:         WHERE lock_key = ?
1330:           AND owner_id = ?
1331:     `,
1332:         [lockKey, ownerId]
1333:     );
1334:     return (result.changes ?? 0) > 0;
1335: }
1336: 
1337: export async function setRuntimeFlag(key: string, value: string): Promise<void> {
1338:     const db = await getDatabase();
1339:     await db.run(
1340:         `
1341:         INSERT INTO sync_state (key, value, updated_at) VALUES (?, ?, CURRENT_TIMESTAMP)
1342:         ON CONFLICT(key) DO UPDATE SET value = excluded.value, updated_at = CURRENT_TIMESTAMP
1343:     `,
1344:         [key, value]
1345:     );
1346: }
1347: 
1348: export async function getRuntimeFlag(key: string): Promise<string | null> {
1349:     const db = await getDatabase();
1350:     const row = await db.get<{ value: string }>(`SELECT value FROM sync_state WHERE key = ?`, [key]);
1351:     return row?.value ?? null;
1352: }
1353: 
1354: export async function setAutomationPause(minutes: number | null, reason: string): Promise<string | null> {
1355:     await setRuntimeFlag('automation_paused', 'true');
1356:     await setRuntimeFlag('automation_pause_reason', reason.trim() || 'manual_pause');
1357: 
1358:     if (minutes === null) {
1359:         await setRuntimeFlag('automation_paused_until', '');
1360:         return null;
1361:     }
1362: 
1363:     const safeMinutes = Math.max(1, minutes);
1364:     const until = new Date(Date.now() + safeMinutes * 60_000).toISOString();
1365:     await setRuntimeFlag('automation_paused_until', until);
1366:     return until;
1367: }
1368: 
1369: export async function clearAutomationPause(): Promise<void> {
1370:     await setRuntimeFlag('automation_paused', 'false');
1371:     await setRuntimeFlag('automation_paused_until', '');
1372:     await setRuntimeFlag('automation_pause_reason', '');
1373: }
1374: 
1375: export async function getAutomationPauseState(now: Date = new Date()): Promise<AutomationPauseState> {
1376:     const paused = (await getRuntimeFlag('automation_paused')) === 'true';
1377:     if (!paused) {
1378:         return {
1379:             paused: false,
1380:             pausedUntil: null,
1381:             reason: null,
1382:             remainingSeconds: null,
1383:         };
1384:     }
1385: 
1386:     const reasonRaw = await getRuntimeFlag('automation_pause_reason');
1387:     const untilRaw = await getRuntimeFlag('automation_paused_until');
1388:     const parsedUntil = untilRaw && Number.isFinite(Date.parse(untilRaw))
1389:         ? new Date(untilRaw).toISOString()
1390:         : null;
1391: 
1392:     if (parsedUntil && Date.parse(parsedUntil) <= now.getTime()) {
1393:         await clearAutomationPause();
1394:         return {
1395:             paused: false,
1396:             pausedUntil: null,
1397:             reason: null,
1398:             remainingSeconds: null,
1399:         };
1400:     }
1401: 
1402:     const remainingSeconds = parsedUntil
1403:         ? Math.max(0, Math.ceil((Date.parse(parsedUntil) - now.getTime()) / 1000))
1404:         : null;
1405: 
1406:     return {
1407:         paused: true,
1408:         pausedUntil: parsedUntil,
1409:         reason: reasonRaw && reasonRaw.trim() ? reasonRaw : null,
1410:         remainingSeconds,
1411:     };
1412: }
1413: 
1414: export async function recordRunLog(level: 'INFO' | 'WARN' | 'ERROR', event: string, payload: Record<string, unknown>): Promise<void> {
1415:     const db = await getDatabase();
1416:     await db.run(
1417:         `
1418:         INSERT INTO run_logs (level, event, payload_json)
1419:         VALUES (?, ?, ?)
1420:     `,
1421:         [level, event, JSON.stringify(payload)]
1422:     );
1423: }
1424: 
1425: export async function getLastRunLogs(limit: number): Promise<Array<{ level: string; event: string; payload_json: string; created_at: string }>> {
1426:     const db = await getDatabase();
1427:     return db.all(
1428:         `SELECT level, event, payload_json, created_at FROM run_logs ORDER BY created_at DESC LIMIT ?`,
1429:         [limit]
1430:     );
1431: }
1432: 
1433: export async function cleanupPrivacyData(retentionDays: number): Promise<PrivacyCleanupStats> {
1434:     const db = await getDatabase();
1435:     const safeDays = Math.max(7, retentionDays);
1436:     const daysParam = String(safeDays);
1437: 
1438:     const runLogs = await db.run(
1439:         `DELETE FROM run_logs WHERE created_at < DATETIME('now', '-' || ? || ' days')`,
1440:         [daysParam]
1441:     );
1442:     const jobAttempts = await db.run(
1443:         `DELETE FROM job_attempts WHERE started_at < DATETIME('now', '-' || ? || ' days')`,
1444:         [daysParam]
1445:     );
1446:     const leadEvents = await db.run(
1447:         `DELETE FROM lead_events WHERE created_at < DATETIME('now', '-' || ? || ' days')`,
1448:         [daysParam]
1449:     );
1450:     const messageHistory = await db.run(
1451:         `DELETE FROM message_history WHERE sent_at < DATETIME('now', '-' || ? || ' days')`,
1452:         [daysParam]
1453:     );
1454:     const deliveredOutboxEvents = await db.run(
1455:         `DELETE FROM outbox_events
1456:          WHERE delivered_at IS NOT NULL
1457:            AND created_at < DATETIME('now', '-' || ? || ' days')`,
1458:         [daysParam]
1459:     );
1460:     const resolvedIncidents = await db.run(
1461:         `DELETE FROM account_incidents
1462:          WHERE status = 'RESOLVED'
1463:            AND resolved_at < DATETIME('now', '-' || ? || ' days')`,
1464:         [daysParam]
1465:     );
1466: 
1467:     return {
1468:         runLogs: runLogs.changes ?? 0,
1469:         jobAttempts: jobAttempts.changes ?? 0,
1470:         leadEvents: leadEvents.changes ?? 0,
1471:         messageHistory: messageHistory.changes ?? 0,
1472:         deliveredOutboxEvents: deliveredOutboxEvents.changes ?? 0,
1473:         resolvedIncidents: resolvedIncidents.changes ?? 0,
1474:     };
1475: }
1476: 
1477: export async function storeMessageHash(leadId: number, contentHash: string): Promise<void> {
1478:     const db = await getDatabase();
1479:     await db.run(
1480:         `
1481:         INSERT INTO message_history (lead_id, content_hash)
1482:         VALUES (?, ?)
1483:     `,
1484:         [leadId, contentHash]
1485:     );
1486: }
1487: 
1488: export async function countRecentMessageHash(contentHash: string, hoursWindow: number): Promise<number> {
1489:     const db = await getDatabase();
1490:     const row = await db.get<{ total: number }>(
1491:         `
1492:         SELECT COUNT(*) as total
1493:         FROM message_history
1494:         WHERE content_hash = ?
1495:           AND sent_at >= DATETIME('now', '-' || ? || ' hours')
1496:     `,
1497:         [contentHash, hoursWindow]
1498:     );
1499:     return row?.total ?? 0;
1500: }
1501: 
1502: export async function getRiskInputs(localDate: string, hardInviteCap: number): Promise<RiskInputs> {
1503:     const db = await getDatabase();
1504:     const pendingInvites = await countLeadsByStatuses(['INVITED']);
1505:     const invitedTotalRow = await db.get<{ total: number }>(
1506:         `SELECT COUNT(*) as total FROM leads WHERE invited_at IS NOT NULL`
1507:     );
1508:     const invitedTotal = invitedTotalRow?.total ?? 0;
1509:     const pendingRatio = invitedTotal > 0 ? pendingInvites / invitedTotal : 0;
1510: 
1511:     const attemptsRow = await db.get<{ total: number }>(
1512:         `
1513:         SELECT COUNT(*) as total
1514:         FROM job_attempts
1515:         WHERE started_at >= DATETIME('now', '-24 hours')
1516:     `
1517:     );
1518:     const failedRow = await db.get<{ total: number }>(
1519:         `
1520:         SELECT COUNT(*) as total
1521:         FROM job_attempts
1522:         WHERE started_at >= DATETIME('now', '-24 hours')
1523:           AND success = 0
1524:     `
1525:     );
1526:     const totalAttempts = attemptsRow?.total ?? 0;
1527:     const failedAttempts = failedRow?.total ?? 0;
1528:     const errorRate = totalAttempts > 0 ? failedAttempts / totalAttempts : 0;
1529: 
1530:     const selectorFailures = await getDailyStat(localDate, 'selector_failures');
1531:     const denominator = Math.max(1, totalAttempts);
1532:     const selectorFailureRate = selectorFailures / denominator;
1533: 
1534:     const challengeCount = await getDailyStat(localDate, 'challenges_count');
1535:     const invitesSent = await getDailyStat(localDate, 'invites_sent');
1536:     const inviteVelocityRatio = hardInviteCap > 0 ? invitesSent / hardInviteCap : 0;
1537: 
1538:     return {
1539:         pendingRatio,
1540:         errorRate,
1541:         selectorFailureRate,
1542:         challengeCount,
1543:         inviteVelocityRatio,
1544:     };
1545: }
1546: 
1547: export interface JobWithPayload<T extends Record<string, unknown>> extends JobRecord {
1548:     payload: T;
1549: }
1550: 
1551: export function parseJobPayload<T extends Record<string, unknown>>(job: JobRecord): JobWithPayload<T> {
1552:     return {
1553:         ...job,
1554:         payload: parsePayload<T>(job.payload_json),
1555:     };
1556: }
1557: 
1558: 
1559: /**
1560:  * Al boot, resetta i job RUNNING bloccati da troppo tempo.
1561:  * Un job resta RUNNING se il processo viene killato durante l'esecuzione.
1562:  */
1563: export async function recoverStuckJobs(staleAfterMinutes: number = 30): Promise<number> {
1564:     const db = await getDatabase();
1565:     const result = await db.run(
1566:         `UPDATE jobs
1567:          SET status = 'QUEUED',
1568:              locked_at = NULL,
1569:              updated_at = CURRENT_TIMESTAMP,
1570:              last_error = 'Recovered from RUNNING on startup'
1571:          WHERE status = 'RUNNING'
1572:            AND (
1573:              locked_at IS NULL
1574:              OR locked_at <= DATETIME('now', '-' || ? || ' minutes')
1575:            )`,
1576:         [Math.max(1, staleAfterMinutes)]
1577:     );
1578:     return result.changes ?? 0;
1579: }
````

## File: src/core/scheduler.ts
````typescript
  1: import { config, getLocalDateString, getWeekStartDate } from '../config';
  2: import { pickAccountIdForLead } from '../accountManager';
  3: import { evaluateRisk, calculateDynamicBudget } from '../risk/riskEngine';
  4: import { JobType, RiskSnapshot } from '../types/domain';
  5: import {
  6:     countWeeklyInvites,
  7:     ensureLeadList,
  8:     enqueueJob,
  9:     getDailyStat,
 10:     getLeadStatusCountsForLists,
 11:     getLeadsByStatusForList,
 12:     getListDailyStat,
 13:     getRiskInputs,
 14:     listLeadCampaignConfigs,
 15:     promoteNewLeadsToReadyInvite,
 16:     syncLeadListsFromLeads,
 17: } from './repositories';
 18: import { transitionLead } from './leadStateService';
 19: 
 20: export type WorkflowSelection = 'invite' | 'check' | 'message' | 'all';
 21: 
 22: export interface ScheduleResult {
 23:     localDate: string;
 24:     riskSnapshot: RiskSnapshot;
 25:     inviteBudget: number;
 26:     messageBudget: number;
 27:     queuedInviteJobs: number;
 28:     queuedCheckJobs: number;
 29:     queuedMessageJobs: number;
 30:     listBreakdown: ListScheduleBreakdown[];
 31:     dryRun: boolean;
 32: }
 33: 
 34: export interface ScheduleOptions {
 35:     dryRun?: boolean;
 36: }
 37: 
 38: export interface ListScheduleBreakdown {
 39:     listName: string;
 40:     inviteBudget: number;
 41:     messageBudget: number;
 42:     queuedInviteJobs: number;
 43:     queuedCheckJobs: number;
 44:     queuedMessageJobs: number;
 45:     adaptiveFactor: number;
 46:     adaptiveReasons: string[];
 47:     pendingRatio: number;
 48:     blockedRatio: number;
 49:     maxScheduledDelaySec: number;
 50: }
 51: 
 52: export function workflowToJobTypes(workflow: WorkflowSelection): JobType[] {
 53:     if (workflow === 'all') return ['INVITE', 'ACCEPTANCE_CHECK', 'MESSAGE'];
 54:     if (workflow === 'invite') return ['INVITE'];
 55:     if (workflow === 'check') return ['ACCEPTANCE_CHECK'];
 56:     return ['MESSAGE'];
 57: }
 58: 
 59: function buildInviteKey(leadId: number, localDate: string): string {
 60:     return `invite:${leadId}:${localDate}`;
 61: }
 62: 
 63: function buildMessageKey(leadId: number, acceptedAtDate: string): string {
 64:     return `message:${leadId}:${acceptedAtDate}`;
 65: }
 66: 
 67: function buildCheckKey(leadId: number, localDate: string): string {
 68:     return `check:${leadId}:${localDate}`;
 69: }
 70: 
 71: function computeListBudget(globalRemaining: number, listCap: number | null, alreadyConsumed: number): number {
 72:     const listRemaining = listCap === null
 73:         ? globalRemaining
 74:         : Math.max(0, listCap - alreadyConsumed);
 75:     return Math.max(0, Math.min(globalRemaining, listRemaining));
 76: }
 77: 
 78: interface AdaptiveBudgetContext {
 79:     factor: number;
 80:     reasons: string[];
 81:     pendingRatio: number;
 82:     blockedRatio: number;
 83: }
 84: 
 85: interface NoBurstPlanner {
 86:     nextDelaySec: () => number;
 87: }
 88: 
 89: function toNonNegativeInt(value: number): number {
 90:     return Math.max(0, Math.floor(value));
 91: }
 92: 
 93: function clamp01(value: number): number {
 94:     return Math.min(1, Math.max(0, value));
 95: }
 96: 
 97: function pickRandomInt(min: number, max: number): number {
 98:     const low = Math.min(min, max);
 99:     const high = Math.max(min, max);
100:     if (high <= low) return low;
101:     return Math.floor(Math.random() * (high - low + 1)) + low;
102: }
103: 
104: function applyAdaptiveFactor(rawBudget: number, factor: number): number {
105:     if (rawBudget <= 0 || factor <= 0) {
106:         return 0;
107:     }
108:     const computed = Math.floor(rawBudget * factor);
109:     if (computed <= 0) {
110:         return 1;
111:     }
112:     return Math.min(rawBudget, computed);
113: }
114: 
115: function evaluateAdaptiveBudgetContext(
116:     statusCounts: Record<string, number>,
117:     riskAction: RiskSnapshot['action']
118: ): AdaptiveBudgetContext {
119:     if (!config.adaptiveCapsEnabled) {
120:         return {
121:             factor: riskAction === 'STOP' ? 0 : 1,
122:             reasons: riskAction === 'STOP' ? ['global_risk_stop'] : [],
123:             pendingRatio: 0,
124:             blockedRatio: 0,
125:         };
126:     }
127: 
128:     const invited = statusCounts.INVITED ?? 0;
129:     const acceptedLike = (statusCounts.ACCEPTED ?? 0) + (statusCounts.READY_MESSAGE ?? 0) + (statusCounts.MESSAGED ?? 0);
130:     const blockedSkipped = (statusCounts.BLOCKED ?? 0) + (statusCounts.SKIPPED ?? 0);
131: 
132:     const pendingRatioDenominator = Math.max(1, invited + acceptedLike);
133:     const pendingRatio = invited / pendingRatioDenominator;
134: 
135:     const blockedRatioDenominator = Math.max(1, invited + acceptedLike + blockedSkipped);
136:     const blockedRatio = blockedSkipped / blockedRatioDenominator;
137: 
138:     let factor = 1;
139:     const reasons: string[] = [];
140: 
141:     if (riskAction === 'STOP') {
142:         factor = 0;
143:         reasons.push('global_risk_stop');
144:     } else if (riskAction === 'WARN') {
145:         factor = Math.min(factor, clamp01(config.adaptiveCapsWarnFactor));
146:         reasons.push('global_risk_warn');
147:     }
148: 
149:     if (pendingRatio >= config.adaptiveCapsPendingStop) {
150:         factor = Math.min(factor, clamp01(config.adaptiveCapsMinFactor));
151:         reasons.push('list_pending_high');
152:     } else if (pendingRatio >= config.adaptiveCapsPendingWarn) {
153:         factor = Math.min(factor, 0.5);
154:         reasons.push('list_pending_warn');
155:     }
156: 
157:     if (blockedRatio >= config.adaptiveCapsBlockedWarn) {
158:         factor = Math.min(factor, 0.6);
159:         reasons.push('list_blocked_warn');
160:     }
161: 
162:     return {
163:         factor: clamp01(factor),
164:         reasons,
165:         pendingRatio: Number.parseFloat(pendingRatio.toFixed(4)),
166:         blockedRatio: Number.parseFloat(blockedRatio.toFixed(4)),
167:     };
168: }
169: 
170: function createNoBurstPlanner(): NoBurstPlanner {
171:     const minDelay = toNonNegativeInt(config.noBurstMinDelaySec);
172:     const maxDelay = toNonNegativeInt(config.noBurstMaxDelaySec);
173:     const longBreakEvery = toNonNegativeInt(config.noBurstLongBreakEvery);
174:     const longBreakMin = toNonNegativeInt(config.noBurstLongBreakMinSec);
175:     const longBreakMax = toNonNegativeInt(config.noBurstLongBreakMaxSec);
176: 
177:     let totalDelaySec = 0;
178:     let queuedJobs = 0;
179: 
180:     return {
181:         nextDelaySec: () => {
182:             queuedJobs += 1;
183:             totalDelaySec += pickRandomInt(minDelay, maxDelay);
184: 
185:             if (longBreakEvery > 0 && queuedJobs % longBreakEvery === 0) {
186:                 totalDelaySec += pickRandomInt(longBreakMin, longBreakMax);
187:             }
188: 
189:             return totalDelaySec;
190:         },
191:     };
192: }
193: 
194: async function resolveActiveLists(): Promise<string[]> {
195:     await syncLeadListsFromLeads();
196:     let lists = await listLeadCampaignConfigs(true);
197:     if (lists.length === 0) {
198:         await ensureLeadList('default');
199:         lists = await listLeadCampaignConfigs(true);
200:     }
201:     return lists.map((list) => list.name);
202: }
203: 
204: function initListBreakdown(listNames: string[]): Map<string, ListScheduleBreakdown> {
205:     const map = new Map<string, ListScheduleBreakdown>();
206:     for (const listName of listNames) {
207:         map.set(listName, {
208:             listName,
209:             inviteBudget: 0,
210:             messageBudget: 0,
211:             queuedInviteJobs: 0,
212:             queuedCheckJobs: 0,
213:             queuedMessageJobs: 0,
214:             adaptiveFactor: 1,
215:             adaptiveReasons: [],
216:             pendingRatio: 0,
217:             blockedRatio: 0,
218:             maxScheduledDelaySec: 0,
219:         });
220:     }
221:     return map;
222: }
223: 
224: export async function scheduleJobs(workflow: WorkflowSelection, options: ScheduleOptions = {}): Promise<ScheduleResult> {
225:     const dryRun = options.dryRun ?? false;
226:     const localDate = getLocalDateString();
227:     const riskInputs = await getRiskInputs(localDate, config.hardInviteCap);
228:     const riskSnapshot = evaluateRisk(riskInputs);
229: 
230:     const dailyInvitesSent = await getDailyStat(localDate, 'invites_sent');
231:     const dailyMessagesSent = await getDailyStat(localDate, 'messages_sent');
232:     const weekStartDate = getWeekStartDate();
233:     const weeklyInvitesSent = await countWeeklyInvites(weekStartDate);
234:     const weeklyRemaining = Math.max(0, config.weeklyInviteLimit - weeklyInvitesSent);
235: 
236:     const inviteBudget = Math.min(
237:         calculateDynamicBudget(config.softInviteCap, config.hardInviteCap, dailyInvitesSent, riskSnapshot.action),
238:         weeklyRemaining
239:     );
240:     const messageBudget = calculateDynamicBudget(config.softMsgCap, config.hardMsgCap, dailyMessagesSent, riskSnapshot.action);
241: 
242:     let queuedInviteJobs = 0;
243:     let queuedCheckJobs = 0;
244:     let queuedMessageJobs = 0;
245:     await syncLeadListsFromLeads();
246:     let listConfigs = await listLeadCampaignConfigs(true);
247:     if (listConfigs.length === 0) {
248:         await ensureLeadList('default');
249:         listConfigs = await listLeadCampaignConfigs(true);
250:     }
251:     const activeListNames = listConfigs.length > 0
252:         ? listConfigs.map((list) => list.name)
253:         : await resolveActiveLists();
254:     const listBreakdown = initListBreakdown(activeListNames);
255:     const listConfigMap = new Map(listConfigs.map((list) => [list.name, list]));
256:     const statusRows = await getLeadStatusCountsForLists(activeListNames);
257:     const listStatusCounts = new Map<string, Record<string, number>>();
258:     for (const row of statusRows) {
259:         const statusName = row.status === 'PENDING' ? 'READY_INVITE' : row.status;
260:         if (!listStatusCounts.has(row.list_name)) {
261:             listStatusCounts.set(row.list_name, {});
262:         }
263:         const target = listStatusCounts.get(row.list_name);
264:         if (!target) continue;
265:         target[statusName] = (target[statusName] ?? 0) + row.total;
266:     }
267:     const adaptiveContextMap = new Map<string, AdaptiveBudgetContext>();
268:     for (const listName of activeListNames) {
269:         const statusCounts = listStatusCounts.get(listName) ?? {};
270:         const context = evaluateAdaptiveBudgetContext(statusCounts, riskSnapshot.action);
271:         adaptiveContextMap.set(listName, context);
272:         const breakdown = listBreakdown.get(listName);
273:         if (breakdown) {
274:             breakdown.adaptiveFactor = context.factor;
275:             breakdown.adaptiveReasons = context.reasons;
276:             breakdown.pendingRatio = context.pendingRatio;
277:             breakdown.blockedRatio = context.blockedRatio;
278:         }
279:     }
280:     const noBurstPlanner = !dryRun && config.noBurstEnabled ? createNoBurstPlanner() : null;
281: 
282:     if (!dryRun && riskSnapshot.action !== 'STOP') {
283:         await promoteNewLeadsToReadyInvite(config.hardInviteCap * 4);
284:     }
285: 
286:     if (workflow === 'all' || workflow === 'invite') {
287:         let remainingInviteBudget = inviteBudget;
288:         for (const listName of activeListNames) {
289:             if (remainingInviteBudget <= 0) break;
290:             const breakdown = listBreakdown.get(listName);
291:             if (!breakdown) continue;
292: 
293:             const listConfig = listConfigMap.get(listName);
294:             const listInvitesSent = await getListDailyStat(localDate, listName, 'invites_sent');
295:             const rawListBudget = computeListBudget(remainingInviteBudget, listConfig?.dailyInviteCap ?? null, listInvitesSent);
296:             const adaptive = adaptiveContextMap.get(listName);
297:             const listBudget = applyAdaptiveFactor(rawListBudget, adaptive?.factor ?? 1);
298:             breakdown.inviteBudget = listBudget;
299:             if (listBudget <= 0) continue;
300: 
301:             if (dryRun) {
302:                 const readyCandidates = await getLeadsByStatusForList('READY_INVITE', listName, listBudget);
303:                 const newCandidates = await getLeadsByStatusForList('NEW', listName, listBudget);
304:                 const candidateIds = new Set<number>();
305:                 for (const lead of readyCandidates) candidateIds.add(lead.id);
306:                 for (const lead of newCandidates) candidateIds.add(lead.id);
307:                 const planned = Math.min(listBudget, candidateIds.size);
308:                 breakdown.queuedInviteJobs += planned;
309:                 queuedInviteJobs += planned;
310:                 remainingInviteBudget -= planned;
311:                 continue;
312:             }
313: 
314:             const inviteCandidates = await getLeadsByStatusForList('READY_INVITE', listName, listBudget);
315: 
316:             let insertedForList = 0;
317:             for (const lead of inviteCandidates) {
318:                 const initialDelaySec = noBurstPlanner ? noBurstPlanner.nextDelaySec() : 0;
319:                 const accountId = pickAccountIdForLead(lead.id);
320:                 const inserted = await enqueueJob(
321:                     'INVITE',
322:                     { leadId: lead.id, localDate },
323:                     buildInviteKey(lead.id, localDate),
324:                     10,
325:                     config.retryMaxAttempts,
326:                     initialDelaySec,
327:                     accountId
328:                 );
329:                 if (inserted) {
330:                     insertedForList += 1;
331:                     queuedInviteJobs += 1;
332:                     breakdown.maxScheduledDelaySec = Math.max(breakdown.maxScheduledDelaySec, initialDelaySec);
333:                 }
334:             }
335:             breakdown.queuedInviteJobs += insertedForList;
336:             remainingInviteBudget -= insertedForList;
337:         }
338:     }
339: 
340:     if (workflow === 'all' || workflow === 'check') {
341:         const checkLimitPerList = Math.max(25, config.hardInviteCap * 3);
342:         for (const listName of activeListNames) {
343:             const breakdown = listBreakdown.get(listName);
344:             if (!breakdown) continue;
345:             const invitedLeads = await getLeadsByStatusForList('INVITED', listName, checkLimitPerList);
346:             if (dryRun) {
347:                 breakdown.queuedCheckJobs += invitedLeads.length;
348:                 queuedCheckJobs += invitedLeads.length;
349:                 continue;
350:             }
351: 
352:             let insertedForList = 0;
353:             for (const lead of invitedLeads) {
354:                 const initialDelaySec = noBurstPlanner ? noBurstPlanner.nextDelaySec() : 0;
355:                 const accountId = pickAccountIdForLead(lead.id);
356:                 const inserted = await enqueueJob(
357:                     'ACCEPTANCE_CHECK',
358:                     { leadId: lead.id },
359:                     buildCheckKey(lead.id, localDate),
360:                     30,
361:                     config.retryMaxAttempts,
362:                     initialDelaySec,
363:                     accountId
364:                 );
365:                 if (inserted) {
366:                     insertedForList += 1;
367:                     queuedCheckJobs += 1;
368:                     breakdown.maxScheduledDelaySec = Math.max(breakdown.maxScheduledDelaySec, initialDelaySec);
369:                 }
370:             }
371:             breakdown.queuedCheckJobs += insertedForList;
372:         }
373:     }
374: 
375:     if (workflow === 'all' || workflow === 'message') {
376:         let remainingMessageBudget = messageBudget;
377:         for (const listName of activeListNames) {
378:             if (remainingMessageBudget <= 0) break;
379:             const breakdown = listBreakdown.get(listName);
380:             if (!breakdown) continue;
381: 
382:             const listConfig = listConfigMap.get(listName);
383:             const listMessagesSent = await getListDailyStat(localDate, listName, 'messages_sent');
384:             const rawListBudget = computeListBudget(remainingMessageBudget, listConfig?.dailyMessageCap ?? null, listMessagesSent);
385:             const adaptive = adaptiveContextMap.get(listName);
386:             const listBudget = applyAdaptiveFactor(rawListBudget, adaptive?.factor ?? 1);
387:             breakdown.messageBudget = listBudget;
388:             if (listBudget <= 0) continue;
389: 
390:             if (dryRun) {
391:                 const accepted = await getLeadsByStatusForList('ACCEPTED', listName, listBudget);
392:                 const readyToMessage = await getLeadsByStatusForList('READY_MESSAGE', listName, listBudget);
393:                 const uniqueLeadIds = new Set<number>();
394:                 for (const lead of accepted) uniqueLeadIds.add(lead.id);
395:                 for (const lead of readyToMessage) uniqueLeadIds.add(lead.id);
396:                 const planned = Math.min(listBudget, uniqueLeadIds.size);
397:                 breakdown.queuedMessageJobs += planned;
398:                 queuedMessageJobs += planned;
399:                 remainingMessageBudget -= planned;
400:                 continue;
401:             }
402: 
403:             const accepted = await getLeadsByStatusForList('ACCEPTED', listName, Math.max(50, listBudget));
404:             for (const lead of accepted) {
405:                 await transitionLead(lead.id, 'READY_MESSAGE', 'scheduler_promote_to_ready_message');
406:             }
407:             const readyToMessage = await getLeadsByStatusForList('READY_MESSAGE', listName, listBudget);
408: 
409:             let insertedForList = 0;
410:             for (const lead of readyToMessage) {
411:                 const acceptedAtDate = lead.accepted_at ? lead.accepted_at.slice(0, 10) : localDate;
412:                 const minDelayHours = Math.max(0, config.messageScheduleMinDelayHours);
413:                 const maxDelayHours = Math.max(minDelayHours, config.messageScheduleMaxDelayHours);
414:                 let acceptanceDelaySec = 0;
415:                 if (maxDelayHours > 0) {
416:                     const targetDelaySec = pickRandomInt(minDelayHours * 3600, maxDelayHours * 3600);
417:                     const acceptedAtMs = lead.accepted_at ? Date.parse(lead.accepted_at) : NaN;
418:                     const elapsedSec = Number.isFinite(acceptedAtMs)
419:                         ? Math.max(0, Math.floor((Date.now() - acceptedAtMs) / 1000))
420:                         : 0;
421:                     acceptanceDelaySec = Math.max(0, targetDelaySec - elapsedSec);
422:                 }
423: 
424:                 const noBurstDelaySec = noBurstPlanner ? noBurstPlanner.nextDelaySec() : 0;
425:                 const initialDelaySec = acceptanceDelaySec + noBurstDelaySec;
426:                 const accountId = pickAccountIdForLead(lead.id);
427:                 const inserted = await enqueueJob(
428:                     'MESSAGE',
429:                     { leadId: lead.id, acceptedAtDate },
430:                     buildMessageKey(lead.id, acceptedAtDate),
431:                     20,
432:                     config.retryMaxAttempts,
433:                     initialDelaySec,
434:                     accountId
435:                 );
436:                 if (inserted) {
437:                     insertedForList += 1;
438:                     queuedMessageJobs += 1;
439:                     breakdown.maxScheduledDelaySec = Math.max(breakdown.maxScheduledDelaySec, initialDelaySec);
440:                 }
441:             }
442:             breakdown.queuedMessageJobs += insertedForList;
443:             remainingMessageBudget -= insertedForList;
444:         }
445:     }
446: 
447:     return {
448:         localDate,
449:         riskSnapshot,
450:         inviteBudget,
451:         messageBudget,
452:         queuedInviteJobs,
453:         queuedCheckJobs,
454:         queuedMessageJobs,
455:         listBreakdown: Array.from(listBreakdown.values()),
456:         dryRun,
457:     };
458: }
````

## File: src/index.ts
````typescript
   1: import { closeDatabase, initDatabase } from './db';
   2: import { config, getLocalDateString } from './config';
   3: import { checkLogin, closeBrowser as closeBrowserSession, detectChallenge, humanDelay, isLoggedIn, launchBrowser } from './browser';
   4: import { randomUUID } from 'crypto';
   5: import { importLeadsFromCSV } from './csvImporter';
   6: import { buildFunnelReport, runSiteCheck } from './core/audit';
   7: import { runCompanyEnrichmentBatch } from './core/companyEnrichment';
   8: import { runWorkflow } from './core/orchestrator';
   9: import { runDoctor } from './core/doctor';
  10: import { runSalesNavigatorListSync } from './core/salesNavigatorSync';
  11: import { reconcileLeadStatus } from './core/leadStateService';
  12: import {
  13:     acquireRuntimeLock,
  14:     cleanupPrivacyData,
  15:     countCompanyTargets,
  16:     getAutomationPauseState,
  17:     getDailyStatsSnapshot,
  18:     getLeadById,
  19:     getJobStatusCounts,
  20:     getSalesNavListByName,
  21:     getRuntimeLock,
  22:     getRuntimeFlag,
  23:     getLeadsWithSalesNavigatorUrls,
  24:     heartbeatRuntimeLock,
  25:     linkLeadToSalesNavList,
  26:     listCompanyTargets,
  27:     listLeadCampaignConfigs,
  28:     listOpenIncidents,
  29:     listSalesNavLists,
  30:     releaseRuntimeLock,
  31:     recoverStuckJobs,
  32:     resolveIncident,
  33:     clearAutomationPause as clearPauseState,
  34:     setAutomationPause,
  35:     setRuntimeFlag,
  36:     upsertSalesNavList,
  37:     updateLeadLinkedinUrl,
  38:     updateLeadCampaignConfig,
  39: } from './core/repositories';
  40: import { setQuarantine } from './risk/incidentManager';
  41: import { getEventSyncStatus, runEventSyncOnce } from './sync/eventSync';
  42: import { WorkflowSelection } from './core/scheduler';
  43: import { isProfileUrl, isSalesNavigatorUrl, normalizeLinkedInUrl } from './linkedinUrl';
  44: import { Page } from 'playwright';
  45: import { getAccountProfileById, getRuntimeAccountProfiles } from './accountManager';
  46: import { getProxyFailoverChain, getProxyPoolStatus } from './proxyManager';
  47: import { runRandomLinkedinActivity } from './workers/randomActivityWorker';
  48: import { addLeadToSalesNavList, createSalesNavList } from './salesnav/listActions';
  49: 
  50: // Graceful shutdown: chiude DB prima di uscire per non lasciare job RUNNING.
  51: let shuttingDown = false;
  52: function setupGracefulShutdown(): void {
  53:     const handler = async (signal: string): Promise<void> => {
  54:         if (shuttingDown) return;
  55:         shuttingDown = true;
  56:         console.warn(`[SIGNAL] ${signal} ricevuto — chiusura in corso...`);
  57:         await closeDatabase();
  58:         process.exit(0);
  59:     };
  60:     process.on('SIGINT', () => { void handler('SIGINT'); });
  61:     process.on('SIGTERM', () => { void handler('SIGTERM'); });
  62: }
  63: 
  64: function getOptionValue(args: string[], optionName: string): string | undefined {
  65:     const index = args.findIndex((value) => value === optionName);
  66:     if (index === -1 || index + 1 >= args.length) {
  67:         return undefined;
  68:     }
  69:     return args[index + 1];
  70: }
  71: 
  72: function hasOption(args: string[], optionName: string): boolean {
  73:     return args.includes(optionName);
  74: }
  75: 
  76: function parseWorkflow(input: string | undefined): WorkflowSelection {
  77:     if (input === 'invite' || input === 'check' || input === 'message' || input === 'all') {
  78:         return input;
  79:     }
  80:     return 'all';
  81: }
  82: 
  83: function parseIntStrict(raw: string, optionName: string): number {
  84:     const parsed = Number.parseInt(raw, 10);
  85:     if (!Number.isFinite(parsed)) {
  86:         throw new Error(`Valore non valido per ${optionName}: ${raw}`);
  87:     }
  88:     return parsed;
  89: }
  90: 
  91: function parseNullableCap(raw: string, optionName: string): number | null {
  92:     const normalized = raw.trim().toLowerCase();
  93:     if (normalized === 'none' || normalized === 'null' || normalized === 'off' || normalized === '-1') {
  94:         return null;
  95:     }
  96:     const parsed = parseIntStrict(raw, optionName);
  97:     if (parsed < 0) {
  98:         throw new Error(`${optionName} deve essere >= 0 oppure none/null/off.`);
  99:     }
 100:     return parsed;
 101: }
 102: 
 103: function parsePauseMinutes(raw: string, optionName: string): number | null {
 104:     const normalized = raw.trim().toLowerCase();
 105:     if (normalized === 'none' || normalized === 'null' || normalized === 'off' || normalized === 'indefinite') {
 106:         return null;
 107:     }
 108:     const parsed = parseIntStrict(raw, optionName);
 109:     if (parsed < 1) {
 110:         throw new Error(`${optionName} deve essere >= 1 oppure none/null/off/indefinite.`);
 111:     }
 112:     return parsed;
 113: }
 114: 
 115: function parseBoolStrict(raw: string, optionName: string): boolean {
 116:     const normalized = raw.trim().toLowerCase();
 117:     if (normalized === 'true' || normalized === '1' || normalized === 'yes') return true;
 118:     if (normalized === 'false' || normalized === '0' || normalized === 'no') return false;
 119:     throw new Error(`Valore non valido per ${optionName}: ${raw} (usa true/false).`);
 120: }
 121: 
 122: function getWorkflowValue(args: string[]): string | undefined {
 123:     const explicit = getOptionValue(args, '--workflow');
 124:     if (explicit) {
 125:         return explicit;
 126:     }
 127:     const positional = args.find((value) => !value.startsWith('--'));
 128:     return positional;
 129: }
 130: 
 131: function getPositionalArgs(args: string[]): string[] {
 132:     return args.filter((value) => !value.startsWith('--'));
 133: }
 134: 
 135: function sleep(ms: number): Promise<void> {
 136:     return new Promise((resolve) => setTimeout(resolve, ms));
 137: }
 138: 
 139: interface SalesNavResolveItem {
 140:     leadId: number;
 141:     status: string;
 142:     currentUrl: string;
 143:     resolvedProfileUrl: string | null;
 144:     action: 'resolved' | 'updated' | 'conflict' | 'unresolved' | 'challenge_detected' | 'error';
 145:     conflictLeadId?: number | null;
 146:     error?: string;
 147: }
 148: 
 149: interface SalesNavResolveReport {
 150:     scanned: number;
 151:     resolvable: number;
 152:     updated: number;
 153:     conflicts: number;
 154:     unresolved: number;
 155:     challengeDetected: boolean;
 156:     fix: boolean;
 157:     dryRun: boolean;
 158:     items: SalesNavResolveItem[];
 159: }
 160: 
 161: async function collectProfileUrlCandidates(page: Page): Promise<string[]> {
 162:     const candidates = new Set<string>();
 163: 
 164:     const currentUrl = page.url();
 165:     if (currentUrl) candidates.add(currentUrl);
 166: 
 167:     const canonicalHref = await page.locator('link[rel="canonical"]').first().getAttribute('href').catch(() => null);
 168:     if (canonicalHref) candidates.add(canonicalHref);
 169: 
 170:     const ogUrl = await page.locator('meta[property="og:url"]').first().getAttribute('content').catch(() => null);
 171:     if (ogUrl) candidates.add(ogUrl);
 172: 
 173:     const anchors = await page.evaluate(() => {
 174:         return Array.from(document.querySelectorAll('a[href]'))
 175:             .map((node) => (node as HTMLAnchorElement).href)
 176:             .filter((href) => typeof href === 'string' && href.length > 0);
 177:     }).catch(() => [] as string[]);
 178: 
 179:     for (const href of anchors) {
 180:         candidates.add(href);
 181:     }
 182: 
 183:     return Array.from(candidates);
 184: }
 185: 
 186: function pickResolvedProfileUrl(candidates: string[]): string | null {
 187:     for (const candidate of candidates) {
 188:         const normalized = normalizeLinkedInUrl(candidate);
 189:         if (!isProfileUrl(normalized)) continue;
 190:         if (isSalesNavigatorUrl(normalized)) continue;
 191:         return normalized;
 192:     }
 193:     return null;
 194: }
 195: 
 196: function getRecoveryStatusFromBlockedReason(reason: string | null): 'READY_INVITE' | 'INVITED' | 'READY_MESSAGE' | null {
 197:     const normalized = (reason ?? '').toLowerCase();
 198:     if (normalized.includes('salesnav_url_requires_profile_invite')) {
 199:         return 'READY_INVITE';
 200:     }
 201:     if (normalized.includes('salesnav_url_requires_profile_check')) {
 202:         return 'INVITED';
 203:     }
 204:     if (normalized.includes('salesnav_url_requires_profile_message')) {
 205:         return 'READY_MESSAGE';
 206:     }
 207:     return null;
 208: }
 209: 
 210: const WORKFLOW_RUNNER_LOCK_KEY = 'workflow.runner';
 211: const WORKFLOW_RUNNER_MIN_TTL_SECONDS = 120;
 212: const WORKFLOW_RUNNER_HEARTBEAT_MS = 30_000;
 213: const AUTO_SITE_CHECK_LAST_RUN_KEY = 'site_check.last_run_at';
 214: const SALESNAV_LAST_SYNC_KEY = 'salesnav.last_sync_at';
 215: 
 216: function createLockOwnerId(command: string): string {
 217:     const suffix = randomUUID().split('-')[0];
 218:     return `${command}:${process.pid}:${suffix}`;
 219: }
 220: 
 221: function computeWorkflowLockTtlSeconds(intervalMs: number): number {
 222:     return Math.max(WORKFLOW_RUNNER_MIN_TTL_SECONDS, Math.ceil(intervalMs / 1000) + 120);
 223: }
 224: 
 225: async function acquireWorkflowRunnerLock(command: string, ttlSeconds: number, metadata: Record<string, unknown>): Promise<string> {
 226:     const ownerId = createLockOwnerId(command);
 227:     const result = await acquireRuntimeLock(WORKFLOW_RUNNER_LOCK_KEY, ownerId, ttlSeconds, metadata);
 228:     if (!result.acquired) {
 229:         const holder = result.lock;
 230:         throw new Error(
 231:             `[LOCK] Runner già attivo. owner=${holder?.owner_id ?? 'unknown'} heartbeat=${holder?.heartbeat_at ?? 'n/a'} expires=${holder?.expires_at ?? 'n/a'}`
 232:         );
 233:     }
 234:     console.log(`[LOCK] acquired key=${WORKFLOW_RUNNER_LOCK_KEY} owner=${ownerId} ttl=${ttlSeconds}s`);
 235:     return ownerId;
 236: }
 237: 
 238: async function heartbeatWorkflowRunnerLock(ownerId: string, ttlSeconds: number): Promise<void> {
 239:     const ok = await heartbeatRuntimeLock(WORKFLOW_RUNNER_LOCK_KEY, ownerId, ttlSeconds);
 240:     if (!ok) {
 241:         throw new Error('[LOCK] Runtime lock perso durante l\'esecuzione.');
 242:     }
 243: }
 244: 
 245: async function releaseWorkflowRunnerLock(ownerId: string): Promise<void> {
 246:     const released = await releaseRuntimeLock(WORKFLOW_RUNNER_LOCK_KEY, ownerId);
 247:     console.log(`[LOCK] released key=${WORKFLOW_RUNNER_LOCK_KEY} owner=${ownerId} released=${released}`);
 248: }
 249: 
 250: async function sleepWithLockHeartbeat(totalMs: number, ownerId: string, ttlSeconds: number): Promise<void> {
 251:     let remaining = Math.max(0, totalMs);
 252:     while (remaining > 0) {
 253:         const chunk = Math.min(WORKFLOW_RUNNER_HEARTBEAT_MS, remaining);
 254:         await sleep(chunk);
 255:         remaining -= chunk;
 256:         if (remaining > 0) {
 257:             await heartbeatWorkflowRunnerLock(ownerId, ttlSeconds);
 258:         }
 259:     }
 260: }
 261: 
 262: interface LoopDoctorGate {
 263:     proceed: boolean;
 264:     reason: string;
 265: }
 266: 
 267: interface AutoSiteCheckDecision {
 268:     shouldRun: boolean;
 269:     reason: string;
 270:     hoursSinceLastRun: number | null;
 271: }
 272: 
 273: interface SalesNavSyncDecision {
 274:     shouldRun: boolean;
 275:     reason: string;
 276:     hoursSinceLastRun: number | null;
 277: }
 278: 
 279: async function evaluateAutoSiteCheckDecision(dryRun: boolean): Promise<AutoSiteCheckDecision> {
 280:     if (dryRun) {
 281:         return { shouldRun: false, reason: 'dry_run', hoursSinceLastRun: null };
 282:     }
 283:     if (!config.autoSiteCheckEnabled) {
 284:         return { shouldRun: false, reason: 'auto_site_check_disabled', hoursSinceLastRun: null };
 285:     }
 286: 
 287:     const lastRunRaw = await getRuntimeFlag(AUTO_SITE_CHECK_LAST_RUN_KEY);
 288:     if (!lastRunRaw) {
 289:         return { shouldRun: true, reason: 'never_run', hoursSinceLastRun: null };
 290:     }
 291: 
 292:     const parsedMs = Date.parse(lastRunRaw);
 293:     if (!Number.isFinite(parsedMs)) {
 294:         return { shouldRun: true, reason: 'invalid_last_run', hoursSinceLastRun: null };
 295:     }
 296: 
 297:     const elapsedHours = (Date.now() - parsedMs) / (1000 * 60 * 60);
 298:     if (elapsedHours >= config.autoSiteCheckIntervalHours) {
 299:         return {
 300:             shouldRun: true,
 301:             reason: 'interval_elapsed',
 302:             hoursSinceLastRun: Number.parseFloat(elapsedHours.toFixed(2)),
 303:         };
 304:     }
 305: 
 306:     return {
 307:         shouldRun: false,
 308:         reason: 'interval_not_elapsed',
 309:         hoursSinceLastRun: Number.parseFloat(elapsedHours.toFixed(2)),
 310:     };
 311: }
 312: 
 313: async function evaluateSalesNavSyncDecision(dryRun: boolean): Promise<SalesNavSyncDecision> {
 314:     if (dryRun) {
 315:         return { shouldRun: false, reason: 'dry_run', hoursSinceLastRun: null };
 316:     }
 317:     if (!config.salesNavSyncEnabled) {
 318:         return { shouldRun: false, reason: 'salesnav_sync_disabled', hoursSinceLastRun: null };
 319:     }
 320: 
 321:     const lastRunRaw = await getRuntimeFlag(SALESNAV_LAST_SYNC_KEY);
 322:     if (!lastRunRaw) {
 323:         return { shouldRun: true, reason: 'never_run', hoursSinceLastRun: null };
 324:     }
 325: 
 326:     const parsedMs = Date.parse(lastRunRaw);
 327:     if (!Number.isFinite(parsedMs)) {
 328:         return { shouldRun: true, reason: 'invalid_last_run', hoursSinceLastRun: null };
 329:     }
 330: 
 331:     const elapsedHours = (Date.now() - parsedMs) / (1000 * 60 * 60);
 332:     if (elapsedHours >= config.salesNavSyncIntervalHours) {
 333:         return {
 334:             shouldRun: true,
 335:             reason: 'interval_elapsed',
 336:             hoursSinceLastRun: Number.parseFloat(elapsedHours.toFixed(2)),
 337:         };
 338:     }
 339: 
 340:     return {
 341:         shouldRun: false,
 342:         reason: 'interval_not_elapsed',
 343:         hoursSinceLastRun: Number.parseFloat(elapsedHours.toFixed(2)),
 344:     };
 345: }
 346: 
 347: async function evaluateLoopDoctorGate(dryRun: boolean): Promise<LoopDoctorGate> {
 348:     if (dryRun) {
 349:         return { proceed: true, reason: 'dry_run' };
 350:     }
 351: 
 352:     const report = await runDoctor();
 353:     const syncOk = !report.sync.enabled || report.sync.configured;
 354:     if (!report.sessionLoginOk) {
 355:         return { proceed: false, reason: 'doctor_login_missing' };
 356:     }
 357:     if (report.quarantine) {
 358:         return { proceed: false, reason: 'doctor_quarantine_active' };
 359:     }
 360:     if (!syncOk) {
 361:         return { proceed: false, reason: 'doctor_sync_not_configured' };
 362:     }
 363:     return { proceed: true, reason: 'doctor_ok' };
 364: }
 365: 
 366: function printHelp(): void {
 367:     console.log('Utilizzo consigliato (Windows): .\\bot.ps1 <comando> [opzioni]');
 368:     console.log('Alternativa: npx ts-node src/index.ts <comando> [opzioni]');
 369:     console.log('Compatibilità: npm start -- <comando> [opzioni]');
 370:     console.log('Comandi principali:');
 371:     console.log('  import --file <file.csv> --list <nome_lista>');
 372:     console.log('  run invite|check|message|all (oppure --workflow <valore>)');
 373:     console.log('  dry-run invite|check|message|all (oppure --workflow <valore>)');
 374:     console.log('  run-loop [workflow] [intervalSec] [--cycles <n>] [--dry-run]');
 375:     console.log('  autopilot [intervalSec] [--cycles <n>] [--dry-run]');
 376:     console.log('  login [timeoutSec] [--account <id_account>]');
 377:     console.log('  doctor');
 378:     console.log('  status');
 379:     console.log('  proxy-status');
 380:     console.log('  funnel');
 381:     console.log('  site-check [limit] [--fix]');
 382:     console.log('  state-sync [limit] [--fix]');
 383:     console.log('  salesnav-resolve [limit] [--fix] [--dry-run]');
 384:     console.log('  salesnav-sync [listName] [--url <salesnav_list_url>] [--max-pages <n>] [--limit <n>] [--account <id>] [--dry-run]');
 385:     console.log('  salesnav-lists [--limit <n>]');
 386:     console.log('  salesnav-create-list <nome> [--account <id>]');
 387:     console.log('  salesnav-add-lead <leadId> <listName> [--account <id>]');
 388:     console.log('  salesnav-add-to-list <leadId> <listName> [--account <id>]  # alias');
 389:     console.log('  random-activity [--account <id>] [--max-actions <n>] [--dry-run]');
 390:     console.log('  enrich-targets [limit] [--dry-run]');
 391:     console.log('  pause [minutes|indefinite] [reason]');
 392:     console.log('  resume');
 393:     console.log('  unquarantine');
 394:     console.log('  incidents [open]');
 395:     console.log('  incident-resolve <id>');
 396:     console.log('  privacy-cleanup [days]');
 397:     console.log('  lists');
 398:     console.log('  company-targets [list] [limit]');
 399:     console.log('  list-config <nome_lista> [priority] [inviteCap|none] [messageCap|none] [active]');
 400:     console.log('    (oppure con opzioni: --list, --priority, --invite-cap, --message-cap, --active)');
 401:     console.log('  sync-status');
 402:     console.log('  sync-run-once');
 403:     console.log('Alias retrocompatibili: connect, check, message');
 404: }
 405: 
 406: async function runImportCommand(args: string[]): Promise<void> {
 407:     const legacyPath = args[0] && !args[0].startsWith('--') ? args[0] : undefined;
 408:     const filePath = getOptionValue(args, '--file') ?? legacyPath;
 409:     const listName = getOptionValue(args, '--list') ?? 'default';
 410: 
 411:     if (!filePath) {
 412:         throw new Error('Specifica il CSV: npm start -- import --file path/to/file.csv --list nome_lista');
 413:     }
 414: 
 415:     const result = await importLeadsFromCSV(filePath, listName);
 416:     console.log(
 417:         `Import completato. Lead inseriti=${result.inserted}, Company target inseriti=${result.companyTargetsInserted}, Skippati=${result.skipped}, Lista=${listName}`
 418:     );
 419: }
 420: 
 421: async function runLoginCommand(args: string[]): Promise<void> {
 422:     const positional = getPositionalArgs(args);
 423:     const positionalTimeout = positional.find((value) => /^\d+$/.test(value));
 424:     const positionalAccount = positional.find((value) => !/^\d+$/.test(value));
 425:     const timeoutRaw = getOptionValue(args, '--timeout') ?? positionalTimeout;
 426:     const timeoutSeconds = timeoutRaw ? Math.max(30, parseIntStrict(timeoutRaw, '--timeout')) : 300;
 427:     const timeoutMs = timeoutSeconds * 1000;
 428:     const accountRaw = getOptionValue(args, '--account') ?? positionalAccount;
 429:     const selectedAccount = getAccountProfileById(accountRaw);
 430:     const availableAccounts = getRuntimeAccountProfiles().map((account) => account.id);
 431:     if (accountRaw && accountRaw !== selectedAccount.id) {
 432:         console.warn(`[LOGIN] account=${accountRaw} non trovato. Uso account=${selectedAccount.id}. Disponibili: ${availableAccounts.join(', ')}`);
 433:     }
 434: 
 435:     const session = await launchBrowser({
 436:         headless: false,
 437:         sessionDir: selectedAccount.sessionDir,
 438:         proxy: selectedAccount.proxy,
 439:     });
 440:     try {
 441:         await session.page.goto('https://www.linkedin.com/login', { waitUntil: 'load' });
 442:         console.log(`Completa il login LinkedIn nella finestra aperta (account=${selectedAccount.id}, timeout ${timeoutSeconds}s)...`);
 443:         console.log('Il browser resta aperto finché il login non viene verificato o finché scade il timeout.');
 444: 
 445:         const startedAt = Date.now();
 446:         let lastLogAt = 0;
 447:         while (Date.now() - startedAt <= timeoutMs) {
 448:             if (await isLoggedIn(session.page)) {
 449:                 const confirmed = await checkLogin(session.page);
 450:                 if (confirmed) {
 451:                     console.log('Login sessione completato con successo.');
 452:                     return;
 453:                 }
 454:             }
 455:             const now = Date.now();
 456:             if (now - lastLogAt >= 15_000) {
 457:                 const remaining = Math.max(0, Math.ceil((timeoutMs - (now - startedAt)) / 1000));
 458:                 console.log(`In attesa completamento login... (${remaining}s rimanenti)`);
 459:                 lastLogAt = now;
 460:             }
 461:             await session.page.waitForTimeout(2500);
 462:         }
 463: 
 464:         // Ultimo controllo esplicito sulla home LinkedIn.
 465:         const loggedIn = await checkLogin(session.page);
 466:         if (!loggedIn) {
 467:             throw new Error(`Login non rilevato entro ${timeoutSeconds} secondi.`);
 468:         }
 469:         console.log('Login sessione completato con successo.');
 470:     } finally {
 471:         await closeBrowserSession(session);
 472:     }
 473: }
 474: 
 475: async function runLoopCommand(args: string[]): Promise<void> {
 476:     const workflow = parseWorkflow(getWorkflowValue(args));
 477:     const positional = getPositionalArgs(args);
 478:     const workflowTokens = new Set(['invite', 'check', 'message', 'all']);
 479:     const numericPositionals = positional.filter((value) => /^\d+$/.test(value));
 480:     const intervalMsRaw = getOptionValue(args, '--interval-ms');
 481:     const intervalSecRaw = getOptionValue(args, '--interval-sec');
 482:     const cyclesRaw = getOptionValue(args, '--cycles') ?? numericPositionals[1];
 483:     const dryRun = hasOption(args, '--dry-run') || positional.some((value) => value.toLowerCase() === 'dry' || value.toLowerCase() === 'dry-run');
 484: 
 485:     let intervalMs = config.workflowLoopIntervalMs;
 486:     if (intervalMsRaw) {
 487:         intervalMs = Math.max(10_000, parseIntStrict(intervalMsRaw, '--interval-ms'));
 488:     } else if (intervalSecRaw) {
 489:         intervalMs = Math.max(10, parseIntStrict(intervalSecRaw, '--interval-sec')) * 1000;
 490:     } else {
 491:         const numericPositional = positional.find((value) => !workflowTokens.has(value) && /^\d+$/.test(value));
 492:         if (numericPositional) {
 493:             intervalMs = Math.max(10, parseIntStrict(numericPositional, 'intervalSec')) * 1000;
 494:         }
 495:     }
 496: 
 497:     const maxCycles = cyclesRaw ? Math.max(1, parseIntStrict(cyclesRaw, '--cycles')) : null;
 498:     console.log(`[LOOP] start workflow=${workflow} dryRun=${dryRun} intervalMs=${intervalMs} cycles=${maxCycles ?? 'infinite'}`);
 499: 
 500:     const lockTtlSeconds = computeWorkflowLockTtlSeconds(intervalMs);
 501:     const lockOwnerId = dryRun
 502:         ? null
 503:         : await acquireWorkflowRunnerLock('run-loop', lockTtlSeconds, {
 504:             workflow,
 505:             dryRun,
 506:             intervalMs,
 507:             startedAt: new Date().toISOString(),
 508:         });
 509: 
 510:     try {
 511:         let cycle = 0;
 512:         while (true) {
 513:             cycle += 1;
 514:             const started = new Date().toISOString();
 515:             console.log(`[LOOP] cycle=${cycle} started_at=${started}`);
 516:             try {
 517:                 if (lockOwnerId) {
 518:                     await heartbeatWorkflowRunnerLock(lockOwnerId, lockTtlSeconds);
 519:                 }
 520: 
 521:                 const doctorGate = await evaluateLoopDoctorGate(dryRun);
 522:                 if (!doctorGate.proceed) {
 523:                     console.warn(`[LOOP] cycle=${cycle} skipped reason=${doctorGate.reason}`);
 524:                 } else {
 525:                     const autoSiteCheck = await evaluateAutoSiteCheckDecision(dryRun);
 526:                     if (autoSiteCheck.shouldRun) {
 527:                         const siteCheckReport = await runSiteCheck({
 528:                             limitPerStatus: config.autoSiteCheckLimit,
 529:                             autoFix: config.autoSiteCheckFix,
 530:                         });
 531:                         await setRuntimeFlag(AUTO_SITE_CHECK_LAST_RUN_KEY, new Date().toISOString());
 532:                         console.log('[LOOP] auto-site-check', {
 533:                             reason: autoSiteCheck.reason,
 534:                             intervalHours: config.autoSiteCheckIntervalHours,
 535:                             limitPerStatus: config.autoSiteCheckLimit,
 536:                             staleDays: config.siteCheckStaleDays,
 537:                             autoFix: config.autoSiteCheckFix,
 538:                             report: siteCheckReport,
 539:                         });
 540: 
 541:                         // Dopo il site-check, 10% di probabilità di visitare un profilo casuale
 542:                         // per diluire il pattern di scraping e rendere il traffico più naturale.
 543:                         if (!dryRun && Math.random() < 0.10) {
 544:                             const decoyProfiles = [
 545:                                 'https://www.linkedin.com/in/satya-nadella/',
 546:                                 'https://www.linkedin.com/in/jeffweiner08/',
 547:                                 'https://www.linkedin.com/in/reidhoffman/',
 548:                                 'https://www.linkedin.com/in/guyraz/',
 549:                                 'https://www.linkedin.com/in/ariellalouis/',
 550:                             ];
 551:                             const decoy = decoyProfiles[Math.floor(Math.random() * decoyProfiles.length)];
 552:                             try {
 553:                                 const decoySession = await launchBrowser({ headless: config.headless });
 554:                                 try {
 555:                                     await decoySession.page.goto(decoy, { waitUntil: 'domcontentloaded' });
 556:                                     await humanDelay(decoySession.page, 3000, 7000);
 557:                                     console.log(`[LOOP] decoy-visit url=${decoy}`);
 558:                                 } finally {
 559:                                     await closeBrowserSession(decoySession);
 560:                                 }
 561:                             } catch {
 562:                                 // Ignora errori nella visita decoy: non è critica
 563:                             }
 564:                         }
 565:                     } else {
 566:                         console.log('[LOOP] auto-site-check skipped', autoSiteCheck);
 567:                     }
 568: 
 569:                     if (config.salesNavSyncEnabled && (workflow === 'all' || workflow === 'invite')) {
 570:                         const salesNavDecision = await evaluateSalesNavSyncDecision(dryRun);
 571:                         if (salesNavDecision.shouldRun) {
 572:                             const salesNavSyncReport = await runSalesNavigatorListSync({
 573:                                 listName: config.salesNavSyncListName,
 574:                                 listUrl: config.salesNavSyncListUrl || undefined,
 575:                                 maxPages: config.salesNavSyncMaxPages,
 576:                                 maxLeadsPerList: config.salesNavSyncLimit,
 577:                                 dryRun,
 578:                                 accountId: config.salesNavSyncAccountId || undefined,
 579:                             });
 580:                             await setRuntimeFlag(SALESNAV_LAST_SYNC_KEY, new Date().toISOString());
 581:                             console.log('[LOOP] salesnav-sync', {
 582:                                 reason: salesNavDecision.reason,
 583:                                 intervalHours: config.salesNavSyncIntervalHours,
 584:                                 limitPerList: config.salesNavSyncLimit,
 585:                                 report: salesNavSyncReport,
 586:                             });
 587:                         } else {
 588:                             console.log('[LOOP] salesnav-sync skipped', salesNavDecision);
 589:                         }
 590:                     }
 591: 
 592:                     if (config.companyEnrichmentEnabled && (workflow === 'all' || workflow === 'invite')) {
 593:                         const enrichment = await runCompanyEnrichmentBatch({
 594:                             limit: config.companyEnrichmentBatch,
 595:                             maxProfilesPerCompany: config.companyEnrichmentMaxProfilesPerCompany,
 596:                             dryRun,
 597:                         });
 598:                         console.log('[LOOP] enrichment', enrichment);
 599:                     }
 600:                     await runWorkflow({ workflow, dryRun });
 601: 
 602:                     if (!dryRun && config.randomActivityEnabled && Math.random() <= config.randomActivityProbability) {
 603:                         const randomActivityReport = await runRandomLinkedinActivity({
 604:                             accountId: config.salesNavSyncAccountId || undefined,
 605:                             maxActions: config.randomActivityMaxActions,
 606:                             dryRun,
 607:                         });
 608:                         console.log('[LOOP] random-activity', randomActivityReport);
 609:                     }
 610: 
 611:                     console.log(`[LOOP] cycle=${cycle} completed`);
 612:                 }
 613:             } catch (error) {
 614:                 console.error(`[LOOP] cycle=${cycle} failed`, error);
 615:             }
 616: 
 617:             if (maxCycles !== null && cycle >= maxCycles) {
 618:                 console.log(`[LOOP] completed ${cycle} cycle(s).`);
 619:                 break;
 620:             }
 621: 
 622:             console.log(`[LOOP] waiting ${Math.floor(intervalMs / 1000)}s before next cycle...`);
 623:             if (lockOwnerId) {
 624:                 await sleepWithLockHeartbeat(intervalMs, lockOwnerId, lockTtlSeconds);
 625:             } else {
 626:                 await sleep(intervalMs);
 627:             }
 628:         }
 629:     } finally {
 630:         if (lockOwnerId) {
 631:             await releaseWorkflowRunnerLock(lockOwnerId);
 632:         }
 633:     }
 634: }
 635: 
 636: async function runAutopilotCommand(args: string[]): Promise<void> {
 637:     const positional = getPositionalArgs(args);
 638:     const intervalRaw = getOptionValue(args, '--interval-sec') ?? positional[0];
 639:     const cyclesRaw = getOptionValue(args, '--cycles') ?? positional[1];
 640:     const intervalArg = intervalRaw ?? String(Math.floor(config.workflowLoopIntervalMs / 1000));
 641:     const forwarded = ['all', intervalArg];
 642:     if (cyclesRaw && /^\d+$/.test(cyclesRaw)) {
 643:         forwarded.push('--cycles', cyclesRaw);
 644:     }
 645:     if (hasOption(args, '--dry-run') || positional.includes('dry') || positional.includes('dry-run')) {
 646:         forwarded.push('--dry-run');
 647:     }
 648:     await runLoopCommand(forwarded);
 649: }
 650: 
 651: async function runWorkflowCommand(workflow: WorkflowSelection, dryRun: boolean): Promise<void> {
 652:     if (dryRun) {
 653:         await runWorkflow({ workflow, dryRun: true });
 654:         return;
 655:     }
 656: 
 657:     const lockTtlSeconds = Math.max(300, config.jobStuckMinutes * 60 + 300);
 658:     const lockOwnerId = await acquireWorkflowRunnerLock('run', lockTtlSeconds, {
 659:         workflow,
 660:         dryRun: false,
 661:         startedAt: new Date().toISOString(),
 662:     });
 663:     try {
 664:         await runWorkflow({ workflow, dryRun: false });
 665:         await heartbeatWorkflowRunnerLock(lockOwnerId, lockTtlSeconds);
 666:     } finally {
 667:         await releaseWorkflowRunnerLock(lockOwnerId);
 668:     }
 669: }
 670: 
 671: async function runFunnelCommand(): Promise<void> {
 672:     const report = await buildFunnelReport();
 673:     console.log(JSON.stringify(report, null, 2));
 674: }
 675: 
 676: async function runSiteCheckCommand(args: string[]): Promise<void> {
 677:     const positional = getPositionalArgs(args);
 678:     const limitRaw = getOptionValue(args, '--limit') ?? positional[0];
 679:     const limit = limitRaw ? Math.max(1, parseIntStrict(limitRaw, '--limit')) : 25;
 680:     const autoFix = hasOption(args, '--fix') || positional.includes('fix');
 681:     const report = await runSiteCheck({ limitPerStatus: limit, autoFix });
 682:     console.log(JSON.stringify(report, null, 2));
 683: }
 684: 
 685: async function runStateSyncCommand(args: string[]): Promise<void> {
 686:     const positional = getPositionalArgs(args);
 687:     const limitRaw = getOptionValue(args, '--limit') ?? positional[0];
 688:     const limit = limitRaw ? Math.max(1, parseIntStrict(limitRaw, '--limit')) : config.postRunStateSyncLimit;
 689:     const autoFix = hasOption(args, '--fix') || positional.includes('fix') || config.postRunStateSyncFix;
 690:     const report = await runSiteCheck({ limitPerStatus: limit, autoFix });
 691:     console.log(JSON.stringify({
 692:         mode: 'state_sync',
 693:         limitPerStatus: limit,
 694:         autoFix,
 695:         report,
 696:     }, null, 2));
 697: }
 698: 
 699: async function runSalesNavSyncCommand(args: string[]): Promise<void> {
 700:     const positional = getPositionalArgs(args);
 701:     const dryRun = hasOption(args, '--dry-run') || positional.includes('dry-run') || positional.includes('dry');
 702:     const listName = getOptionValue(args, '--list') ?? positional[0] ?? config.salesNavSyncListName;
 703:     const listUrl = getOptionValue(args, '--url') ?? positional[1] ?? config.salesNavSyncListUrl;
 704:     const maxPagesRaw = getOptionValue(args, '--max-pages');
 705:     const maxPages = maxPagesRaw ? Math.max(1, parseIntStrict(maxPagesRaw, '--max-pages')) : config.salesNavSyncMaxPages;
 706:     const limitRaw = getOptionValue(args, '--limit');
 707:     const maxLeadsPerList = limitRaw ? Math.max(1, parseIntStrict(limitRaw, '--limit')) : config.salesNavSyncLimit;
 708:     const accountId = getOptionValue(args, '--account') ?? config.salesNavSyncAccountId;
 709: 
 710:     const report = await runSalesNavigatorListSync({
 711:         listName: listName?.trim() ? listName : null,
 712:         listUrl: listUrl?.trim() ? listUrl : null,
 713:         maxPages,
 714:         maxLeadsPerList,
 715:         dryRun,
 716:         accountId: accountId || undefined,
 717:     });
 718:     console.log(JSON.stringify(report, null, 2));
 719: }
 720: 
 721: async function runSalesNavListsCommand(args: string[]): Promise<void> {
 722:     const positional = getPositionalArgs(args);
 723:     const limitRaw = getOptionValue(args, '--limit') ?? positional[0];
 724:     const limit = limitRaw ? Math.max(1, parseIntStrict(limitRaw, '--limit')) : 200;
 725:     const lists = await listSalesNavLists(limit);
 726:     console.log(JSON.stringify({ total: lists.length, items: lists }, null, 2));
 727: }
 728: 
 729: async function runSalesNavCreateListCommand(args: string[]): Promise<void> {
 730:     const positional = getPositionalArgs(args);
 731:     const listName = getOptionValue(args, '--name') ?? positional[0];
 732:     const accountId = getOptionValue(args, '--account') ?? config.salesNavSyncAccountId;
 733:     if (!listName || !listName.trim()) {
 734:         throw new Error('Specifica nome lista: salesnav-create-list <nome>');
 735:     }
 736:     const result = await createSalesNavList(listName, accountId || undefined);
 737:     let dbListId: number | null = null;
 738:     let dbSyncError: string | null = null;
 739: 
 740:     if (result.ok) {
 741:         try {
 742:             const normalizedName = (result.listName ?? listName).trim();
 743:             if (result.listUrl) {
 744:                 const listRow = await upsertSalesNavList(normalizedName, result.listUrl);
 745:                 dbListId = listRow.id;
 746:             } else {
 747:                 const existing = await getSalesNavListByName(normalizedName);
 748:                 dbListId = existing?.id ?? null;
 749:             }
 750:         } catch (error) {
 751:             dbSyncError = error instanceof Error ? error.message : String(error);
 752:         }
 753:     }
 754: 
 755:     console.log(JSON.stringify({
 756:         ...result,
 757:         dbSync: {
 758:             listId: dbListId,
 759:             synced: dbListId !== null,
 760:             error: dbSyncError,
 761:         },
 762:     }, null, 2));
 763: }
 764: 
 765: async function runSalesNavAddLeadCommand(args: string[]): Promise<void> {
 766:     const positional = getPositionalArgs(args);
 767:     const leadIdRaw = getOptionValue(args, '--lead-id') ?? positional[0];
 768:     const listName = getOptionValue(args, '--list') ?? positional[1];
 769:     const accountId = getOptionValue(args, '--account') ?? config.salesNavSyncAccountId;
 770: 
 771:     if (!leadIdRaw) {
 772:         throw new Error('Specifica leadId: salesnav-add-lead <leadId> <listName>');
 773:     }
 774:     if (!listName || !listName.trim()) {
 775:         throw new Error('Specifica listName: salesnav-add-lead <leadId> <listName>');
 776:     }
 777: 
 778:     const leadId = Math.max(1, parseIntStrict(leadIdRaw, '--lead-id'));
 779:     const lead = await getLeadById(leadId);
 780:     if (!lead) {
 781:         throw new Error(`Lead non trovato: ${leadId}`);
 782:     }
 783: 
 784:     const result = await addLeadToSalesNavList(lead.linkedin_url, listName, accountId || undefined);
 785:     const targetListName = (result.listName ?? listName).trim();
 786:     let dbListId: number | null = null;
 787:     let dbLinked = false;
 788:     let dbSyncError: string | null = null;
 789: 
 790:     if (result.ok) {
 791:         try {
 792:             let listRow = await getSalesNavListByName(targetListName);
 793:             if (!listRow && result.listUrl) {
 794:                 listRow = await upsertSalesNavList(targetListName, result.listUrl);
 795:             }
 796:             if (listRow) {
 797:                 dbListId = listRow.id;
 798:                 await linkLeadToSalesNavList(listRow.id, leadId);
 799:                 dbLinked = true;
 800:             }
 801:         } catch (error) {
 802:             dbSyncError = error instanceof Error ? error.message : String(error);
 803:         }
 804:     }
 805: 
 806:     console.log(JSON.stringify({
 807:         leadId,
 808:         listName,
 809:         leadUrl: lead.linkedin_url,
 810:         dbSync: {
 811:             listId: dbListId,
 812:             linked: dbLinked,
 813:             error: dbSyncError,
 814:         },
 815:         ...result,
 816:     }, null, 2));
 817: }
 818: 
 819: async function runProxyStatusCommand(): Promise<void> {
 820:     const status = getProxyPoolStatus();
 821:     const failoverChain = getProxyFailoverChain().map((proxy, index) => ({
 822:         order: index + 1,
 823:         server: proxy.server,
 824:         auth: !!proxy.username || !!proxy.password,
 825:     }));
 826: 
 827:     console.log(JSON.stringify({
 828:         ...status,
 829:         failoverChain,
 830:     }, null, 2));
 831: }
 832: 
 833: async function runRandomActivityCommand(args: string[]): Promise<void> {
 834:     const positional = getPositionalArgs(args);
 835:     const maxActionsRaw = getOptionValue(args, '--max-actions')
 836:         ?? getOptionValue(args, '--actions')
 837:         ?? positional.find((value) => /^\d+$/.test(value));
 838:     const accountId = getOptionValue(args, '--account')
 839:         ?? positional.find((value) => {
 840:             const normalized = value.toLowerCase();
 841:             if (normalized === 'dry' || normalized === 'dry-run') return false;
 842:             return !value.startsWith('--') && !/^\d+$/.test(value);
 843:         })
 844:         ?? config.salesNavSyncAccountId
 845:         ?? undefined;
 846:     const dryRun = hasOption(args, '--dry-run') || positional.includes('dry') || positional.includes('dry-run');
 847:     const maxActions = maxActionsRaw
 848:         ? Math.max(1, parseIntStrict(maxActionsRaw, '--max-actions'))
 849:         : config.randomActivityMaxActions;
 850: 
 851:     const report = await runRandomLinkedinActivity({
 852:         accountId: accountId || undefined,
 853:         maxActions,
 854:         dryRun,
 855:     });
 856:     console.log(JSON.stringify(report, null, 2));
 857: }
 858: 
 859: async function runSalesNavResolveCommand(args: string[]): Promise<void> {
 860:     const positional = getPositionalArgs(args);
 861:     const limitRaw = getOptionValue(args, '--limit') ?? positional[0];
 862:     const limit = limitRaw ? Math.max(1, parseIntStrict(limitRaw, '--limit')) : 25;
 863:     const fix = hasOption(args, '--fix') || positional.includes('fix');
 864:     const dryRun = hasOption(args, '--dry-run') || positional.includes('dry-run') || positional.includes('dry');
 865: 
 866:     const leads = await getLeadsWithSalesNavigatorUrls(limit);
 867:     const report: SalesNavResolveReport = {
 868:         scanned: 0,
 869:         resolvable: 0,
 870:         updated: 0,
 871:         conflicts: 0,
 872:         unresolved: 0,
 873:         challengeDetected: false,
 874:         fix,
 875:         dryRun,
 876:         items: [],
 877:     };
 878: 
 879:     if (leads.length === 0) {
 880:         console.log(JSON.stringify(report, null, 2));
 881:         return;
 882:     }
 883: 
 884:     const session = await launchBrowser({ headless: config.headless });
 885:     try {
 886:         const loggedIn = await checkLogin(session.page);
 887:         if (!loggedIn) {
 888:             throw new Error('Sessione LinkedIn non autenticata. Esegui prima: .\\bot.ps1 login');
 889:         }
 890: 
 891:         for (const lead of leads) {
 892:             report.scanned += 1;
 893:             try {
 894:                 await session.page.goto(lead.linkedin_url, { waitUntil: 'domcontentloaded' });
 895:                 await humanDelay(session.page, 1000, 2000);
 896: 
 897:                 if (await detectChallenge(session.page)) {
 898:                     report.challengeDetected = true;
 899:                     report.items.push({
 900:                         leadId: lead.id,
 901:                         status: lead.status,
 902:                         currentUrl: lead.linkedin_url,
 903:                         resolvedProfileUrl: null,
 904:                         action: 'challenge_detected',
 905:                     });
 906:                     break;
 907:                 }
 908: 
 909:                 const candidates = await collectProfileUrlCandidates(session.page);
 910:                 const resolvedProfileUrl = pickResolvedProfileUrl(candidates);
 911:                 if (!resolvedProfileUrl) {
 912:                     report.unresolved += 1;
 913:                     report.items.push({
 914:                         leadId: lead.id,
 915:                         status: lead.status,
 916:                         currentUrl: lead.linkedin_url,
 917:                         resolvedProfileUrl: null,
 918:                         action: 'unresolved',
 919:                     });
 920:                     continue;
 921:                 }
 922: 
 923:                 report.resolvable += 1;
 924:                 if (!fix || dryRun) {
 925:                     report.items.push({
 926:                         leadId: lead.id,
 927:                         status: lead.status,
 928:                         currentUrl: lead.linkedin_url,
 929:                         resolvedProfileUrl,
 930:                         action: 'resolved',
 931:                     });
 932:                     continue;
 933:                 }
 934: 
 935:                 const updated = await updateLeadLinkedinUrl(lead.id, resolvedProfileUrl);
 936:                 if (updated.updated) {
 937:                     const recoveryStatus = lead.status === 'BLOCKED'
 938:                         ? getRecoveryStatusFromBlockedReason(lead.blocked_reason)
 939:                         : null;
 940:                     if (recoveryStatus) {
 941:                         await reconcileLeadStatus(lead.id, recoveryStatus, 'salesnav_profile_url_resolved', {
 942:                             previousStatus: lead.status,
 943:                             blockedReason: lead.blocked_reason,
 944:                         });
 945:                     }
 946:                     report.updated += 1;
 947:                     report.items.push({
 948:                         leadId: lead.id,
 949:                         status: lead.status,
 950:                         currentUrl: lead.linkedin_url,
 951:                         resolvedProfileUrl,
 952:                         action: 'updated',
 953:                     });
 954:                 } else {
 955:                     report.conflicts += 1;
 956:                     report.items.push({
 957:                         leadId: lead.id,
 958:                         status: lead.status,
 959:                         currentUrl: lead.linkedin_url,
 960:                         resolvedProfileUrl,
 961:                         action: 'conflict',
 962:                         conflictLeadId: updated.conflictLeadId,
 963:                     });
 964:                 }
 965:             } catch (error) {
 966:                 report.items.push({
 967:                     leadId: lead.id,
 968:                     status: lead.status,
 969:                     currentUrl: lead.linkedin_url,
 970:                     resolvedProfileUrl: null,
 971:                     action: 'error',
 972:                     error: error instanceof Error ? error.message : String(error),
 973:                 });
 974:             }
 975:         }
 976:     } finally {
 977:         await closeBrowserSession(session);
 978:     }
 979: 
 980:     console.log(JSON.stringify(report, null, 2));
 981: }
 982: 
 983: async function runEnrichTargetsCommand(args: string[]): Promise<void> {
 984:     const positional = getPositionalArgs(args);
 985:     const limitRaw = getOptionValue(args, '--limit') ?? positional[0];
 986:     const limit = limitRaw ? Math.max(1, parseIntStrict(limitRaw, '--limit')) : config.companyEnrichmentBatch;
 987:     const dryRun = hasOption(args, '--dry-run') || positional.includes('dry') || positional.includes('dry-run');
 988:     const report = await runCompanyEnrichmentBatch({
 989:         limit,
 990:         maxProfilesPerCompany: config.companyEnrichmentMaxProfilesPerCompany,
 991:         dryRun,
 992:     });
 993:     console.log(JSON.stringify(report, null, 2));
 994: }
 995: 
 996: async function runStatusCommand(): Promise<void> {
 997:     const localDate = getLocalDateString();
 998:     const [
 999:         quarantineFlag,
1000:         pauseState,
1001:         incidents,
1002:         jobStatusCounts,
1003:         dailyStats,
1004:         syncStatus,
1005:         runnerLock,
1006:         autoSiteCheckLastRunAt,
1007:         salesNavSyncLastRunAt,
1008:     ] = await Promise.all([
1009:         getRuntimeFlag('account_quarantine'),
1010:         getAutomationPauseState(),
1011:         listOpenIncidents(),
1012:         getJobStatusCounts(),
1013:         getDailyStatsSnapshot(localDate),
1014:         getEventSyncStatus(),
1015:         getRuntimeLock(WORKFLOW_RUNNER_LOCK_KEY),
1016:         getRuntimeFlag(AUTO_SITE_CHECK_LAST_RUN_KEY),
1017:         getRuntimeFlag(SALESNAV_LAST_SYNC_KEY),
1018:     ]);
1019: 
1020:     const payload = {
1021:         localDate,
1022:         quarantine: quarantineFlag === 'true',
1023:         accounts: getRuntimeAccountProfiles().map((account) => ({
1024:             id: account.id,
1025:             sessionDir: account.sessionDir,
1026:             dedicatedProxy: !!account.proxy,
1027:         })),
1028:         pause: pauseState,
1029:         openIncidents: incidents.length,
1030:         jobs: jobStatusCounts,
1031:         proxy: getProxyPoolStatus(),
1032:         dailyStats,
1033:         sync: syncStatus,
1034:         runnerLock,
1035:         autoSiteCheck: {
1036:             enabled: config.autoSiteCheckEnabled,
1037:             fix: config.autoSiteCheckFix,
1038:             limitPerStatus: config.autoSiteCheckLimit,
1039:             intervalHours: config.autoSiteCheckIntervalHours,
1040:             staleDays: config.siteCheckStaleDays,
1041:             lastRunAt: autoSiteCheckLastRunAt,
1042:         },
1043:         stateSync: {
1044:             postRunEnabled: config.postRunStateSyncEnabled,
1045:             postRunLimit: config.postRunStateSyncLimit,
1046:             postRunFix: config.postRunStateSyncFix,
1047:         },
1048:         salesNavSync: {
1049:             enabled: config.salesNavSyncEnabled,
1050:             listName: config.salesNavSyncListName,
1051:             listUrlConfigured: !!config.salesNavSyncListUrl.trim(),
1052:             maxPages: config.salesNavSyncMaxPages,
1053:             intervalHours: config.salesNavSyncIntervalHours,
1054:             limitPerList: config.salesNavSyncLimit,
1055:             accountId: config.salesNavSyncAccountId || null,
1056:             lastRunAt: salesNavSyncLastRunAt,
1057:         },
1058:         randomActivity: {
1059:             enabled: config.randomActivityEnabled,
1060:             probability: config.randomActivityProbability,
1061:             maxActions: config.randomActivityMaxActions,
1062:         },
1063:         ai: {
1064:             personalizationEnabled: config.aiPersonalizationEnabled,
1065:             guardianEnabled: config.aiGuardianEnabled,
1066:             model: config.aiModel,
1067:             openaiConfigured: !!config.openaiApiKey,
1068:             guardianMinIntervalMinutes: config.aiGuardianMinIntervalMinutes,
1069:             guardianPauseMinutes: config.aiGuardianPauseMinutes,
1070:         },
1071:     };
1072:     console.log(JSON.stringify(payload, null, 2));
1073: }
1074: 
1075: async function runPauseCommand(args: string[]): Promise<void> {
1076:     const positional = getPositionalArgs(args);
1077:     const minutesRaw = getOptionValue(args, '--minutes') ?? positional[0];
1078:     const reasonRaw = getOptionValue(args, '--reason') ?? (positional.length > 1 ? positional.slice(1).join(' ') : 'manual_pause');
1079: 
1080:     const minutes = minutesRaw
1081:         ? parsePauseMinutes(minutesRaw, '--minutes')
1082:         : config.autoPauseMinutesOnFailureBurst;
1083:     const pausedUntil = await setAutomationPause(minutes, reasonRaw);
1084:     const renderedUntil = pausedUntil ?? 'manual resume';
1085:     console.log(`Automazione in pausa. pausedUntil=${renderedUntil} reason=${reasonRaw}`);
1086: }
1087: 
1088: async function runResumeCommand(): Promise<void> {
1089:     await clearPauseState();
1090:     console.log('Pausa automazione rimossa.');
1091: }
1092: 
1093: async function runUnquarantineCommand(): Promise<void> {
1094:     await setQuarantine(false);
1095:     await clearPauseState();
1096:     console.log('Quarantine disattivata e pausa rimossa.');
1097: }
1098: 
1099: async function runResolveIncidentCommand(args: string[]): Promise<void> {
1100:     const positional = getPositionalArgs(args);
1101:     const idRaw = getOptionValue(args, '--id') ?? positional[0];
1102:     if (!idRaw) {
1103:         throw new Error('Specifica ID incidente: npm start -- incident-resolve <id>');
1104:     }
1105:     const incidentId = parseIntStrict(idRaw, '--id');
1106:     if (incidentId < 1) {
1107:         throw new Error('--id deve essere >= 1');
1108:     }
1109:     await resolveIncident(incidentId);
1110:     console.log(`Incidente ${incidentId} risolto.`);
1111: }
1112: 
1113: async function runPrivacyCleanupCommand(args: string[]): Promise<void> {
1114:     const positional = getPositionalArgs(args);
1115:     const daysRaw = getOptionValue(args, '--days') ?? positional[0];
1116:     const days = daysRaw ? Math.max(7, parseIntStrict(daysRaw, '--days')) : config.retentionDays;
1117:     const result = await cleanupPrivacyData(days);
1118:     console.log(JSON.stringify({ retentionDays: days, ...result }, null, 2));
1119: }
1120: 
1121: async function runCompanyTargetsCommand(args: string[]): Promise<void> {
1122:     const positional = getPositionalArgs(args);
1123:     const listName = getOptionValue(args, '--list') ?? positional[0] ?? null;
1124:     const limitRaw = getOptionValue(args, '--limit') ?? positional[1];
1125:     const limit = limitRaw ? Math.max(1, parseIntStrict(limitRaw, '--limit')) : 50;
1126:     const [total, items] = await Promise.all([
1127:         countCompanyTargets(listName ?? undefined),
1128:         listCompanyTargets(listName, limit),
1129:     ]);
1130:     console.log(JSON.stringify({ list: listName ?? 'all', total, shown: items.length, items }, null, 2));
1131: }
1132: 
1133: async function main(): Promise<void> {
1134:     setupGracefulShutdown();
1135:     const args = process.argv.slice(2);
1136:     const command = args[0];
1137:     const commandArgs = args.slice(1);
1138: 
1139:     await initDatabase();
1140:     const shouldRecoverStuckJobs = command === 'run'
1141:         || command === 'connect'
1142:         || command === 'check'
1143:         || command === 'message'
1144:         || (command === 'run-loop' && !hasOption(commandArgs, '--dry-run'));
1145:     if (shouldRecoverStuckJobs) {
1146:         const recoveredJobs = await recoverStuckJobs(config.jobStuckMinutes);
1147:         if (recoveredJobs > 0) {
1148:             console.warn(`[BOOT] Ripristinati ${recoveredJobs} job RUNNING bloccati da oltre ${config.jobStuckMinutes} minuti.`);
1149:         }
1150:     }
1151: 
1152:     switch (command) {
1153:         case 'import':
1154:             await runImportCommand(commandArgs);
1155:             break;
1156:         case 'run': {
1157:             const workflow = parseWorkflow(getWorkflowValue(commandArgs));
1158:             await runWorkflowCommand(workflow, false);
1159:             break;
1160:         }
1161:         case 'dry-run': {
1162:             const workflow = parseWorkflow(getWorkflowValue(commandArgs));
1163:             await runWorkflowCommand(workflow, true);
1164:             break;
1165:         }
1166:         case 'run-loop':
1167:             await runLoopCommand(commandArgs);
1168:             break;
1169:         case 'autopilot':
1170:             await runAutopilotCommand(commandArgs);
1171:             break;
1172:         case 'login':
1173:             await runLoginCommand(commandArgs);
1174:             break;
1175:         case 'doctor': {
1176:             const report = await runDoctor();
1177:             console.log(JSON.stringify(report, null, 2));
1178:             break;
1179:         }
1180:         case 'funnel':
1181:             await runFunnelCommand();
1182:             break;
1183:         case 'site-check':
1184:             await runSiteCheckCommand(commandArgs);
1185:             break;
1186:         case 'state-sync':
1187:             await runStateSyncCommand(commandArgs);
1188:             break;
1189:         case 'salesnav-sync':
1190:             await runSalesNavSyncCommand(commandArgs);
1191:             break;
1192:         case 'salesnav-lists':
1193:             await runSalesNavListsCommand(commandArgs);
1194:             break;
1195:         case 'salesnav-create-list':
1196:             await runSalesNavCreateListCommand(commandArgs);
1197:             break;
1198:         case 'salesnav-add-lead':
1199:             await runSalesNavAddLeadCommand(commandArgs);
1200:             break;
1201:         case 'salesnav-add-to-list':
1202:             await runSalesNavAddLeadCommand(commandArgs);
1203:             break;
1204:         case 'salesnav-resolve':
1205:             await runSalesNavResolveCommand(commandArgs);
1206:             break;
1207:         case 'enrich-targets':
1208:             await runEnrichTargetsCommand(commandArgs);
1209:             break;
1210:         case 'status':
1211:             await runStatusCommand();
1212:             break;
1213:         case 'proxy-status':
1214:             await runProxyStatusCommand();
1215:             break;
1216:         case 'random-activity':
1217:             await runRandomActivityCommand(commandArgs);
1218:             break;
1219:         case 'pause':
1220:             await runPauseCommand(commandArgs);
1221:             break;
1222:         case 'resume':
1223:             await runResumeCommand();
1224:             break;
1225:         case 'unquarantine':
1226:             await runUnquarantineCommand();
1227:             break;
1228:         case 'incidents': {
1229:             const positional = getPositionalArgs(commandArgs);
1230:             const openOnly = commandArgs.includes('--open') || positional.includes('open') || positional.length === 0;
1231:             if (!openOnly) {
1232:                 console.log('Usa: npm start -- incidents open');
1233:                 break;
1234:             }
1235:             const incidents = await listOpenIncidents();
1236:             console.log(JSON.stringify(incidents, null, 2));
1237:             break;
1238:         }
1239:         case 'incident-resolve':
1240:             await runResolveIncidentCommand(commandArgs);
1241:             break;
1242:         case 'privacy-cleanup':
1243:             await runPrivacyCleanupCommand(commandArgs);
1244:             break;
1245:         case 'lists': {
1246:             const lists = await listLeadCampaignConfigs(false);
1247:             console.log(JSON.stringify(lists, null, 2));
1248:             break;
1249:         }
1250:         case 'company-targets':
1251:             await runCompanyTargetsCommand(commandArgs);
1252:             break;
1253:         case 'list-config': {
1254:             const positional = getPositionalArgs(commandArgs);
1255:             const listName = getOptionValue(commandArgs, '--list') ?? positional[0];
1256:             if (!listName) {
1257:                 throw new Error('Specifica la lista: npm start -- list-config --list <nome_lista> ...');
1258:             }
1259: 
1260:             const patch: {
1261:                 priority?: number;
1262:                 dailyInviteCap?: number | null;
1263:                 dailyMessageCap?: number | null;
1264:                 isActive?: boolean;
1265:             } = {};
1266: 
1267:             const priorityRaw = getOptionValue(commandArgs, '--priority') ?? positional[1];
1268:             if (hasOption(commandArgs, '--priority') || priorityRaw !== undefined) {
1269:                 const raw = priorityRaw;
1270:                 if (!raw) throw new Error('Manca valore per --priority');
1271:                 const parsed = parseIntStrict(raw, '--priority');
1272:                 if (parsed < 1) throw new Error('--priority deve essere >= 1');
1273:                 patch.priority = parsed;
1274:             }
1275:             const inviteCapRaw = getOptionValue(commandArgs, '--invite-cap') ?? positional[2];
1276:             if (hasOption(commandArgs, '--invite-cap') || inviteCapRaw !== undefined) {
1277:                 const raw = inviteCapRaw;
1278:                 if (!raw) throw new Error('Manca valore per --invite-cap');
1279:                 patch.dailyInviteCap = parseNullableCap(raw, '--invite-cap');
1280:             }
1281:             const messageCapRaw = getOptionValue(commandArgs, '--message-cap') ?? positional[3];
1282:             if (hasOption(commandArgs, '--message-cap') || messageCapRaw !== undefined) {
1283:                 const raw = messageCapRaw;
1284:                 if (!raw) throw new Error('Manca valore per --message-cap');
1285:                 patch.dailyMessageCap = parseNullableCap(raw, '--message-cap');
1286:             }
1287:             const activeRaw = getOptionValue(commandArgs, '--active') ?? positional[4];
1288:             if (hasOption(commandArgs, '--active') || activeRaw !== undefined) {
1289:                 const raw = activeRaw;
1290:                 if (!raw) throw new Error('Manca valore per --active');
1291:                 patch.isActive = parseBoolStrict(raw, '--active');
1292:             }
1293: 
1294:             const updated = await updateLeadCampaignConfig(listName, patch);
1295:             console.log(JSON.stringify(updated, null, 2));
1296:             break;
1297:         }
1298:         case 'sync-status': {
1299:             const status = await getEventSyncStatus();
1300:             console.log(JSON.stringify(status, null, 2));
1301:             break;
1302:         }
1303:         case 'sync-run-once':
1304:             await runEventSyncOnce();
1305:             console.log('Sync eventi completato.');
1306:             break;
1307:         case 'connect':
1308:             await runWorkflowCommand('invite', false);
1309:             break;
1310:         case 'check':
1311:             await runWorkflowCommand('check', false);
1312:             break;
1313:         case 'message':
1314:             await runWorkflowCommand('message', false);
1315:             break;
1316:         default:
1317:             printHelp();
1318:             break;
1319:     }
1320: }
1321: 
1322: main()
1323:     .catch((error) => {
1324:         console.error('[FATAL]', error);
1325:         process.exitCode = 1;
1326:     })
1327:     .finally(async () => {
1328:         await closeDatabase();
1329:     });
````

## File: src/selectors.ts
````typescript
 1: /**
 2:  * Centralized selectors with progressive fallbacks.
 3:  */
 4: export const SELECTORS = {
 5:     globalNav: '.global-nav__me, [data-test-global-nav-me] button',
 6: 
 7:     connectButtonPrimary: [
 8:         'button.artdeco-button--primary:has-text("Connect")',
 9:         'button.artdeco-button--primary:has-text("Collegati")',
10:     ].join(', '),
11: 
12:     moreActionsButton: [
13:         'button[aria-label="More actions"]',
14:         'button[aria-label="Altre azioni"]',
15:         'button.artdeco-dropdown__trigger:has-text("More")',
16:         'button.artdeco-dropdown__trigger:has-text("Altro")',
17:     ].join(', '),
18: 
19:     connectInMoreMenu: [
20:         'div.artdeco-dropdown__content-inner li button:has-text("Connect")',
21:         'div.artdeco-dropdown__content-inner li button:has-text("Collegati")',
22:     ].join(', '),
23: 
24:     sendWithoutNote: [
25:         'button[aria-label="Send without a note"]',
26:         'button[aria-label="Invia senza nota"]',
27:     ].join(', '),
28: 
29:     sendFallback: [
30:         'button.artdeco-button--primary:has-text("Send")',
31:         'button.artdeco-button--primary:has-text("Invia")',
32:     ].join(', '),
33: 
34:     invitePendingIndicators: [
35:         'button:has-text("Pending")',
36:         'button:has-text("In attesa")',
37:         'button[aria-label*="Pending"]',
38:     ].join(', '),
39: 
40:     messageButton: [
41:         'button[aria-label^="Message"]',
42:         'button[aria-label^="Invia messaggio"]',
43:         'a.message-anywhere-button',
44:     ].join(', '),
45: 
46:     distanceBadge: [
47:         'span.dist-value',
48:         'span[aria-hidden="true"]:has-text("1st")',
49:         'span[aria-hidden="true"]:has-text("1°")',
50:     ].join(', '),
51: 
52:     messageTextbox: [
53:         'div.msg-form__contenteditable[role="textbox"]',
54:         'div[contenteditable="true"][role="textbox"]',
55:     ].join(', '),
56: 
57:     messageSendButton: [
58:         'button.msg-form__send-button',
59:         'button:has-text("Send")',
60:         'button:has-text("Invia")',
61:     ].join(', '),
62: 
63:     challengeSignals: [
64:         'input[name="captcha"]',
65:         'iframe[src*="captcha"]',
66:         'form[action*="checkpoint"]',
67:         'h1:has-text("Security verification")',
68:         'h1:has-text("Verifica")',
69:         'div:has-text("temporarily blocked")',
70:         'div:has-text("temporaneamente bloccato")',
71:     ].join(', '),
72: 
73:     addNoteButton: [
74:         'button[aria-label="Add a note"]',
75:         'button[aria-label="Aggiungi una nota"]',
76:         'button:has-text("Add a note")',
77:         'button:has-text("Aggiungi una nota")',
78:     ].join(', '),
79: 
80:     noteTextarea: [
81:         'div[role="dialog"] textarea',
82:         'div[role="dialog"] input[type="text"]',
83:     ].join(', '),
84: 
85:     sendWithNote: [
86:         'div[role="dialog"] button[aria-label="Send invitation"]',
87:         'div[role="dialog"] button[aria-label="Invia invito"]',
88:         'div[role="dialog"] button.artdeco-button--primary:has-text("Send")',
89:         'div[role="dialog"] button.artdeco-button--primary:has-text("Invia")',
90:     ].join(', '),
91: 
92:     inviteWeeklyLimitSignals: [
93:         'div:has-text("weekly invitation limit")',
94:         'span:has-text("weekly invitation limit")',
95:         'div:has-text("limite settimanale")',
96:         'span:has-text("limite settimanale")',
97:     ].join(', '),
98: };
````

## File: src/tests/integration.ts
````typescript
  1: import assert from 'assert';
  2: import fs from 'fs';
  3: import path from 'path';
  4: 
  5: async function run(): Promise<void> {
  6:     const testDbPath = path.resolve(process.cwd(), 'data', 'test_integration.sqlite');
  7:     if (fs.existsSync(testDbPath)) {
  8:         fs.unlinkSync(testDbPath);
  9:     }
 10: 
 11:     process.env.DB_PATH = testDbPath;
 12:     process.env.SUPABASE_SYNC_ENABLED = 'false';
 13:     process.env.SELECTOR_CANARY_ENABLED = 'false';
 14: 
 15:     const dbModule = await import('../db');
 16:     const repositories = await import('../core/repositories');
 17:     const stateService = await import('../core/leadStateService');
 18: 
 19:     await dbModule.initDatabase();
 20: 
 21:     const inserted = await repositories.addLead({
 22:         accountName: 'Rossi Srl',
 23:         firstName: 'Mario',
 24:         lastName: 'Rossi',
 25:         jobTitle: 'CEO',
 26:         website: 'https://example.com',
 27:         linkedinUrl: 'https://www.linkedin.com/in/mario-rossi-test/',
 28:         listName: 'test-list',
 29:     });
 30:     assert.equal(inserted, true);
 31: 
 32:     const syncedLeadInsert = await repositories.upsertSalesNavigatorLead({
 33:         accountName: 'Sales Co',
 34:         firstName: 'Luca',
 35:         lastName: 'Verdi',
 36:         jobTitle: 'Head of Sales',
 37:         website: '',
 38:         linkedinUrl: 'https://www.linkedin.com/in/luca-verdi-sync-test/',
 39:         listName: 'sales-list',
 40:     });
 41:     assert.equal(syncedLeadInsert.action, 'inserted');
 42: 
 43:     const syncedLeadUpdate = await repositories.upsertSalesNavigatorLead({
 44:         accountName: 'Sales Company Spa',
 45:         firstName: 'Luca',
 46:         lastName: 'Verdi',
 47:         jobTitle: 'VP Sales',
 48:         website: '',
 49:         linkedinUrl: 'https://www.linkedin.com/in/luca-verdi-sync-test/',
 50:         listName: 'sales-list-updated',
 51:     });
 52:     assert.equal(syncedLeadUpdate.action === 'updated' || syncedLeadUpdate.action === 'unchanged', true);
 53: 
 54:     const syncedLead = await repositories.getLeadByLinkedinUrl('https://www.linkedin.com/in/luca-verdi-sync-test/');
 55:     assert.ok(syncedLead);
 56:     if (!syncedLead) {
 57:         throw new Error('Lead sincronizzato non trovato');
 58:     }
 59:     assert.equal(syncedLead.list_name, 'sales-list-updated');
 60: 
 61:     const salesNavList = await repositories.upsertSalesNavList(
 62:         'sales-list-updated',
 63:         'https://www.linkedin.com/sales/lists/people/123456789/'
 64:     );
 65:     await repositories.linkLeadToSalesNavList(salesNavList.id, syncedLead.id);
 66:     const salesNavLists = await repositories.listSalesNavLists(10);
 67:     const linkedSalesList = salesNavLists.find((item) => item.id === salesNavList.id);
 68:     assert.ok(linkedSalesList);
 69:     assert.equal((linkedSalesList?.leads_count ?? 0) >= 1, true);
 70: 
 71:     await repositories.promoteNewLeadsToReadyInvite(10);
 72:     const ready = await repositories.getLeadsByStatus('READY_INVITE', 10);
 73:     assert.equal(ready.length >= 1, true);
 74: 
 75:     const lead = ready.find((row) => row.linkedin_url.includes('/in/mario-rossi-test/')) ?? ready[0];
 76:     await stateService.transitionLead(lead.id, 'INVITED', 'integration_invite');
 77:     const invited = await repositories.getLeadsByStatus('INVITED', 10);
 78:     assert.equal(invited.length, 1);
 79: 
 80:     await stateService.reconcileLeadStatus(lead.id, 'READY_INVITE', 'integration_reconcile_back');
 81:     const readyAgain = await repositories.getLeadsByStatus('READY_INVITE', 10);
 82:     assert.equal(readyAgain.some((row) => row.id === lead.id), true);
 83:     await stateService.transitionLead(lead.id, 'INVITED', 'integration_invite_again');
 84: 
 85:     const queued = await repositories.enqueueJob(
 86:         'INVITE',
 87:         { leadId: lead.id, localDate: '2026-02-24' },
 88:         `invite:${lead.id}:2026-02-24`,
 89:         10,
 90:         3
 91:     );
 92:     assert.equal(queued, true);
 93: 
 94:     const locked = await repositories.lockNextQueuedJob(['INVITE']);
 95:     assert.ok(locked);
 96:     if (!locked) {
 97:         throw new Error('Lock job fallito');
 98:     }
 99:     await repositories.markJobSucceeded(locked.id);
100: 
101:     const dailyInvites = await repositories.getDailyStat('2026-02-24', 'invites_sent');
102:     assert.equal(dailyInvites, 0);
103: 
104:     const lockA = await repositories.acquireRuntimeLock('integration.runner.lock', 'owner-a', 5, { source: 'integration' });
105:     assert.equal(lockA.acquired, true);
106: 
107:     const lockBBlocked = await repositories.acquireRuntimeLock('integration.runner.lock', 'owner-b', 5, { source: 'integration' });
108:     assert.equal(lockBBlocked.acquired, false);
109:     assert.equal(lockBBlocked.lock?.owner_id, 'owner-a');
110: 
111:     const heartbeatOk = await repositories.heartbeatRuntimeLock('integration.runner.lock', 'owner-a', 5);
112:     assert.equal(heartbeatOk, true);
113: 
114:     const releasedByWrongOwner = await repositories.releaseRuntimeLock('integration.runner.lock', 'owner-b');
115:     assert.equal(releasedByWrongOwner, false);
116: 
117:     const releasedByOwner = await repositories.releaseRuntimeLock('integration.runner.lock', 'owner-a');
118:     assert.equal(releasedByOwner, true);
119: 
120:     const staleLock = await repositories.acquireRuntimeLock('integration.stale.lock', 'owner-a', 1, { source: 'integration' });
121:     assert.equal(staleLock.acquired, true);
122:     await new Promise((resolve) => setTimeout(resolve, 2100));
123: 
124:     const staleTakeover = await repositories.acquireRuntimeLock('integration.stale.lock', 'owner-b', 5, { source: 'integration' });
125:     assert.equal(staleTakeover.acquired, true);
126:     assert.equal(staleTakeover.lock?.owner_id, 'owner-b');
127: 
128:     const delayedQueued = await repositories.enqueueJob(
129:         'INVITE',
130:         { leadId: lead.id, localDate: '2026-02-24' },
131:         `invite:${lead.id}:delayed`,
132:         10,
133:         3,
134:         60
135:     );
136:     assert.equal(delayedQueued, true);
137:     const delayedLocked = await repositories.lockNextQueuedJob(['INVITE']);
138:     assert.equal(delayedLocked, null);
139: 
140:     const accountQueuedA = await repositories.enqueueJob(
141:         'INVITE',
142:         { leadId: lead.id, localDate: '2026-02-25' },
143:         `invite:${lead.id}:account-a`,
144:         10,
145:         3,
146:         0,
147:         'acc-a'
148:     );
149:     assert.equal(accountQueuedA, true);
150: 
151:     const accountQueuedB = await repositories.enqueueJob(
152:         'MESSAGE',
153:         { leadId: lead.id, acceptedAtDate: '2026-02-25' },
154:         `message:${lead.id}:account-b`,
155:         10,
156:         3,
157:         0,
158:         'acc-b'
159:     );
160:     assert.equal(accountQueuedB, true);
161: 
162:     const lockedAccA = await repositories.lockNextQueuedJob(['INVITE', 'MESSAGE'], 'acc-a');
163:     assert.ok(lockedAccA);
164:     if (!lockedAccA) {
165:         throw new Error('Lock job acc-a fallito');
166:     }
167:     assert.equal(lockedAccA.account_id, 'acc-a');
168:     await repositories.markJobSucceeded(lockedAccA.id);
169: 
170:     const lockedAccB = await repositories.lockNextQueuedJob(['INVITE', 'MESSAGE'], 'acc-b');
171:     assert.ok(lockedAccB);
172:     if (!lockedAccB) {
173:         throw new Error('Lock job acc-b fallito');
174:     }
175:     assert.equal(lockedAccB.account_id, 'acc-b');
176:     await repositories.markJobSucceeded(lockedAccB.id);
177: 
178:     await dbModule.closeDatabase();
179:     if (fs.existsSync(testDbPath)) {
180:         fs.unlinkSync(testDbPath);
181:     }
182: }
183: 
184: run()
185:     .then(() => {
186:         console.log('Integration tests passed.');
187:     })
188:     .catch((error) => {
189:         console.error(error);
190:         process.exit(1);
191:     });
````

## File: src/workers/inviteWorker.ts
````typescript
  1: import { Page } from 'playwright';
  2: import { detectChallenge, humanDelay, humanMouseMove, humanType, simulateHumanReading } from '../browser';
  3: import { transitionLead } from '../core/leadStateService';
  4: import { getLeadById, incrementDailyStat, incrementListDailyStat } from '../core/repositories';
  5: import { SELECTORS } from '../selectors';
  6: import { InviteJobPayload, LeadRecord } from '../types/domain';
  7: import { WorkerContext } from './context';
  8: import { ChallengeDetectedError, RetryableWorkerError } from './errors';
  9: import { isSalesNavigatorUrl } from '../linkedinUrl';
 10: import { config } from '../config';
 11: import { buildPersonalizedInviteNote } from '../ai/inviteNotePersonalizer';
 12: import { pauseAutomation } from '../risk/incidentManager';
 13: 
 14: async function clickConnectOnProfile(page: Page): Promise<boolean> {
 15:     const primaryBtn = page.locator(SELECTORS.connectButtonPrimary).first();
 16:     if (await primaryBtn.count() > 0) {
 17:         await humanMouseMove(page, SELECTORS.connectButtonPrimary);
 18:         await humanDelay(page, 120, 320);
 19:         await primaryBtn.click();
 20:         return true;
 21:     }
 22: 
 23:     const moreBtn = page.locator(SELECTORS.moreActionsButton).first();
 24:     if (await moreBtn.count() > 0) {
 25:         await humanMouseMove(page, SELECTORS.moreActionsButton);
 26:         await humanDelay(page, 120, 300);
 27:         await moreBtn.click();
 28:         await humanDelay(page, 700, 1300);
 29:         const connectInMenu = page.locator(SELECTORS.connectInMoreMenu).first();
 30:         if (await connectInMenu.count() > 0) {
 31:             await humanMouseMove(page, SELECTORS.connectInMoreMenu);
 32:             await humanDelay(page, 120, 300);
 33:             await connectInMenu.click();
 34:             return true;
 35:         }
 36:     }
 37: 
 38:     return false;
 39: }
 40: 
 41: async function detectInviteProof(page: Page): Promise<boolean> {
 42:     const pendingCount = await page.locator(SELECTORS.invitePendingIndicators).count();
 43:     if (pendingCount > 0) {
 44:         return true;
 45:     }
 46: 
 47:     const pageText = await page.textContent('body').catch(() => '');
 48:     if (!pageText) {
 49:         return false;
 50:     }
 51:     return /invitation sent|in attesa|pending/i.test(pageText);
 52: }
 53: 
 54: async function detectWeeklyInviteLimit(page: Page): Promise<boolean> {
 55:     const selectorCount = await page.locator(SELECTORS.inviteWeeklyLimitSignals).count();
 56:     if (selectorCount > 0) {
 57:         return true;
 58:     }
 59: 
 60:     const pageText = await page.textContent('body').catch(() => '');
 61:     if (!pageText) {
 62:         return false;
 63:     }
 64:     return /weekly invitation limit|limite settimanale(?: degli)? inviti|hai raggiunto il limite settimanale/i.test(pageText);
 65: }
 66: 
 67: /**
 68:  * Tenta di inviare l'invito con nota personalizzata (se INVITE_WITH_NOTE=true).
 69:  * Flusso:
 70:  *   1. Cerca il bottone "Add a note" nel modale
 71:  *   2. Scrive la nota via humanType
 72:  *   3. Clicca "Send" dal modale
 73:  * Se il bottone "Add a note" non è presente, ricade su sendWithoutNote.
 74:  * Ritorna se l'invio è avvenuto con nota e la source della nota (template/ai).
 75:  */
 76: async function handleInviteModal(
 77:     page: Page,
 78:     lead: LeadRecord,
 79:     dryRun: boolean,
 80:     localDate: string,
 81: ): Promise<{ sentWithNote: boolean; noteSource: 'template' | 'ai' | null }> {
 82:     if (dryRun) return { sentWithNote: false, noteSource: null };
 83: 
 84:     // Controlla se c'è il bottone "Add a note" (con retry breve se il modale sta caricando)
 85:     const addNoteBtn = page.locator(SELECTORS.addNoteButton).first();
 86:     let canAddNote = await addNoteBtn.count() > 0;
 87:     if (config.inviteWithNote && !canAddNote) {
 88:         await page.waitForSelector(SELECTORS.addNoteButton, { timeout: 2000 }).catch(() => null);
 89:         canAddNote = await addNoteBtn.count() > 0;
 90:     }
 91: 
 92:     if (config.inviteWithNote && canAddNote) {
 93:         await humanMouseMove(page, SELECTORS.addNoteButton);
 94:         await humanDelay(page, 150, 350);
 95:         await addNoteBtn.click();
 96:         await humanDelay(page, 600, 1200);
 97: 
 98:         // Scrivi la nota nella textarea del modale
 99:         const personalizedNote = await buildPersonalizedInviteNote(lead);
100:         const note = personalizedNote.note;
101:         const textarea = page.locator(SELECTORS.noteTextarea).first();
102:         if (await textarea.count() > 0) {
103:             await humanType(page, SELECTORS.noteTextarea, note);
104:             await humanDelay(page, 500, 1000);
105:         }
106: 
107:         // Clicca il tasto Send del modale
108:         const sendNoteBtn = page.locator(SELECTORS.sendWithNote).first();
109:         if (await sendNoteBtn.count() > 0) {
110:             await humanMouseMove(page, SELECTORS.sendWithNote);
111:             await humanDelay(page, 120, 320);
112:             await sendNoteBtn.click();
113:             return { sentWithNote: true, noteSource: personalizedNote.source };
114:         }
115: 
116:         // Se il bottone Send del modale non è trovato, è un errore bloccante
117:         await incrementDailyStat(localDate, 'selector_failures');
118:         throw new RetryableWorkerError('Send con nota non trovato nel modale', 'SEND_WITH_NOTE_NOT_FOUND');
119:     }
120: 
121:     // Fallback: invia senza nota
122:     const sendWithoutNote = page.locator(SELECTORS.sendWithoutNote).first();
123:     if (await sendWithoutNote.count() > 0) {
124:         await humanMouseMove(page, SELECTORS.sendWithoutNote);
125:         await humanDelay(page, 120, 300);
126:         await sendWithoutNote.click();
127:         return { sentWithNote: false, noteSource: null };
128:     }
129: 
130:     const fallback = page.locator(SELECTORS.sendFallback).first();
131:     if (await fallback.count() > 0) {
132:         await humanMouseMove(page, SELECTORS.sendFallback);
133:         await humanDelay(page, 120, 300);
134:         await fallback.click();
135:         return { sentWithNote: false, noteSource: null };
136:     }
137: 
138:     await incrementDailyStat(localDate, 'selector_failures');
139:     throw new RetryableWorkerError('Conferma invito senza nota non trovata', 'SEND_BUTTON_NOT_FOUND');
140: }
141: 
142: export async function processInviteJob(payload: InviteJobPayload, context: WorkerContext): Promise<void> {
143:     const lead = await getLeadById(payload.leadId);
144:     if (!lead) {
145:         throw new RetryableWorkerError(`Lead ${payload.leadId} non trovato`, 'LEAD_NOT_FOUND');
146:     }
147: 
148:     if (lead.status === 'NEW' || lead.status === 'PENDING') {
149:         await transitionLead(lead.id, 'READY_INVITE', 'new_lead_promoted');
150:     }
151: 
152:     if (lead.status !== 'READY_INVITE' && lead.status !== 'NEW' && lead.status !== 'PENDING') {
153:         return;
154:     }
155: 
156:     if (isSalesNavigatorUrl(lead.linkedin_url)) {
157:         await transitionLead(lead.id, 'BLOCKED', 'salesnav_url_requires_profile_invite');
158:         return;
159:     }
160: 
161:     await context.session.page.goto(lead.linkedin_url, { waitUntil: 'domcontentloaded' });
162:     await simulateHumanReading(context.session.page);
163: 
164:     if (await detectChallenge(context.session.page)) {
165:         throw new ChallengeDetectedError();
166:     }
167: 
168:     const connectClicked = await clickConnectOnProfile(context.session.page);
169:     if (!connectClicked) {
170:         await incrementDailyStat(context.localDate, 'selector_failures');
171:         await transitionLead(lead.id, 'SKIPPED', 'connect_not_found');
172:         return;
173:     }
174: 
175:     await humanDelay(context.session.page, 900, 1800);
176: 
177:     const inviteResult = await handleInviteModal(
178:         context.session.page,
179:         lead,
180:         context.dryRun,
181:         context.localDate,
182:     );
183: 
184:     if (!context.dryRun) {
185:         const weeklyLimitReached = await detectWeeklyInviteLimit(context.session.page);
186:         if (weeklyLimitReached) {
187:             await pauseAutomation(
188:                 'WEEKLY_INVITE_LIMIT_REACHED',
189:                 {
190:                     leadId: lead.id,
191:                     linkedinUrl: lead.linkedin_url,
192:                     accountId: context.accountId,
193:                 },
194:                 7 * 24 * 60
195:             );
196:             throw new RetryableWorkerError('Limite settimanale inviti raggiunto', 'WEEKLY_LIMIT_REACHED');
197:         }
198:     }
199: 
200:     await humanDelay(context.session.page, 1200, 2200);
201:     const proofOfSend = context.dryRun ? true : await detectInviteProof(context.session.page);
202:     if (!proofOfSend) {
203:         throw new RetryableWorkerError('Proof-of-send non rilevato', 'NO_PROOF_OF_SEND');
204:     }
205: 
206:     await transitionLead(lead.id, 'INVITED', context.dryRun ? 'invite_dry_run' : 'invite_sent', {
207:         dryRun: context.dryRun,
208:         withNote: inviteResult.sentWithNote,
209:         withNoteSource: inviteResult.noteSource,
210:     });
211:     await incrementDailyStat(context.localDate, 'invites_sent');
212:     await incrementListDailyStat(context.localDate, lead.list_name, 'invites_sent');
213: }
````
