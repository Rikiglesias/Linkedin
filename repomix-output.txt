This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where line numbers have been added.

# File Summary

## Purpose
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A header with the file path (## File: path/to/file)
  b. The full contents of the file in a code block

## Usage Guidelines
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
- Pay special attention to the Repository Description. These contain important context and guidelines specific to this project.

## Notes
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: src/**/*, package.json, tsconfig.json, eslint.config.js, .env.example, ROADMAP.md, INTEGRATIONS.md, SECURITY.md
- Files matching these patterns are excluded: node_modules/**, dist/**, data/**, .env, *.log, package-lock.json, repomix-output.txt, .git/**
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Line numbers have been added to the beginning of each line
- Files are sorted by Git change count (files with more changes are at the bottom)

# User Provided Header
LinkedIn Bot Codebase - Condiviso per analisi AI

# Directory Structure
```
.env.example
eslint.config.js
INTEGRATIONS.md
package.json
ROADMAP.md
SECURITY.md
src/acceptanceChecker.ts
src/accountManager.ts
src/ai/guardian.ts
src/ai/inviteNotePersonalizer.ts
src/ai/leadScorer.ts
src/ai/messagePersonalizer.ts
src/ai/openaiClient.ts
src/ai/semanticChecker.ts
src/ai/sentimentAnalysis.ts
src/api/server.ts
src/browser.ts
src/cloud/cloudBridge.ts
src/cloud/controlPlaneSync.ts
src/cloud/supabaseDataClient.ts
src/cloud/telegramListener.ts
src/config.ts
src/connectWorkflow.ts
src/core/audit.ts
src/core/companyEnrichment.ts
src/core/doctor.ts
src/core/jobRunner.ts
src/core/leadStateService.ts
src/core/orchestrator.ts
src/core/repositories.ts
src/core/salesNavigatorSync.ts
src/core/scheduler.ts
src/core/sessionWarmer.ts
src/csvImporter.ts
src/db.ts
src/db/migrations/001_core.sql
src/db/migrations/002_legacy_status_backfill.sql
src/db/migrations/003_add_person_fields.sql
src/db/migrations/004_list_campaign_controls.sql
src/db/migrations/005_performance_indexes.sql
src/db/migrations/006_company_targets.sql
src/db/migrations/007_company_target_tracking.sql
src/db/migrations/008_runtime_locks.sql
src/db/migrations/009_site_check_tracking.sql
src/db/migrations/010_salesnav_lists.sql
src/db/migrations/011_daily_stats_acceptances.sql
src/db/migrations/012_ai_profile_and_prompt_variants.sql
src/db/migrations/013_lead_scoring.sql
src/db/migrations/014_campaign_runs.sql
src/index.ts
src/linkedinUrl.ts
src/messages.ts
src/messagingWorkflow.ts
src/models.ts
src/noteGenerator.ts
src/proxyManager.ts
src/risk/incidentManager.ts
src/risk/riskEngine.ts
src/salesnav/listActions.ts
src/salesnav/listScraper.ts
src/scripts/rampUp.ts
src/security/filesystem.ts
src/security/redaction.ts
src/selectors.ts
src/sync/eventSync.ts
src/sync/supabase.full.schema.sql
src/sync/supabase.schema.sql
src/sync/supabaseSyncWorker.ts
src/sync/webhookSyncWorker.ts
src/telemetry/alerts.ts
src/telemetry/dailyReporter.ts
src/telemetry/kpiReporter.ts
src/telemetry/logger.ts
src/tests/e2eDry.ts
src/tests/integration.ts
src/tests/unit.ts
src/types/domain.ts
src/validation/messageValidator.ts
src/workers/acceptanceWorker.ts
src/workers/context.ts
src/workers/errors.ts
src/workers/hygieneWorker.ts
src/workers/inboxWorker.ts
src/workers/inviteWorker.ts
src/workers/messageWorker.ts
src/workers/randomActivityWorker.ts
tsconfig.json
```

# Files

## File: eslint.config.js
````javascript
 1: const typescriptEslintEslintPlugin = require("@typescript-eslint/eslint-plugin");
 2: const typescriptEslintParser = require("@typescript-eslint/parser");
 3: 
 4: module.exports = [
 5:     {
 6:         files: ["**/*.ts"],
 7:         languageOptions: {
 8:             parser: typescriptEslintParser,
 9:             parserOptions: {
10:                 ecmaVersion: "latest",
11:                 sourceType: "module",
12:             },
13:         },
14:         plugins: {
15:             "@typescript-eslint": typescriptEslintEslintPlugin,
16:         },
17:         rules: {
18:             "no-console": "off",
19:             "@typescript-eslint/no-unused-vars": "error",
20:             "@typescript-eslint/no-explicit-any": "error",
21:             "semi": ["error", "always"]
22:         },
23:     },
24: ];
````

## File: src/acceptanceChecker.ts
````typescript
1: import { runWorkflow } from './core/orchestrator';
2: 
3: export async function runAcceptanceChecker(): Promise<void> {
4:     await runWorkflow({
5:         workflow: 'check',
6:         dryRun: false,
7:     });
8: }
````

## File: src/accountManager.ts
````typescript
  1: import { AccountProfileConfig, config } from './config';
  2: import { ProxyConfig } from './proxyManager';
  3: 
  4: export interface RuntimeAccountProfile {
  5:     id: string;
  6:     sessionDir: string;
  7:     proxy?: ProxyConfig;
  8: }
  9: 
 10: function parseProxyConfig(profile: AccountProfileConfig): ProxyConfig | undefined {
 11:     const rawUrl = profile.proxyUrl.trim();
 12:     if (!rawUrl) {
 13:         return undefined;
 14:     }
 15: 
 16:     const normalizedUrl = /^[a-zA-Z][a-zA-Z\d+.-]*:\/\//.test(rawUrl) ? rawUrl : `http://${rawUrl}`;
 17:     let server = normalizedUrl;
 18:     let username = profile.proxyUsername.trim() || undefined;
 19:     let password = profile.proxyPassword.trim() || undefined;
 20: 
 21:     try {
 22:         const parsed = new URL(normalizedUrl);
 23:         server = `${parsed.protocol}//${parsed.host}`;
 24:         if (!username && parsed.username) {
 25:             username = decodeURIComponent(parsed.username);
 26:         }
 27:         if (!password && parsed.password) {
 28:             password = decodeURIComponent(parsed.password);
 29:         }
 30:     } catch {
 31:         // Manteniamo rawUrl cos√¨ com'√®: Playwright valuter√† la validit√† lato launch.
 32:     }
 33: 
 34:     return {
 35:         server,
 36:         username,
 37:         password,
 38:     };
 39: }
 40: 
 41: function toRuntimeProfile(profile: AccountProfileConfig): RuntimeAccountProfile {
 42:     const fallbackId = 'default';
 43:     const trimmedId = profile.id.trim();
 44:     return {
 45:         id: trimmedId || fallbackId,
 46:         sessionDir: profile.sessionDir,
 47:         proxy: parseProxyConfig(profile),
 48:     };
 49: }
 50: 
 51: function dedupeById(profiles: RuntimeAccountProfile[]): RuntimeAccountProfile[] {
 52:     const unique = new Map<string, RuntimeAccountProfile>();
 53:     for (const profile of profiles) {
 54:         if (!unique.has(profile.id)) {
 55:             unique.set(profile.id, profile);
 56:         }
 57:     }
 58:     return Array.from(unique.values());
 59: }
 60: 
 61: function getConfiguredRuntimeProfiles(): RuntimeAccountProfile[] {
 62:     const runtime = config.accountProfiles.map(toRuntimeProfile);
 63:     const deduped = dedupeById(runtime);
 64:     return deduped.slice(0, 2);
 65: }
 66: 
 67: export function getRuntimeAccountProfiles(): RuntimeAccountProfile[] {
 68:     const configured = getConfiguredRuntimeProfiles();
 69:     if (!config.multiAccountEnabled || configured.length === 0) {
 70:         return [{
 71:             id: 'default',
 72:             sessionDir: config.sessionDir,
 73:         }];
 74:     }
 75:     return configured;
 76: }
 77: 
 78: export function isMultiAccountRuntimeEnabled(): boolean {
 79:     return config.multiAccountEnabled && getRuntimeAccountProfiles().length > 1;
 80: }
 81: 
 82: export function getSchedulingAccountIds(): string[] {
 83:     return getRuntimeAccountProfiles().map((profile) => profile.id);
 84: }
 85: 
 86: export function pickAccountIdForLead(leadId: number): string {
 87:     const accountIds = getSchedulingAccountIds();
 88:     if (accountIds.length === 0) {
 89:         return 'default';
 90:     }
 91:     if (accountIds.length === 1) {
 92:         return accountIds[0];
 93:     }
 94: 
 95:     const normalizedLeadId = Number.isFinite(leadId) ? Math.abs(Math.trunc(leadId)) : 0;
 96:     const index = normalizedLeadId % accountIds.length;
 97:     return accountIds[index] ?? accountIds[0];
 98: }
 99: 
100: export function getAccountProfileById(accountId: string | null | undefined): RuntimeAccountProfile {
101:     const accounts = getRuntimeAccountProfiles();
102:     if (accounts.length === 0) {
103:         return {
104:             id: 'default',
105:             sessionDir: config.sessionDir,
106:         };
107:     }
108:     if (!accountId) {
109:         return accounts[0];
110:     }
111:     const found = accounts.find((profile) => profile.id === accountId);
112:     return found ?? accounts[0];
113: }
````

## File: src/ai/guardian.ts
````typescript
  1: import { config } from '../config';
  2: import { ScheduleResult, WorkflowSelection } from '../core/scheduler';
  3: import { getRuntimeFlag, setRuntimeFlag } from '../core/repositories';
  4: import { requestOpenAIText } from './openaiClient';
  5: 
  6: const AI_GUARDIAN_LAST_RUN_AT_KEY = 'ai_guardian.last_run_at';
  7: 
  8: export type AiGuardianSeverity = 'normal' | 'watch' | 'critical';
  9: 
 10: export interface AiGuardianDecision {
 11:     source: 'heuristic' | 'ai';
 12:     severity: AiGuardianSeverity;
 13:     summary: string;
 14:     recommendations: string[];
 15:     pauseMinutes: number;
 16: }
 17: 
 18: export interface AiGuardianResult {
 19:     executed: boolean;
 20:     reason: string;
 21:     decision: AiGuardianDecision | null;
 22: }
 23: 
 24: interface ParsedAiGuardianPayload {
 25:     severity: AiGuardianSeverity;
 26:     summary: string;
 27:     recommendations: string[];
 28:     pauseMinutes: number;
 29: }
 30: 
 31: function clampPauseMinutes(value: number): number {
 32:     const parsed = Number.isFinite(value) ? Math.floor(value) : 0;
 33:     if (parsed <= 0) return 0;
 34:     return Math.min(24 * 60, parsed);
 35: }
 36: 
 37: function heuristics(schedule: ScheduleResult): AiGuardianDecision {
 38:     const criticalList = schedule.listBreakdown.find(
 39:         (list) => list.pendingRatio >= 0.78 || list.blockedRatio >= 0.35
 40:     );
 41: 
 42:     if (schedule.riskSnapshot.action === 'STOP' || criticalList) {
 43:         return {
 44:             source: 'heuristic',
 45:             severity: 'critical',
 46:             summary: 'Rischio elevato rilevato prima dell‚Äôesecuzione.',
 47:             recommendations: [
 48:                 'Pausa automatica e controllo manuale account.',
 49:                 'Ridurre limiti giornalieri su inviti e messaggi.',
 50:                 'Eseguire site-check con --fix prima della ripartenza.',
 51:             ],
 52:             pauseMinutes: config.aiGuardianPauseMinutes,
 53:         };
 54:     }
 55: 
 56:     if (
 57:         schedule.riskSnapshot.action === 'WARN'
 58:         || schedule.riskSnapshot.pendingRatio >= config.pendingRatioWarn
 59:         || schedule.riskSnapshot.errorRate >= 0.2
 60:     ) {
 61:         return {
 62:             source: 'heuristic',
 63:             severity: 'watch',
 64:             summary: 'Rischio intermedio: conviene rallentare e monitorare.',
 65:             recommendations: [
 66:                 'Ridurre volume inviti nel prossimo ciclo.',
 67:                 'Aumentare intervallo loop e verificare mismatch DB/sito.',
 68:             ],
 69:             pauseMinutes: 0,
 70:         };
 71:     }
 72: 
 73:     return {
 74:         source: 'heuristic',
 75:         severity: 'normal',
 76:         summary: 'Situazione stabile.',
 77:         recommendations: ['Continuare con policy conservative attive.'],
 78:         pauseMinutes: 0,
 79:     };
 80: }
 81: 
 82: function tryExtractJsonBlock(raw: string): string | null {
 83:     const start = raw.indexOf('{');
 84:     const end = raw.lastIndexOf('}');
 85:     if (start === -1 || end === -1 || end <= start) {
 86:         return null;
 87:     }
 88:     return raw.slice(start, end + 1);
 89: }
 90: 
 91: function parseAiDecision(raw: string): ParsedAiGuardianPayload | null {
 92:     const jsonBlock = tryExtractJsonBlock(raw);
 93:     if (!jsonBlock) return null;
 94: 
 95:     try {
 96:         const parsed = JSON.parse(jsonBlock) as Record<string, unknown>;
 97:         const severityRaw = typeof parsed.severity === 'string' ? parsed.severity.toLowerCase() : '';
 98:         const severity: AiGuardianSeverity = severityRaw === 'critical' || severityRaw === 'watch' || severityRaw === 'normal'
 99:             ? severityRaw
100:             : 'watch';
101:         const summary = typeof parsed.summary === 'string' ? parsed.summary.trim() : '';
102:         const recommendationsRaw = Array.isArray(parsed.recommendations) ? parsed.recommendations : [];
103:         const recommendations = recommendationsRaw
104:             .filter((item): item is string => typeof item === 'string')
105:             .map((item) => item.trim())
106:             .filter(Boolean)
107:             .slice(0, 5);
108:         const pauseMinutesRaw = typeof parsed.pauseMinutes === 'number'
109:             ? parsed.pauseMinutes
110:             : Number.parseInt(String(parsed.pauseMinutes ?? '0'), 10);
111: 
112:         return {
113:             severity,
114:             summary: summary || 'AI guardian non ha fornito un summary dettagliato.',
115:             recommendations: recommendations.length > 0 ? recommendations : ['Verificare manualmente trend rischio.'],
116:             pauseMinutes: clampPauseMinutes(pauseMinutesRaw),
117:         };
118:     } catch {
119:         return null;
120:     }
121: }
122: 
123: async function shouldRunAiGuardianNow(now: Date): Promise<{ allowed: boolean; reason: string }> {
124:     const lastRaw = await getRuntimeFlag(AI_GUARDIAN_LAST_RUN_AT_KEY);
125:     if (!lastRaw) {
126:         return { allowed: true, reason: 'first_run' };
127:     }
128:     const parsed = Date.parse(lastRaw);
129:     if (!Number.isFinite(parsed)) {
130:         return { allowed: true, reason: 'invalid_last_run' };
131:     }
132:     const elapsedMinutes = (now.getTime() - parsed) / 60_000;
133:     if (elapsedMinutes >= config.aiGuardianMinIntervalMinutes) {
134:         return { allowed: true, reason: 'interval_elapsed' };
135:     }
136:     return { allowed: false, reason: 'interval_not_elapsed' };
137: }
138: 
139: export async function evaluateAiGuardian(
140:     workflow: WorkflowSelection,
141:     schedule: ScheduleResult
142: ): Promise<AiGuardianResult> {
143:     const heuristicDecision = heuristics(schedule);
144:     if (!config.aiGuardianEnabled || !config.openaiApiKey) {
145:         return {
146:             executed: true,
147:             reason: 'heuristic_only',
148:             decision: heuristicDecision,
149:         };
150:     }
151: 
152:     const now = new Date();
153:     const runCheck = await shouldRunAiGuardianNow(now);
154:     if (!runCheck.allowed) {
155:         return {
156:             executed: false,
157:             reason: runCheck.reason,
158:             decision: null,
159:         };
160:     }
161: 
162:     const systemPrompt = [
163:         'Sei un risk controller per automazione LinkedIn.',
164:         'Valuta il rischio in anticipo e rispondi SOLO JSON valido.',
165:         'Schema JSON: {"severity":"normal|watch|critical","summary":"...","recommendations":["..."],"pauseMinutes":number}',
166:         'Usa approccio conservativo, no ottimismo.',
167:     ].join(' ');
168:     const userPrompt = JSON.stringify({
169:         workflow,
170:         riskSnapshot: schedule.riskSnapshot,
171:         inviteBudget: schedule.inviteBudget,
172:         messageBudget: schedule.messageBudget,
173:         queuedInviteJobs: schedule.queuedInviteJobs,
174:         queuedCheckJobs: schedule.queuedCheckJobs,
175:         queuedMessageJobs: schedule.queuedMessageJobs,
176:         listBreakdown: schedule.listBreakdown,
177:         fallbackHeuristic: heuristicDecision,
178:     });
179: 
180:     try {
181:         const text = await requestOpenAIText({
182:             system: systemPrompt,
183:             user: `Valuta questo contesto operativo e decidi: ${userPrompt}`,
184:             maxOutputTokens: 260,
185:             temperature: 0.2,
186:         });
187:         const parsed = parseAiDecision(text);
188:         await setRuntimeFlag(AI_GUARDIAN_LAST_RUN_AT_KEY, now.toISOString());
189: 
190:         if (!parsed) {
191:             return {
192:                 executed: true,
193:                 reason: 'ai_parse_failed_fallback_heuristic',
194:                 decision: heuristicDecision,
195:             };
196:         }
197: 
198:         return {
199:             executed: true,
200:             reason: runCheck.reason,
201:             decision: {
202:                 source: 'ai',
203:                 severity: parsed.severity,
204:                 summary: parsed.summary,
205:                 recommendations: parsed.recommendations,
206:                 pauseMinutes: parsed.pauseMinutes,
207:             },
208:         };
209:     } catch {
210:         return {
211:             executed: true,
212:             reason: 'ai_error_fallback_heuristic',
213:             decision: heuristicDecision,
214:         };
215:     }
216: }
````

## File: src/ai/leadScorer.ts
````typescript
 1: import { requestOpenAIText } from './openaiClient';
 2: import { logWarn } from '../telemetry/logger';
 3: 
 4: export interface LeadScoreResult {
 5:     confidenceScore: number;
 6:     leadScore: number;
 7:     reason: string;
 8: }
 9: 
10: export async function scoreLeadProfile(
11:     accountName: string,
12:     fullName: string,
13:     headline: string | null
14: ): Promise<LeadScoreResult> {
15:     const rawHeadline = (headline || '').trim();
16: 
17:     // Se non troviamo una vera descrizione del lavoro usiamo un default di incertezza
18:     if (!rawHeadline) {
19:         return {
20:             confidenceScore: 30,
21:             leadScore: 20,
22:             reason: 'MISSING_HEADLINE_OR_ROLE',
23:         };
24:     }
25: 
26:     const systemPrompt = `Sei un esperto classificatore B2B. L'utente cerca lead validi nell'azienda target.
27: Devi analizzare i dati del lead (nome, qualifica/headline, azienda cercata) e fornire in output UNO JSON RIGIDO.
28: Valuta 2 parametri su base 1-100:
29: 1. "confidenceScore": quanto sei certo che questa persona lavori davvero nell'azienda target oggi? (Penalizza "ex account name", ologrammi o "student at...").
30: 2. "leadScore": quanto √® "buono" questo prospect per il B2B? (Alta per CEO/Founder/Dirigenti/Manager, Mezza per dipendenti base, Bassa per studenti/intern/pensionati).
31: 3. "reason": una brevissima stringa esplicativa (no spazi, stile UPPER_SNAKE_CASE es. "HIGH_VALUE_EXECUTIVE", "LOW_VALUE_INTERN", "POSSIBLE_EX_EMPLOYEE").
32: 
33: Rispondi SOLO con JSON. Esempio:
34: {
35:   "confidenceScore": 85,
36:   "leadScore": 90,
37:   "reason": "DECISION_MAKER"
38: }`;
39: 
40:     const userPrompt = JSON.stringify({
41:         targetCompany: accountName,
42:         personName: fullName,
43:         headline: rawHeadline,
44:     });
45: 
46:     try {
47:         const generated = await requestOpenAIText({
48:             system: systemPrompt,
49:             user: userPrompt,
50:             maxOutputTokens: 150,
51:             temperature: 0.1,
52:         });
53: 
54:         const rawJsonText = generated.replace(/```json/g, '').replace(/```/g, '').trim();
55:         const parsed = JSON.parse(rawJsonText);
56: 
57:         return {
58:             confidenceScore: Math.min(100, Math.max(0, Number(parsed.confidenceScore) || 50)),
59:             leadScore: Math.min(100, Math.max(0, Number(parsed.leadScore) || 50)),
60:             reason: String(parsed.reason || 'UNKNOWN').toUpperCase().replace(/[^A-Z_]/g, ''),
61:         };
62:     } catch (error) {
63:         await logWarn('ai.lead_scorer.failed', {
64:             personName: fullName,
65:             error: error instanceof Error ? error.message : String(error),
66:         });
67:         // In caso di errore API, diamo punteggi medi per non bloccare tutto a zero
68:         return {
69:             confidenceScore: 50,
70:             leadScore: 50,
71:             reason: 'API_ERROR_FALLBACK',
72:         };
73:     }
74: }
````

## File: src/ai/semanticChecker.ts
````typescript
  1: import { requestOpenAIEmbeddings, isOpenAIConfigured } from './openaiClient';
  2: 
  3: interface MemoryItem {
  4:     text: string;
  5:     embedding?: number[];
  6: }
  7: 
  8: export class SemanticChecker {
  9:     private static memory: MemoryItem[] = [];
 10:     private static MAX_MEMORY = 50;
 11: 
 12:     /**
 13:      * Calcola la Jaccard similarity (0-1) tra due stringhe,
 14:      * basata su bigrammi di parole.
 15:      */
 16:     private static jaccardSimilarity(str1: string, str2: string): number {
 17:         const getBigrams = (s: string) => {
 18:             const words = s.toLowerCase().replace(/[^\w\s]/g, '').split(/\s+/).filter(w => w.length > 0);
 19:             const bigrams = new Set<string>();
 20:             for (let i = 0; i < words.length - 1; i++) {
 21:                 bigrams.add(`${words[i]} ${words[i + 1]}`);
 22:             }
 23:             return bigrams;
 24:         };
 25: 
 26:         const set1 = getBigrams(str1);
 27:         const set2 = getBigrams(str2);
 28: 
 29:         if (set1.size === 0 && set2.size === 0) return 1.0;
 30:         if (set1.size === 0 || set2.size === 0) return 0.0;
 31: 
 32:         let intersectionSize = 0;
 33:         for (const item of set1) {
 34:             if (set2.has(item)) intersectionSize++;
 35:         }
 36: 
 37:         const unionSize = set1.size + set2.size - intersectionSize;
 38:         return intersectionSize / unionSize;
 39:     }
 40: 
 41:     private static cosineSimilarity(vec1: number[], vec2: number[]): number {
 42:         if (vec1.length !== vec2.length) return 0;
 43:         let dotProduct = 0;
 44:         let normA = 0;
 45:         let normB = 0;
 46:         for (let i = 0; i < vec1.length; i++) {
 47:             dotProduct += vec1[i] * vec2[i];
 48:             normA += vec1[i] * vec1[i];
 49:             normB += vec2[i] * vec2[i];
 50:         }
 51:         if (normA === 0 || normB === 0) return 0;
 52:         return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));
 53:     }
 54: 
 55:     /**
 56:      * Verifica se il nuovo testo √® troppo simile ad uno degli ultimi messaggi inviati.
 57:      * @param text Testo da verificare.
 58:      * @param threshold Soglia (es. 0.8 per 80% di similarit√†).
 59:      * @returns True se √® troppo simile a qualcosa in memoria.
 60:      */
 61:     public static async isTooSimilar(text: string, threshold: number = 0.8): Promise<boolean> {
 62:         let queryEmbedding: number[] | undefined;
 63: 
 64:         if (isOpenAIConfigured()) {
 65:             try {
 66:                 queryEmbedding = await requestOpenAIEmbeddings(text);
 67:             } catch {
 68:                 // Fallback silently to Jaccard
 69:             }
 70:         }
 71: 
 72:         for (const pastMsg of this.memory) {
 73:             if (queryEmbedding && pastMsg.embedding) {
 74:                 const sim = this.cosineSimilarity(queryEmbedding, pastMsg.embedding);
 75:                 if (sim > threshold) return true;
 76:             } else {
 77:                 if (this.jaccardSimilarity(text, pastMsg.text) > threshold) {
 78:                     return true;
 79:                 }
 80:             }
 81:         }
 82:         return false;
 83:     }
 84: 
 85:     /**
 86:      * Aggiunge un nuovo messaggio alla memoria (se non √® vuoto).
 87:      */
 88:     public static async remember(text: string): Promise<void> {
 89:         const t = text.trim();
 90:         if (!t) return;
 91: 
 92:         let embedding: number[] | undefined;
 93:         if (isOpenAIConfigured()) {
 94:             try {
 95:                 embedding = await requestOpenAIEmbeddings(t);
 96:             } catch {
 97:                 // Ignore, will fallback to jaccard
 98:             }
 99:         }
100: 
101:         this.memory.push({ text: t, embedding });
102:         if (this.memory.length > this.MAX_MEMORY) {
103:             this.memory.shift();
104:         }
105:     }
106: }
````

## File: src/ai/sentimentAnalysis.ts
````typescript
 1: import { config } from '../config';
 2: import { requestOpenAIText } from './openaiClient';
 3: import { logWarn } from '../telemetry/logger';
 4: 
 5: export type MessageIntent = 'POSITIVE' | 'NEGATIVE' | 'NEUTRAL' | 'QUESTIONS' | 'NOT_INTERESTED' | 'UNKNOWN';
 6: 
 7: export interface SentimentAnalysisResult {
 8:     intent: MessageIntent;
 9:     confidence: number;
10:     reasoning: string;
11: }
12: 
13: const SYSTEM_PROMPT = `Sei un esperto classificatore NLP di messaggi B2B LinkedIn in italiano.
14: La tua task √® analizzare il messaggio in ingresso e restituire UNICAMENTE un JSON valido con questa struttura esatta:
15: {
16:   "intent": "POSITIVE" | "NEGATIVE" | "NEUTRAL" | "QUESTIONS" | "NOT_INTERESTED",
17:   "confidence": <numero tra 0 e 1>,
18:   "reasoning": "<breve motivazione della scelta>"
19: }
20: 
21: DEFINIZIONI DEGLI INTENT:
22: - POSITIVE: L'utente esprime chiaro interesse, propone una call, accetta esplicitamente o usa toni entusiasti.
23: - NEGATIVE: L'utente si lamenta, si inalbera, √® scocciato dal messaggio, risponde con aggressivit√†.
24: - NEUTRAL: L'utente saluta "Grazie per il collegamento" e nient'altro, o risponde con pollici/ok senza particolare slancio.
25: - QUESTIONS: L'utente fa domande specifiche sul servizio/prodotto o su chi sei, necessita di pi√π info prima di decidere.
26: - NOT_INTERESTED: L'utente declina l'offerta ("Non mi interessa", "Siamo gi√† a posto", "No grazie").
27: 
28: Regola fondamentale: NESSUN TESTO FUORI DAL JSON. Il tuo output DEVE essere parsabile da JSON.parse().`;
29: 
30: export async function analyzeIncomingMessage(messageText: string): Promise<SentimentAnalysisResult> {
31:     if (config.inviteNoteMode !== 'ai' || !config.openaiApiKey) {
32:         return {
33:             intent: 'UNKNOWN',
34:             confidence: 0,
35:             reasoning: 'AI non configurata o disabilitata per il NLP Inbound.',
36:         };
37:     }
38: 
39:     if (!messageText || messageText.trim().length === 0) {
40:         return {
41:             intent: 'NEUTRAL',
42:             confidence: 1,
43:             reasoning: 'Messaggio vuoto o nullo.',
44:         };
45:     }
46: 
47:     try {
48:         const responseText = await requestOpenAIText({
49:             system: SYSTEM_PROMPT,
50:             user: `Analizza questo messaggio: "${messageText}"`,
51:             maxOutputTokens: 150,
52:             temperature: 0.1, // temperatura bassa per output deterministico JSON
53:             responseFormat: 'json_object' // Richiede OpenAI tier recente, altrimenti fallback
54:         });
55: 
56:         // Pulizia base se LLM formatta con markdown
57:         const cleanedJsonString = responseText.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
58:         const parsed = JSON.parse(cleanedJsonString);
59: 
60:         return {
61:             intent: parsed.intent || 'UNKNOWN',
62:             confidence: typeof parsed.confidence === 'number' ? parsed.confidence : 0,
63:             reasoning: parsed.reasoning || 'Parsing riuscito ma campi mancanti.',
64:         };
65:     } catch (error) {
66:         await logWarn('ai.sentiment_analysis.failed', {
67:             error: error instanceof Error ? error.message : String(error),
68:             messageSnippet: messageText.substring(0, 50)
69:         });
70: 
71:         return {
72:             intent: 'UNKNOWN',
73:             confidence: 0,
74:             reasoning: 'Errore generico durante la richiesta LLM o il parsing JSON.',
75:         };
76:     }
77: }
````

## File: src/api/server.ts
````typescript
  1: import express from 'express';
  2: import cors from 'cors';
  3: import path from 'path';
  4: import { timingSafeEqual } from 'crypto';
  5: import type { NextFunction, Request, Response } from 'express';
  6: import { getGlobalKPIData, getRiskInputs, getABTestingStats } from '../core/repositories';
  7: import { getDatabase } from '../db';
  8: import { evaluateRisk } from '../risk/riskEngine';
  9: import { getLocalDateString, config } from '../config';
 10: import { pauseAutomation, resumeAutomation, setQuarantine } from '../risk/incidentManager';
 11: import { CampaignRunRecord } from '../types/domain';
 12: 
 13: const app = express();
 14: app.use(cors());
 15: app.use(express.json());
 16: 
 17: function secureEquals(a: string, b: string): boolean {
 18:     const aBuffer = Buffer.from(a);
 19:     const bBuffer = Buffer.from(b);
 20:     if (aBuffer.length !== bBuffer.length) {
 21:         return false;
 22:     }
 23:     return timingSafeEqual(aBuffer, bBuffer);
 24: }
 25: 
 26: function normalizeIp(rawIp: string): string {
 27:     const trimmed = rawIp.trim();
 28:     if (!trimmed) return '';
 29:     if (trimmed === '::1') return '127.0.0.1';
 30:     if (trimmed.startsWith('::ffff:')) return trimmed.slice('::ffff:'.length);
 31:     return trimmed;
 32: }
 33: 
 34: function resolveRequestIp(req: Request): string {
 35:     const forwardedFor = req.header('x-forwarded-for');
 36:     if (forwardedFor) {
 37:         const first = forwardedFor.split(',')[0] ?? '';
 38:         const normalized = normalizeIp(first);
 39:         if (normalized) return normalized;
 40:     }
 41:     const fallback = req.ip ?? (req.socket?.remoteAddress ?? '');
 42:     return normalizeIp(fallback);
 43: }
 44: 
 45: function isTrustedIp(ip: string): boolean {
 46:     const trusted = new Set<string>(['127.0.0.1', ...config.dashboardTrustedIps.map(normalizeIp)]);
 47:     return trusted.has(ip);
 48: }
 49: 
 50: function isApiKeyAuthValid(req: Request): boolean {
 51:     if (!config.dashboardApiKey) return false;
 52: 
 53:     const fromHeader = req.header('x-api-key');
 54:     if (fromHeader && secureEquals(fromHeader.trim(), config.dashboardApiKey)) {
 55:         return true;
 56:     }
 57: 
 58:     const authorization = req.header('authorization') ?? '';
 59:     if (!authorization.toLowerCase().startsWith('bearer ')) {
 60:         return false;
 61:     }
 62: 
 63:     const token = authorization.slice('bearer '.length).trim();
 64:     return token.length > 0 && secureEquals(token, config.dashboardApiKey);
 65: }
 66: 
 67: function isBasicAuthValid(req: Request): boolean {
 68:     if (!config.dashboardBasicUser || !config.dashboardBasicPassword) return false;
 69:     const authorization = req.header('authorization') ?? '';
 70:     if (!authorization.toLowerCase().startsWith('basic ')) {
 71:         return false;
 72:     }
 73: 
 74:     const encoded = authorization.slice('basic '.length).trim();
 75:     if (!encoded) return false;
 76: 
 77:     let decoded = '';
 78:     try {
 79:         decoded = Buffer.from(encoded, 'base64').toString('utf8');
 80:     } catch {
 81:         return false;
 82:     }
 83: 
 84:     const separatorIndex = decoded.indexOf(':');
 85:     if (separatorIndex <= 0) {
 86:         return false;
 87:     }
 88: 
 89:     const user = decoded.slice(0, separatorIndex);
 90:     const password = decoded.slice(separatorIndex + 1);
 91:     return secureEquals(user, config.dashboardBasicUser) && secureEquals(password, config.dashboardBasicPassword);
 92: }
 93: 
 94: function dashboardAuthMiddleware(req: Request, res: Response, next: NextFunction): void {
 95:     if (!config.dashboardAuthEnabled) {
 96:         next();
 97:         return;
 98:     }
 99: 
100:     if (req.path === '/api/health') {
101:         next();
102:         return;
103:     }
104: 
105:     const requestIp = resolveRequestIp(req);
106:     if (isTrustedIp(requestIp)) {
107:         next();
108:         return;
109:     }
110: 
111:     const authConfigured = !!config.dashboardApiKey || (!!config.dashboardBasicUser && !!config.dashboardBasicPassword);
112:     if (!authConfigured) {
113:         res.status(503).json({
114:             error: 'Dashboard auth enabled but no credentials configured. Set DASHBOARD_API_KEY or DASHBOARD_BASIC_USER/PASSWORD.',
115:         });
116:         return;
117:     }
118: 
119:     if (isApiKeyAuthValid(req) || isBasicAuthValid(req)) {
120:         next();
121:         return;
122:     }
123: 
124:     res.setHeader('WWW-Authenticate', 'Basic realm="LinkedIn Bot Dashboard"');
125:     res.status(401).json({ error: 'Unauthorized' });
126: }
127: 
128: app.use(dashboardAuthMiddleware);
129: 
130: // Serves the public directory (Dashboard UI)
131: const publicDir = path.resolve(__dirname, '../../public');
132: app.use(express.static(publicDir));
133: 
134: // Health check
135: app.get('/api/health', (req, res) => {
136:     res.json({ status: 'ok', timestamp: new Date().toISOString() });
137: });
138: 
139: // KPIs endpoint
140: app.get('/api/kpis', async (req, res) => {
141:     try {
142:         const kpi = await getGlobalKPIData();
143:         const localDate = getLocalDateString();
144:         const riskInputs = await getRiskInputs(localDate, config.hardInviteCap);
145:         const risk = await evaluateRisk(riskInputs);
146:         const db = await getDatabase();
147: 
148:         const runtimePause = await db.get(`SELECT value FROM runtime_flags WHERE key = 'automation_paused_until'`);
149:         const isQuarantined = await db.get(`SELECT value FROM runtime_flags WHERE key = 'account_quarantine'`);
150: 
151:         res.json({
152:             funnel: {
153:                 totalLeads: kpi.totalLeads,
154:                 invited: kpi.statusCounts['INVITED'] || 0,
155:                 accepted: kpi.statusCounts['ACCEPTED'] || 0,
156:                 readyMessage: kpi.statusCounts['READY_MESSAGE'] || 0,
157:                 messaged: kpi.statusCounts['MESSAGED'] || 0,
158:                 replied: kpi.statusCounts['REPLIED'] || 0,
159:                 withdrawn: kpi.statusCounts['WITHDRAWN'] || 0
160:             },
161:             risk: risk,
162:             activeCampaigns: kpi.activeCampaigns,
163:             system: {
164:                 pausedUntil: runtimePause?.value || null,
165:                 quarantined: isQuarantined?.value === 'true'
166:             }
167:         });
168:     } catch (err: unknown) {
169:         const message = err instanceof Error ? err.message : String(err);
170:         console.error('API Error', message);
171:         res.status(500).json({ error: message });
172:     }
173: });
174: 
175: // Recent runs
176: app.get('/api/runs', async (req, res) => {
177:     try {
178:         const db = await getDatabase();
179:         const runs = await db.all<CampaignRunRecord[]>(`SELECT * FROM campaign_runs ORDER BY id DESC LIMIT 10`);
180:         res.json(runs);
181:     } catch (err: unknown) {
182:         const message = err instanceof Error ? err.message : String(err);
183:         console.error('API Error', message);
184:         res.status(500).json({ error: message });
185:     }
186: });
187: 
188: // A/B Testing Stats
189: app.get('/api/ab-testing/stats', async (req, res) => {
190:     try {
191:         const stats = await getABTestingStats();
192:         res.json(stats);
193:     } catch (err: unknown) {
194:         const message = err instanceof Error ? err.message : String(err);
195:         console.error('API Error /ab-testing/stats', message);
196:         res.status(500).json({ error: message });
197:     }
198: });
199: 
200: // Controls
201: app.post('/api/controls/pause', async (req, res) => {
202:     try {
203:         const minutes = req.body.minutes || 1440; // Default 24h
204:         await pauseAutomation('MANUAL_UI_PAUSE', { source: 'dashboard' }, minutes);
205:         res.json({ success: true, message: `Paused for ${minutes} minutes` });
206:     } catch (err: unknown) {
207:         const message = err instanceof Error ? err.message : String(err);
208:         res.status(500).json({ error: message });
209:     }
210: });
211: 
212: app.post('/api/controls/resume', async (req, res) => {
213:     try {
214:         await resumeAutomation();
215:         res.json({ success: true, message: 'Resumed' });
216:     } catch (err: unknown) {
217:         const message = err instanceof Error ? err.message : String(err);
218:         res.status(500).json({ error: message });
219:     }
220: });
221: 
222: app.post('/api/controls/quarantine', async (req, res) => {
223:     try {
224:         const enabled = req.body.enabled === true;
225:         await setQuarantine(enabled);
226:         res.json({ success: true, message: `Quarantine set to ${enabled}` });
227:     } catch (err: unknown) {
228:         const message = err instanceof Error ? err.message : String(err);
229:         res.status(500).json({ error: message });
230:     }
231: });
232: 
233: export function startServer(port: number = 3000) {
234:     return app.listen(port, () => {
235:         console.log(`\nüöÄ Dashboard & Web API is running on http://localhost:${port}\n`);
236:     });
237: }
````

## File: src/cloud/controlPlaneSync.ts
````typescript
  1: import { createHash } from 'crypto';
  2: import { config } from '../config';
  3: import {
  4:     applyControlPlaneCampaignConfigs,
  5:     ControlPlaneCampaignConfigInput,
  6:     getRuntimeFlag,
  7:     setRuntimeFlag,
  8:     applyCloudAccountUpdates,
  9:     applyCloudLeadUpdates
 10: } from '../core/repositories';
 11: import { logInfo, logWarn } from '../telemetry/logger';
 12: import {
 13:     fetchCloudCampaignConfigs,
 14:     fetchCloudAccountsUpdates,
 15:     fetchCloudLeadsUpdates
 16: } from './supabaseDataClient';
 17: 
 18: const CONTROL_PLANE_LAST_RUN_KEY = 'control_plane.campaigns.last_run_at';
 19: const CONTROL_PLANE_LAST_HASH_KEY = 'control_plane.campaigns.last_hash';
 20: const CONTROL_PLANE_ACCOUNTS_LAST_SYNC_KEY = 'control_plane.accounts.last_sync_at';
 21: const CONTROL_PLANE_LEADS_LAST_SYNC_KEY = 'control_plane.leads.last_sync_at';
 22: 
 23: function isControlPlaneConfigured(): boolean {
 24:     return !!(config.supabaseSyncEnabled && config.supabaseUrl && config.supabaseServiceRoleKey);
 25: }
 26: 
 27: function normalizeControlPlaneCampaigns(
 28:     campaigns: Array<{
 29:         name: string;
 30:         is_active: boolean;
 31:         priority: number;
 32:         daily_invite_cap: number | null;
 33:         daily_message_cap: number | null;
 34:     }>
 35: ): ControlPlaneCampaignConfigInput[] {
 36:     const byName = new Map<string, ControlPlaneCampaignConfigInput>();
 37:     for (const campaign of campaigns) {
 38:         const name = campaign.name.trim();
 39:         if (!name) continue;
 40:         byName.set(name, {
 41:             name,
 42:             isActive: campaign.is_active,
 43:             priority: Math.max(1, Math.floor(campaign.priority)),
 44:             dailyInviteCap: campaign.daily_invite_cap === null ? null : Math.max(0, Math.floor(campaign.daily_invite_cap)),
 45:             dailyMessageCap: campaign.daily_message_cap === null ? null : Math.max(0, Math.floor(campaign.daily_message_cap)),
 46:         });
 47:     }
 48:     return Array.from(byName.values())
 49:         .sort((a, b) => a.priority - b.priority || a.name.localeCompare(b.name));
 50: }
 51: 
 52: function computeControlPlaneHash(configs: ControlPlaneCampaignConfigInput[]): string {
 53:     const payload = JSON.stringify(configs);
 54:     return createHash('sha256').update(payload).digest('hex');
 55: }
 56: 
 57: export interface ControlPlaneStatus {
 58:     enabled: boolean;
 59:     configured: boolean;
 60:     intervalMs: number;
 61:     maxCampaigns: number;
 62:     lastRunAt: string | null;
 63: }
 64: 
 65: export interface ControlPlaneSyncReport {
 66:     enabled: boolean;
 67:     configured: boolean;
 68:     executed: boolean;
 69:     reason: string;
 70:     lastRunAt: string | null;
 71:     hashChanged: boolean;
 72:     fetched: number;
 73:     applied: number;
 74:     created: number;
 75:     updated: number;
 76:     unchanged: number;
 77:     skippedInvalid: number;
 78: }
 79: 
 80: export async function getControlPlaneStatus(): Promise<ControlPlaneStatus> {
 81:     const lastRunAt = await getRuntimeFlag(CONTROL_PLANE_LAST_RUN_KEY);
 82:     return {
 83:         enabled: config.supabaseControlPlaneEnabled,
 84:         configured: isControlPlaneConfigured(),
 85:         intervalMs: config.supabaseControlPlaneSyncIntervalMs,
 86:         maxCampaigns: config.supabaseControlPlaneMaxCampaigns,
 87:         lastRunAt,
 88:     };
 89: }
 90: 
 91: async function syncAccountsDown() {
 92:     const lastSyncAt = await getRuntimeFlag(CONTROL_PLANE_ACCOUNTS_LAST_SYNC_KEY);
 93:     const updates = await fetchCloudAccountsUpdates(lastSyncAt, 100);
 94:     if (updates.length > 0) {
 95:         await applyCloudAccountUpdates(updates);
 96:         // Calcola il max updated_at
 97:         let maxUpdatedAt = lastSyncAt || new Date(0).toISOString();
 98:         for (const u of updates) {
 99:             if (u.updated_at && u.updated_at > maxUpdatedAt) {
100:                 maxUpdatedAt = u.updated_at;
101:             }
102:         }
103:         await setRuntimeFlag(CONTROL_PLANE_ACCOUNTS_LAST_SYNC_KEY, maxUpdatedAt);
104:         await logInfo('control_plane.accounts.downsync', { count: updates.length });
105:     }
106: }
107: 
108: async function syncLeadsDown() {
109:     const lastSyncAt = await getRuntimeFlag(CONTROL_PLANE_LEADS_LAST_SYNC_KEY);
110:     const updates = await fetchCloudLeadsUpdates(lastSyncAt, 500);
111:     if (updates.length > 0) {
112:         await applyCloudLeadUpdates(updates);
113:         // Calcola il max updated_at
114:         let maxUpdatedAt = lastSyncAt || new Date(0).toISOString();
115:         for (const u of updates) {
116:             if (u.updated_at && u.updated_at > maxUpdatedAt) {
117:                 maxUpdatedAt = u.updated_at;
118:             }
119:         }
120:         await setRuntimeFlag(CONTROL_PLANE_LEADS_LAST_SYNC_KEY, maxUpdatedAt);
121:         await logInfo('control_plane.leads.downsync', { count: updates.length });
122:     }
123: }
124: 
125: export async function runControlPlaneSync(options: { force?: boolean } = {}): Promise<ControlPlaneSyncReport> {
126:     const enabled = config.supabaseControlPlaneEnabled;
127:     const configured = isControlPlaneConfigured();
128:     const force = options.force === true;
129:     const nowIso = new Date().toISOString();
130:     const lastRunAt = await getRuntimeFlag(CONTROL_PLANE_LAST_RUN_KEY);
131: 
132:     const baseReport: ControlPlaneSyncReport = {
133:         enabled,
134:         configured,
135:         executed: false,
136:         reason: 'noop',
137:         lastRunAt,
138:         hashChanged: false,
139:         fetched: 0,
140:         applied: 0,
141:         created: 0,
142:         updated: 0,
143:         unchanged: 0,
144:         skippedInvalid: 0,
145:     };
146: 
147:     if (!enabled) {
148:         return { ...baseReport, reason: 'control_plane_disabled' };
149:     }
150:     if (!configured) {
151:         return { ...baseReport, reason: 'supabase_not_configured' };
152:     }
153: 
154:     if (!force && lastRunAt) {
155:         const elapsedMs = Date.now() - Date.parse(lastRunAt);
156:         if (Number.isFinite(elapsedMs) && elapsedMs >= 0 && elapsedMs < config.supabaseControlPlaneSyncIntervalMs) {
157:             return { ...baseReport, reason: 'interval_not_elapsed' };
158:         }
159:     }
160: 
161:     try {
162:         const remoteCampaigns = await fetchCloudCampaignConfigs(config.supabaseControlPlaneMaxCampaigns);
163:         const normalized = normalizeControlPlaneCampaigns(remoteCampaigns);
164:         const nextHash = computeControlPlaneHash(normalized);
165:         const prevHash = await getRuntimeFlag(CONTROL_PLANE_LAST_HASH_KEY);
166:         const hashChanged = nextHash !== prevHash;
167: 
168:         let applyResult = {
169:             fetched: normalized.length,
170:             applied: 0,
171:             created: 0,
172:             updated: 0,
173:             unchanged: normalized.length,
174:             skippedInvalid: 0,
175:         };
176:         let reason = 'hash_unchanged';
177: 
178:         if (force || hashChanged) {
179:             applyResult = await applyControlPlaneCampaignConfigs(normalized);
180:             reason = force ? 'forced_sync' : 'synced';
181:         }
182: 
183:         // Downsync entit√† addizionali
184:         await syncAccountsDown();
185:         await syncLeadsDown();
186: 
187:         await setRuntimeFlag(CONTROL_PLANE_LAST_RUN_KEY, nowIso);
188:         await setRuntimeFlag(CONTROL_PLANE_LAST_HASH_KEY, nextHash);
189: 
190:         await logInfo('control_plane.campaigns.sync', {
191:             reason,
192:             force,
193:             hashChanged,
194:             ...applyResult,
195:             intervalMs: config.supabaseControlPlaneSyncIntervalMs,
196:             maxCampaigns: config.supabaseControlPlaneMaxCampaigns,
197:         });
198: 
199:         return {
200:             ...baseReport,
201:             executed: true,
202:             reason,
203:             lastRunAt: nowIso,
204:             hashChanged,
205:             ...applyResult,
206:         };
207:     } catch (error: unknown) {
208:         const message = error instanceof Error ? error.message : String(error);
209:         await logWarn('control_plane.campaigns.sync.error', { error: message });
210:         return {
211:             ...baseReport,
212:             reason: 'sync_error',
213:         };
214:     }
215: }
````

## File: src/cloud/telegramListener.ts
````typescript
  1: import { config } from '../config';
  2: import { logInfo, logWarn } from '../telemetry/logger';
  3: 
  4: let isPolling = false;
  5: let lastUpdateId = 0;
  6: 
  7: export async function startTelegramListener(): Promise<void> {
  8:     if (!config.telegramBotToken) {
  9:         console.warn('[TELEGRAM] Listener non avviato: telegramBotToken mancante.');
 10:         return;
 11:     }
 12:     if (isPolling) return;
 13:     isPolling = true;
 14: 
 15:     console.log('[TELEGRAM] Long-polling listener avviato per ricezione comandi nel DB.');
 16: 
 17:     // Esegue in background infinito
 18:     void pollLoop();
 19: }
 20: 
 21: async function pollLoop(): Promise<void> {
 22:     while (isPolling) {
 23:         try {
 24:             const url = `https://api.telegram.org/bot${config.telegramBotToken}/getUpdates?offset=${lastUpdateId + 1}&timeout=30`;
 25:             const response = await fetch(url);
 26:             if (!response.ok) {
 27:                 await new Promise(res => setTimeout(res, 5000));
 28:                 continue;
 29:             }
 30: 
 31:             const data = await response.json() as { ok: boolean; result?: Array<{ update_id: number; message?: TelegramMessage }> };
 32:             if (!data.ok || !data.result) {
 33:                 await new Promise(res => setTimeout(res, 2000));
 34:                 continue;
 35:             }
 36: 
 37:             for (const update of data.result) {
 38:                 lastUpdateId = Math.max(lastUpdateId, update.update_id);
 39:                 if (update.message && update.message.text) {
 40:                     await processTelegramMessage(update.message);
 41:                 }
 42:             }
 43:         } catch (error) {
 44:             console.error('[TELEGRAM] Errore nel polling:', error);
 45:             await new Promise(res => setTimeout(res, 5000));
 46:         }
 47:     }
 48: }
 49: 
 50: interface TelegramMessage {
 51:     text?: string;
 52:     chat: {
 53:         id: number | string;
 54:     };
 55: }
 56: 
 57: async function processTelegramMessage(message: TelegramMessage): Promise<void> {
 58:     const text = (message.text || '').trim();
 59:     if (!text.startsWith('/')) return; // Solo comandi
 60: 
 61:     // Verifica sicurezza (solo la chat autorizzata)
 62:     if (config.telegramChatId && String(message.chat.id) !== config.telegramChatId) {
 63:         await logWarn('telegram.unauthorized_access', { chatId: message.chat.id, text });
 64:         return;
 65:     }
 66: 
 67:     const parts = text.split(' ');
 68:     const command = parts[0].substring(1).toLowerCase(); // es. 'pausa'
 69:     const argsRaw = parts.slice(1);
 70: 
 71:     let accountId: string | null = null;
 72:     let actualArgs = argsRaw.join(' ');
 73: 
 74:     // Sintassi opzionale: /pausa acc1
 75:     if (argsRaw.length >= 1 && (argsRaw[0] === 'all' || argsRaw[0].startsWith('acc') || /^[0-9]+$/.test(argsRaw[0]))) {
 76:         accountId = argsRaw[0];
 77:         actualArgs = argsRaw.slice(1).join(' ');
 78:     }
 79: 
 80:     // Inserire usando Supabase supabase-js (lo ricarichiamo globalmente per evitare dipendenze circolari strane in init)
 81:     const { createClient } = await import('@supabase/supabase-js');
 82:     if (config.supabaseSyncEnabled && config.supabaseUrl && config.supabaseServiceRoleKey) {
 83:         const sb = createClient(config.supabaseUrl, config.supabaseServiceRoleKey, {
 84:             auth: { persistSession: false, autoRefreshToken: false },
 85:         });
 86: 
 87:         const { error } = await sb.from('telegram_commands').insert({
 88:             account_id: accountId === 'all' ? null : accountId || null,
 89:             command,
 90:             args: actualArgs || null,
 91:             status: 'PENDING',
 92:         });
 93: 
 94:         if (error) {
 95:             await logWarn('telegram.command.insert_failed', { error: error.message });
 96:             await replyToTelegram(message.chat.id, `‚ùå Errore Supabase: ${error.message}`);
 97:         } else {
 98:             await logInfo('telegram.command.received', { command, accountId, actualArgs });
 99:             await replyToTelegram(message.chat.id, `‚úÖ Comando /${command} accodato (attendere processing).`);
100:         }
101:     } else {
102:         await logWarn('telegram.command.ignored_no_cloud', { command });
103:         await replyToTelegram(message.chat.id, `‚ùå Supabase non configurato. Impossibile accodare /${command}.`);
104:     }
105: }
106: 
107: async function replyToTelegram(chatId: string | number, text: string): Promise<void> {
108:     try {
109:         await fetch(`https://api.telegram.org/bot${config.telegramBotToken}/sendMessage`, {
110:             method: 'POST',
111:             headers: { 'Content-Type': 'application/json' },
112:             body: JSON.stringify({
113:                 chat_id: chatId,
114:                 text,
115:             })
116:         });
117:     } catch (e) {
118:         console.error('[TELEGRAM] Errore risposta', e);
119:     }
120: }
````

## File: src/connectWorkflow.ts
````typescript
1: import { runWorkflow } from './core/orchestrator';
2: 
3: export async function runConnectionWorkflow(): Promise<void> {
4:     await runWorkflow({
5:         workflow: 'invite',
6:         dryRun: false,
7:     });
8: }
````

## File: src/core/salesNavigatorSync.ts
````typescript
  1: import { getAccountProfileById } from '../accountManager';
  2: import { checkLogin, closeBrowser, detectChallenge, launchBrowser } from '../browser';
  3: import { quarantineAccount } from '../risk/incidentManager';
  4: import {
  5:     getLeadByLinkedinUrl,
  6:     linkLeadToSalesNavList,
  7:     markSalesNavListSynced,
  8:     upsertSalesNavList,
  9:     upsertSalesNavigatorLead,
 10: } from './repositories';
 11: import { navigateToSavedLists, scrapeLeadsFromSalesNavList, SalesNavLeadCandidate, SalesNavSavedList } from '../salesnav/listScraper';
 12: 
 13: export interface SalesNavigatorSyncOptions {
 14:     listName?: string | null;
 15:     listUrl?: string | null;
 16:     maxPages: number;
 17:     maxLeadsPerList: number;
 18:     dryRun: boolean;
 19:     accountId?: string;
 20: }
 21: 
 22: export interface SalesNavigatorSyncListReport {
 23:     listName: string;
 24:     listUrl: string;
 25:     pagesVisited: number;
 26:     candidatesDiscovered: number;
 27:     uniqueCandidates: number;
 28:     inserted: number;
 29:     updated: number;
 30:     unchanged: number;
 31:     wouldInsert: number;
 32:     wouldUpdate: number;
 33:     errors: number;
 34:     samples: Array<{
 35:         linkedinUrl: string;
 36:         firstName: string;
 37:         lastName: string;
 38:         accountName: string;
 39:         jobTitle: string;
 40:     }>;
 41: }
 42: 
 43: export interface SalesNavigatorSyncReport {
 44:     accountId: string;
 45:     dryRun: boolean;
 46:     listFilter: string | null;
 47:     listDiscoveryCount: number;
 48:     maxPages: number;
 49:     maxLeadsPerList: number;
 50:     pagesVisited: number;
 51:     candidatesDiscovered: number;
 52:     uniqueCandidates: number;
 53:     inserted: number;
 54:     updated: number;
 55:     unchanged: number;
 56:     wouldInsert: number;
 57:     wouldUpdate: number;
 58:     errors: number;
 59:     challengeDetected: boolean;
 60:     lists: SalesNavigatorSyncListReport[];
 61: }
 62: 
 63: function cleanText(value: string | null | undefined): string {
 64:     return (value ?? '').replace(/\s+/g, ' ').trim();
 65: }
 66: 
 67: function matchesListNameFilter(list: SalesNavSavedList, filter: string): boolean {
 68:     const normalizedFilter = filter.toLowerCase();
 69:     const normalizedName = cleanText(list.name).toLowerCase();
 70:     return normalizedName === normalizedFilter || normalizedName.includes(normalizedFilter);
 71: }
 72: 
 73: function toSample(candidate: SalesNavLeadCandidate): SalesNavigatorSyncListReport['samples'][number] {
 74:     return {
 75:         linkedinUrl: candidate.linkedinUrl,
 76:         firstName: candidate.firstName,
 77:         lastName: candidate.lastName,
 78:         accountName: candidate.accountName,
 79:         jobTitle: candidate.jobTitle,
 80:     };
 81: }
 82: 
 83: export async function runSalesNavigatorListSync(options: SalesNavigatorSyncOptions): Promise<SalesNavigatorSyncReport> {
 84:     const listFilter = cleanText(options.listName) || null;
 85:     const explicitListUrl = cleanText(options.listUrl) || null;
 86:     const maxPages = Math.max(1, options.maxPages);
 87:     const maxLeadsPerList = Math.max(1, options.maxLeadsPerList);
 88:     const account = getAccountProfileById(options.accountId);
 89: 
 90:     const report: SalesNavigatorSyncReport = {
 91:         accountId: account.id,
 92:         dryRun: options.dryRun,
 93:         listFilter,
 94:         listDiscoveryCount: 0,
 95:         maxPages,
 96:         maxLeadsPerList,
 97:         pagesVisited: 0,
 98:         candidatesDiscovered: 0,
 99:         uniqueCandidates: 0,
100:         inserted: 0,
101:         updated: 0,
102:         unchanged: 0,
103:         wouldInsert: 0,
104:         wouldUpdate: 0,
105:         errors: 0,
106:         challengeDetected: false,
107:         lists: [],
108:     };
109: 
110:     const session = await launchBrowser({
111:         sessionDir: account.sessionDir,
112:         proxy: account.proxy,
113:     });
114: 
115:     try {
116:         const loggedIn = await checkLogin(session.page);
117:         if (!loggedIn) {
118:             throw new Error(`Sales Navigator sync: sessione non autenticata (account=${account.id}).`);
119:         }
120: 
121:         let targetLists: SalesNavSavedList[] = [];
122:         if (explicitListUrl) {
123:             targetLists = [{
124:                 name: listFilter || 'default',
125:                 url: explicitListUrl,
126:             }];
127:         } else {
128:             const discovered = await navigateToSavedLists(session.page);
129:             report.listDiscoveryCount = discovered.length;
130:             if (listFilter) {
131:                 targetLists = discovered.filter((entry) => matchesListNameFilter(entry, listFilter));
132:             } else {
133:                 targetLists = discovered;
134:             }
135:         }
136: 
137:         if (targetLists.length === 0) {
138:             throw new Error('Sales Navigator sync: nessuna lista trovata con i criteri forniti.');
139:         }
140: 
141:         for (const targetList of targetLists) {
142:             const listName = cleanText(targetList.name) || 'default';
143:             const listUrl = cleanText(targetList.url);
144:             const listReport: SalesNavigatorSyncListReport = {
145:                 listName,
146:                 listUrl,
147:                 pagesVisited: 0,
148:                 candidatesDiscovered: 0,
149:                 uniqueCandidates: 0,
150:                 inserted: 0,
151:                 updated: 0,
152:                 unchanged: 0,
153:                 wouldInsert: 0,
154:                 wouldUpdate: 0,
155:                 errors: 0,
156:                 samples: [],
157:             };
158: 
159:             const scraped = await scrapeLeadsFromSalesNavList(session.page, {
160:                 listUrl,
161:                 maxPages,
162:                 leadLimit: maxLeadsPerList,
163:             });
164:             listReport.pagesVisited = scraped.pagesVisited;
165:             listReport.candidatesDiscovered = scraped.candidatesDiscovered;
166:             listReport.uniqueCandidates = scraped.uniqueCandidates;
167: 
168:             report.pagesVisited += scraped.pagesVisited;
169:             report.candidatesDiscovered += scraped.candidatesDiscovered;
170:             report.uniqueCandidates += scraped.uniqueCandidates;
171: 
172:             if (await detectChallenge(session.page)) {
173:                 report.challengeDetected = true;
174:                 await quarantineAccount('SALESNAV_SYNC_CHALLENGE_DETECTED', {
175:                     listName,
176:                     listUrl,
177:                     accountId: account.id,
178:                 });
179:                 report.lists.push(listReport);
180:                 break;
181:             }
182: 
183:             const listRow = options.dryRun ? null : await upsertSalesNavList(listName, listUrl);
184:             for (const candidate of scraped.leads) {
185:                 if (listReport.samples.length < 10) {
186:                     listReport.samples.push(toSample(candidate));
187:                 }
188:                 try {
189:                     if (options.dryRun) {
190:                         const existing = await getLeadByLinkedinUrl(candidate.linkedinUrl);
191:                         if (existing) {
192:                             listReport.wouldUpdate += 1;
193:                             report.wouldUpdate += 1;
194:                         } else {
195:                             listReport.wouldInsert += 1;
196:                             report.wouldInsert += 1;
197:                         }
198:                         continue;
199:                     }
200: 
201:                     const upserted = await upsertSalesNavigatorLead({
202:                         listName,
203:                         linkedinUrl: candidate.linkedinUrl,
204:                         accountName: candidate.accountName,
205:                         firstName: candidate.firstName,
206:                         lastName: candidate.lastName,
207:                         jobTitle: candidate.jobTitle,
208:                         website: candidate.website,
209:                     });
210: 
211:                     if (listRow && upserted.leadId > 0) {
212:                         await linkLeadToSalesNavList(listRow.id, upserted.leadId);
213:                     }
214: 
215:                     if (upserted.action === 'inserted') {
216:                         listReport.inserted += 1;
217:                         report.inserted += 1;
218:                     } else if (upserted.action === 'updated') {
219:                         listReport.updated += 1;
220:                         report.updated += 1;
221:                     } else {
222:                         listReport.unchanged += 1;
223:                         report.unchanged += 1;
224:                     }
225:                 } catch {
226:                     listReport.errors += 1;
227:                     report.errors += 1;
228:                 }
229:             }
230: 
231:             if (listRow && !options.dryRun) {
232:                 await markSalesNavListSynced(listRow.id);
233:             }
234: 
235:             report.lists.push(listReport);
236:         }
237: 
238:         return report;
239:     } finally {
240:         await closeBrowser(session);
241:     }
242: }
````

## File: src/core/sessionWarmer.ts
````typescript
 1: /**
 2:  * sessionWarmer.ts
 3:  * 
 4:  * Implementa il modulo "Behavioral Engine" della roadmap Fase 3.
 5:  * Il suo scopo √® iniettare traffico inerte "umano" subito dopo il routing e 
 6:  * prima di operazioni massive come mass-enrichment o auto-connect.
 7:  */
 8: 
 9: import { Page } from 'playwright';
10: import { simulateHumanReading, humanType, humanDelay } from '../browser';
11: 
12: 
13: export async function warmupSession(page: Page): Promise<void> {
14:     console.log(`[WARM-UP] Avvio Session Warming (Behavioral Engine)...`);
15: 
16:     try {
17:         // 1. Vai alla Home Page
18:         await page.goto('https://www.linkedin.com/feed/', { waitUntil: 'domcontentloaded' });
19:         await humanDelay(page, 2000, 5000);
20: 
21:         // 2. Scrolling organico sul feed (leggere articoli passivamente)
22:         console.log(`[WARM-UP] Simulazione lettura disinteressata del feed...`);
23:         const maxScrollAttempts = Math.floor(Math.random() * 3) + 2; // Da 2 a 4 scroll
24:         for (let i = 0; i < maxScrollAttempts; i++) {
25:             await simulateHumanReading(page);
26:             await humanDelay(page, 1500, 4000);
27:         }
28: 
29:         // 3. Check Notifiche incrociato (Blink passivo)
30:         if (Math.random() > 0.5) {
31:             console.log(`[WARM-UP] Ispezione sporadica della barra notifiche...`);
32:             const notificationsTab = await page.$('a[href*="/notifications/"]');
33:             if (notificationsTab) {
34:                 // Non ci serve per forza cliccare, a volte basta il mouse over lungo o clic passivo
35:                 await notificationsTab.hover();
36:                 await humanDelay(page, 1000, 2000);
37:             }
38:         }
39: 
40:         // 4. Interazione col motore di ricerca (digita qualcosa, cancella) [Raro: 30%]
41:         if (Math.random() > 0.7) {
42:             console.log(`[WARM-UP] Simulazione interesse ricerca globale disattesa...`);
43:             const searchInput = await page.$('input.search-global-typeahead__input');
44:             if (searchInput) {
45:                 await searchInput.focus();
46:                 // Digita un termine dummy che l'utente scriverebbe e poi cancella
47:                 const dummySearches = ['software engineer', 'recruiter', 'news tech', 'AI trends'];
48:                 const searchTxt = dummySearches[Math.floor(Math.random() * dummySearches.length)];
49:                 await humanType(page, 'input.search-global-typeahead__input', searchTxt);
50:                 await humanDelay(page, 800, 1500);
51:                 // Cancella
52:                 await searchInput.fill('');
53:                 await humanDelay(page, 500, 1000);
54:                 await page.keyboard.press('Escape'); // Chiudi il dropdown
55:             }
56:         }
57: 
58:     } catch (e) {
59:         console.log(`[WARM-UP] Warming interrotto, ignoro (non fatale):`, e instanceof Error ? e.message : e);
60:     } finally {
61:         console.log(`[WARM-UP] Session Warming completato, token stabilizzato.`);
62:         await humanDelay(page, 1000, 2000);
63:     }
64: }
````

## File: src/csvImporter.ts
````typescript
  1: import fs from 'fs';
  2: import csv from 'csv-parser';
  3: import { addCompanyTarget, addLead } from './core/repositories';
  4: import { isLinkedInUrl, normalizeLinkedInUrl } from './linkedinUrl';
  5: 
  6: export interface ImportResult {
  7:     inserted: number;
  8:     companyTargetsInserted: number;
  9:     skipped: number;
 10: }
 11: 
 12: /**
 13:  * Legge un valore da un record CSV provando pi√π possibili nomi di colonna in ordine.
 14:  */
 15: function pickField(row: Record<string, string>, ...keys: string[]): string {
 16:     for (const key of keys) {
 17:         const val = row[key];
 18:         if (val && val.trim()) {
 19:             return val.trim();
 20:         }
 21:     }
 22:     return '';
 23: }
 24: 
 25: function normalizeWebsite(raw: string): string {
 26:     const trimmed = raw.trim();
 27:     if (!trimmed) return '';
 28:     if (/^https?:\/\//i.test(trimmed)) return trimmed;
 29:     if (trimmed.includes('.') && !trimmed.includes(' ')) {
 30:         return `https://${trimmed}`;
 31:     }
 32:     return trimmed;
 33: }
 34: 
 35: export async function importLeadsFromCSV(filePath: string, listName: string): Promise<ImportResult> {
 36:     const rows: Array<Record<string, string>> = [];
 37: 
 38:     await new Promise<void>((resolve, reject) => {
 39:         fs.createReadStream(filePath)
 40:             .pipe(csv())
 41:             .on('data', (row: Record<string, string>) => rows.push(row))
 42:             .on('end', resolve)
 43:             .on('error', reject);
 44:     });
 45: 
 46:     let inserted = 0;
 47:     let companyTargetsInserted = 0;
 48:     let skipped = 0;
 49: 
 50:     for (const row of rows) {
 51:         // LinkedIn URL ‚Äî Sales Navigator e formati alternativi
 52:         const lnUrlRaw = pickField(
 53:             row,
 54:             'linkedin_url',
 55:             'LinkedIn URL',
 56:             'linkedinUrl',
 57:             'LinkedIn Profile URL',
 58:             'Profile URL',
 59:             'Linkedin',
 60:             'Person Linkedin Url',
 61:             'Contact LinkedIn URL'
 62:         );
 63: 
 64:         const linkedinUrl = normalizeLinkedInUrl(lnUrlRaw.trim());
 65: 
 66:         // Sales Navigator: "First Name" e "Last Name" separati
 67:         const firstName = pickField(row, 'First Name', 'first_name', 'FirstName');
 68:         const lastName = pickField(row, 'Last Name', 'last_name', 'LastName');
 69: 
 70:         // Nome account / azienda
 71:         const accountName = pickField(
 72:             row,
 73:             'Account Name', 'account_name', 'Company', 'Company Name', 'company_name',
 74:             'companyName', 'Organization'
 75:         );
 76: 
 77:         // Se non abbiamo accountName esplicito, lo costruiamo da first+last
 78:         const resolvedAccountName = accountName || [firstName, lastName].filter(Boolean).join(' ');
 79: 
 80:         const jobTitle = pickField(row, 'Title', 'Job Title', 'job_title', 'Position');
 81:         const website = normalizeWebsite(
 82:             pickField(
 83:                 row,
 84:                 'Website',
 85:                 'website',
 86:                 'Company Website',
 87:                 'Company Domain',
 88:                 'domain'
 89:             )
 90:         );
 91: 
 92:         if (!linkedinUrl || !isLinkedInUrl(linkedinUrl)) {
 93:             const insertedCompanyTarget = await addCompanyTarget({
 94:                 listName,
 95:                 accountName: resolvedAccountName,
 96:                 website,
 97:                 sourceFile: filePath,
 98:             });
 99:             if (insertedCompanyTarget) {
100:                 companyTargetsInserted += 1;
101:             } else {
102:                 skipped += 1;
103:             }
104:             continue;
105:         }
106: 
107:         const isNew = await addLead({
108:             accountName: resolvedAccountName,
109:             firstName,
110:             lastName,
111:             jobTitle,
112:             website,
113:             linkedinUrl,
114:             listName,
115:         });
116: 
117:         if (isNew) {
118:             inserted += 1;
119:         } else {
120:             skipped += 1;
121:         }
122:     }
123: 
124:     return { inserted, companyTargetsInserted, skipped };
125: }
````

## File: src/db/migrations/001_core.sql
````sql
  1: CREATE TABLE IF NOT EXISTS _migrations (
  2:     id INTEGER PRIMARY KEY AUTOINCREMENT,
  3:     name TEXT NOT NULL UNIQUE,
  4:     applied_at DATETIME DEFAULT CURRENT_TIMESTAMP
  5: );
  6: 
  7: CREATE TABLE IF NOT EXISTS leads (
  8:     id INTEGER PRIMARY KEY AUTOINCREMENT,
  9:     account_name TEXT NOT NULL DEFAULT '',
 10:     website TEXT NOT NULL DEFAULT '',
 11:     linkedin_url TEXT NOT NULL UNIQUE,
 12:     status TEXT NOT NULL DEFAULT 'NEW',
 13:     list_name TEXT NOT NULL DEFAULT 'default',
 14:     invited_at DATETIME,
 15:     accepted_at DATETIME,
 16:     messaged_at DATETIME,
 17:     last_error TEXT,
 18:     blocked_reason TEXT,
 19:     created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
 20:     updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
 21: );
 22: 
 23: CREATE TABLE IF NOT EXISTS lead_lists (
 24:     id INTEGER PRIMARY KEY AUTOINCREMENT,
 25:     name TEXT NOT NULL UNIQUE,
 26:     source TEXT NOT NULL DEFAULT 'manual',
 27:     created_at DATETIME DEFAULT CURRENT_TIMESTAMP
 28: );
 29: 
 30: CREATE TABLE IF NOT EXISTS list_leads (
 31:     list_id INTEGER NOT NULL,
 32:     lead_id INTEGER NOT NULL,
 33:     created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
 34:     PRIMARY KEY (list_id, lead_id),
 35:     FOREIGN KEY (list_id) REFERENCES lead_lists(id),
 36:     FOREIGN KEY (lead_id) REFERENCES leads(id)
 37: );
 38: 
 39: CREATE TABLE IF NOT EXISTS daily_stats (
 40:     date TEXT PRIMARY KEY,
 41:     invites_sent INTEGER NOT NULL DEFAULT 0,
 42:     messages_sent INTEGER NOT NULL DEFAULT 0,
 43:     challenges_count INTEGER NOT NULL DEFAULT 0,
 44:     selector_failures INTEGER NOT NULL DEFAULT 0,
 45:     run_errors INTEGER NOT NULL DEFAULT 0
 46: );
 47: 
 48: CREATE TABLE IF NOT EXISTS jobs (
 49:     id INTEGER PRIMARY KEY AUTOINCREMENT,
 50:     type TEXT NOT NULL,
 51:     status TEXT NOT NULL DEFAULT 'QUEUED',
 52:     payload_json TEXT NOT NULL,
 53:     idempotency_key TEXT NOT NULL UNIQUE,
 54:     priority INTEGER NOT NULL DEFAULT 100,
 55:     attempts INTEGER NOT NULL DEFAULT 0,
 56:     max_attempts INTEGER NOT NULL DEFAULT 3,
 57:     next_run_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
 58:     locked_at DATETIME,
 59:     last_error TEXT,
 60:     created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
 61:     updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
 62: );
 63: 
 64: CREATE TABLE IF NOT EXISTS job_attempts (
 65:     id INTEGER PRIMARY KEY AUTOINCREMENT,
 66:     job_id INTEGER NOT NULL,
 67:     started_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
 68:     finished_at DATETIME,
 69:     success INTEGER NOT NULL DEFAULT 0,
 70:     error_code TEXT,
 71:     error_message TEXT,
 72:     evidence_path TEXT,
 73:     FOREIGN KEY (job_id) REFERENCES jobs(id)
 74: );
 75: 
 76: CREATE TABLE IF NOT EXISTS lead_events (
 77:     id INTEGER PRIMARY KEY AUTOINCREMENT,
 78:     lead_id INTEGER NOT NULL,
 79:     from_status TEXT NOT NULL,
 80:     to_status TEXT NOT NULL,
 81:     reason TEXT NOT NULL,
 82:     metadata_json TEXT NOT NULL DEFAULT '{}',
 83:     created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
 84:     FOREIGN KEY (lead_id) REFERENCES leads(id)
 85: );
 86: 
 87: CREATE TABLE IF NOT EXISTS account_incidents (
 88:     id INTEGER PRIMARY KEY AUTOINCREMENT,
 89:     type TEXT NOT NULL,
 90:     severity TEXT NOT NULL DEFAULT 'WARN',
 91:     status TEXT NOT NULL DEFAULT 'OPEN',
 92:     details_json TEXT NOT NULL DEFAULT '{}',
 93:     opened_at DATETIME DEFAULT CURRENT_TIMESTAMP,
 94:     acknowledged_at DATETIME,
 95:     resolved_at DATETIME
 96: );
 97: 
 98: CREATE TABLE IF NOT EXISTS outbox_events (
 99:     id INTEGER PRIMARY KEY AUTOINCREMENT,
100:     topic TEXT NOT NULL,
101:     payload_json TEXT NOT NULL,
102:     idempotency_key TEXT NOT NULL UNIQUE,
103:     attempts INTEGER NOT NULL DEFAULT 0,
104:     next_retry_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
105:     delivered_at DATETIME,
106:     last_error TEXT,
107:     created_at DATETIME DEFAULT CURRENT_TIMESTAMP
108: );
109: 
110: CREATE TABLE IF NOT EXISTS sync_state (
111:     key TEXT PRIMARY KEY,
112:     value TEXT NOT NULL,
113:     updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
114: );
115: 
116: CREATE TABLE IF NOT EXISTS message_history (
117:     id INTEGER PRIMARY KEY AUTOINCREMENT,
118:     lead_id INTEGER NOT NULL,
119:     content_hash TEXT NOT NULL,
120:     sent_at DATETIME DEFAULT CURRENT_TIMESTAMP,
121:     FOREIGN KEY (lead_id) REFERENCES leads(id)
122: );
123: 
124: CREATE TABLE IF NOT EXISTS run_logs (
125:     id INTEGER PRIMARY KEY AUTOINCREMENT,
126:     level TEXT NOT NULL,
127:     event TEXT NOT NULL,
128:     payload_json TEXT NOT NULL DEFAULT '{}',
129:     created_at DATETIME DEFAULT CURRENT_TIMESTAMP
130: );
131: 
132: CREATE INDEX IF NOT EXISTS idx_leads_status ON leads(status);
133: CREATE INDEX IF NOT EXISTS idx_jobs_status_next_run ON jobs(status, next_run_at);
134: CREATE INDEX IF NOT EXISTS idx_job_attempts_job_id ON job_attempts(job_id);
135: CREATE INDEX IF NOT EXISTS idx_outbox_pending ON outbox_events(delivered_at, next_retry_at);
136: CREATE INDEX IF NOT EXISTS idx_message_history_hash_sent_at ON message_history(content_hash, sent_at);
````

## File: src/db/migrations/002_legacy_status_backfill.sql
````sql
1: UPDATE leads
2: SET status = 'READY_INVITE',
3:     updated_at = CURRENT_TIMESTAMP
4: WHERE status = 'PENDING';
````

## File: src/db/migrations/003_add_person_fields.sql
````sql
1: -- Aggiunge campi persona (nome/cognome) alla tabella leads.
2: -- Sales Navigator esporta First Name e Last Name separatamente.
3: ALTER TABLE leads ADD COLUMN first_name TEXT NOT NULL DEFAULT '';
4: ALTER TABLE leads ADD COLUMN last_name  TEXT NOT NULL DEFAULT '';
5: ALTER TABLE leads ADD COLUMN job_title  TEXT NOT NULL DEFAULT '';
````

## File: src/db/migrations/004_list_campaign_controls.sql
````sql
 1: -- Controlli campagna per lista Sales Navigator.
 2: ALTER TABLE lead_lists ADD COLUMN is_active INTEGER NOT NULL DEFAULT 1;
 3: ALTER TABLE lead_lists ADD COLUMN priority INTEGER NOT NULL DEFAULT 100;
 4: ALTER TABLE lead_lists ADD COLUMN daily_invite_cap INTEGER;
 5: ALTER TABLE lead_lists ADD COLUMN daily_message_cap INTEGER;
 6: 
 7: CREATE TABLE IF NOT EXISTS list_daily_stats (
 8:     date TEXT NOT NULL,
 9:     list_name TEXT NOT NULL,
10:     invites_sent INTEGER NOT NULL DEFAULT 0,
11:     messages_sent INTEGER NOT NULL DEFAULT 0,
12:     PRIMARY KEY (date, list_name)
13: );
14: 
15: CREATE INDEX IF NOT EXISTS idx_list_daily_stats_list_date
16:     ON list_daily_stats(list_name, date);
````

## File: src/db/migrations/005_performance_indexes.sql
````sql
1: -- Indici per scheduler/worker su database con molti lead.
2: CREATE INDEX IF NOT EXISTS idx_leads_status_list_created
3:     ON leads(status, list_name, created_at);
4: 
5: CREATE INDEX IF NOT EXISTS idx_jobs_type_status_next_run
6:     ON jobs(type, status, next_run_at, priority, created_at);
````

## File: src/db/migrations/006_company_targets.sql
````sql
 1: CREATE TABLE IF NOT EXISTS company_targets (
 2:     id INTEGER PRIMARY KEY AUTOINCREMENT,
 3:     list_name TEXT NOT NULL,
 4:     account_name TEXT NOT NULL DEFAULT '',
 5:     website TEXT NOT NULL DEFAULT '',
 6:     source_file TEXT,
 7:     status TEXT NOT NULL DEFAULT 'NEW',
 8:     created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
 9:     updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
10: );
11: 
12: CREATE UNIQUE INDEX IF NOT EXISTS uq_company_targets_list_account_website
13:     ON company_targets(list_name, account_name, website);
14: 
15: CREATE INDEX IF NOT EXISTS idx_company_targets_list_status
16:     ON company_targets(list_name, status, created_at);
````

## File: src/db/migrations/007_company_target_tracking.sql
````sql
1: ALTER TABLE company_targets ADD COLUMN attempts INTEGER NOT NULL DEFAULT 0;
2: ALTER TABLE company_targets ADD COLUMN last_error TEXT;
3: ALTER TABLE company_targets ADD COLUMN processed_at DATETIME;
````

## File: src/db/migrations/008_runtime_locks.sql
````sql
 1: CREATE TABLE IF NOT EXISTS runtime_locks (
 2:     lock_key TEXT PRIMARY KEY,
 3:     owner_id TEXT NOT NULL,
 4:     acquired_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
 5:     heartbeat_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
 6:     expires_at DATETIME NOT NULL,
 7:     metadata_json TEXT NOT NULL DEFAULT '{}',
 8:     updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
 9: );
10: 
11: CREATE INDEX IF NOT EXISTS idx_runtime_locks_expires_at
12:     ON runtime_locks(expires_at);
````

## File: src/db/migrations/009_site_check_tracking.sql
````sql
1: ALTER TABLE leads ADD COLUMN last_site_check_at DATETIME;
2: 
3: CREATE INDEX IF NOT EXISTS idx_leads_status_last_site_check
4:     ON leads(status, last_site_check_at, created_at);
````

## File: src/db/migrations/010_salesnav_lists.sql
````sql
 1: CREATE TABLE IF NOT EXISTS salesnav_lists (
 2:     id INTEGER PRIMARY KEY AUTOINCREMENT,
 3:     name TEXT NOT NULL UNIQUE,
 4:     url TEXT NOT NULL UNIQUE,
 5:     last_synced_at DATETIME,
 6:     created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
 7:     updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
 8: );
 9: 
10: CREATE TABLE IF NOT EXISTS salesnav_list_items (
11:     id INTEGER PRIMARY KEY AUTOINCREMENT,
12:     list_id INTEGER NOT NULL,
13:     lead_id INTEGER NOT NULL,
14:     added_at DATETIME DEFAULT CURRENT_TIMESTAMP,
15:     FOREIGN KEY (list_id) REFERENCES salesnav_lists(id),
16:     FOREIGN KEY (lead_id) REFERENCES leads(id),
17:     UNIQUE(list_id, lead_id)
18: );
19: 
20: CREATE INDEX IF NOT EXISTS idx_salesnav_lists_last_synced_at
21:     ON salesnav_lists(last_synced_at);
22: 
23: CREATE INDEX IF NOT EXISTS idx_salesnav_list_items_list_id
24:     ON salesnav_list_items(list_id);
25: 
26: CREATE INDEX IF NOT EXISTS idx_salesnav_list_items_lead_id
27:     ON salesnav_list_items(lead_id);
````

## File: src/db/migrations/011_daily_stats_acceptances.sql
````sql
1: -- Migration 011: aggiunge colonna acceptances a daily_stats
2: -- Traccia le accettazioni di un invito rilevate dall'acceptanceWorker.
3: -- Usa ADD COLUMN IF NOT EXISTS per idempotenza su DB gi√† aggiornati.
4: 
5: ALTER TABLE daily_stats ADD COLUMN acceptances INTEGER NOT NULL DEFAULT 0;
````

## File: src/db/migrations/012_ai_profile_and_prompt_variants.sql
````sql
1: -- Aggiunta campi per l'Estrazione Profilo (Autopilota AI) e Variante Prompt AI
2: 
3: ALTER TABLE leads ADD COLUMN about TEXT DEFAULT NULL;
4: ALTER TABLE leads ADD COLUMN experience TEXT DEFAULT NULL;
5: ALTER TABLE leads ADD COLUMN invite_prompt_variant TEXT DEFAULT NULL;
````

## File: src/db/migrations/013_lead_scoring.sql
````sql
1: -- Up
2: ALTER TABLE leads ADD COLUMN lead_score INTEGER DEFAULT NULL;
3: ALTER TABLE leads ADD COLUMN confidence_score INTEGER DEFAULT NULL;
````

## File: src/db/migrations/014_campaign_runs.sql
````sql
 1: -- 014_campaign_runs.sql
 2: -- Tabella per l'Audit di ogni singola run del bot
 3: 
 4: CREATE TABLE IF NOT EXISTS campaign_runs (
 5:     id INTEGER PRIMARY KEY AUTOINCREMENT,
 6:     start_time TEXT NOT NULL,
 7:     end_time TEXT,
 8:     status TEXT NOT NULL DEFAULT 'RUNNING', -- 'RUNNING', 'SUCCESS', 'FAILED', 'PAUSED'
 9:     profiles_discovered INTEGER DEFAULT 0,
10:     invites_sent INTEGER DEFAULT 0,
11:     messages_sent INTEGER DEFAULT 0,
12:     errors_count INTEGER DEFAULT 0,
13:     created_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%f', 'now'))
14: );
````

## File: src/linkedinUrl.ts
````typescript
 1: export function tryParseUrl(raw: string): URL | null {
 2:     const trimmed = raw.trim();
 3:     if (!trimmed) return null;
 4:     try {
 5:         return new URL(trimmed);
 6:     } catch {
 7:         return null;
 8:     }
 9: }
10: 
11: export function isLinkedInHost(hostname: string): boolean {
12:     const host = hostname.toLowerCase();
13:     return host === 'linkedin.com' || host.endsWith('.linkedin.com');
14: }
15: 
16: export function isLinkedInUrl(raw: string): boolean {
17:     const parsed = tryParseUrl(raw);
18:     return !!parsed && isLinkedInHost(parsed.hostname);
19: }
20: 
21: export function isSalesNavigatorUrl(raw: string): boolean {
22:     const parsed = tryParseUrl(raw);
23:     if (!parsed || !isLinkedInHost(parsed.hostname)) return false;
24:     return parsed.pathname.toLowerCase().startsWith('/sales/');
25: }
26: 
27: export function isProfileUrl(raw: string): boolean {
28:     const parsed = tryParseUrl(raw);
29:     if (!parsed || !isLinkedInHost(parsed.hostname)) return false;
30:     const path = parsed.pathname.toLowerCase();
31:     return path.startsWith('/in/') || path.startsWith('/pub/');
32: }
33: 
34: export function normalizeLinkedInUrl(raw: string): string {
35:     const parsed = tryParseUrl(raw);
36:     if (!parsed || !isLinkedInHost(parsed.hostname)) {
37:         return raw.trim();
38:     }
39: 
40:     const normalized = new URL(parsed.toString());
41:     normalized.protocol = 'https:';
42:     normalized.hostname = 'www.linkedin.com';
43:     normalized.hash = '';
44: 
45:     // Canonicalizza i profili alla radice /in/<slug>/ per evitare varianti duplicate.
46:     const parts = normalized.pathname.split('/').filter(Boolean);
47:     if (parts.length >= 2 && parts[0].toLowerCase() === 'in') {
48:         normalized.pathname = `/in/${parts[1]}/`;
49:         normalized.search = '';
50:         return normalized.toString();
51:     }
52: 
53:     normalized.pathname = normalized.pathname.replace(/\/+$/, '');
54:     return normalized.toString();
55: }
````

## File: src/messages.ts
````typescript
 1: import { LeadRecord } from './types/domain';
 2: 
 3: const templates: string[] = [
 4:     `Ciao {{firstName}},\n\npiacere di connetterci qui su LinkedIn.\nSeguo aziende nel tuo settore e ho visto alcuni punti dove spesso si sblocca crescita commerciale con piccoli cambi operativi.\n\nSe ti va, facciamo una call di 15 minuti questa settimana?`,
 5:     `Ciao {{firstName}},\n\ngrazie del collegamento.\nHo dato un'occhiata a {{companyHint}} e credo ci sia spazio per uno scambio utile su acquisizione e pipeline.\n\nTi andrebbe una breve call di 15 minuti?`,
 6:     `Ciao {{firstName}},\n\npiacere di essere in contatto.\nLavoro su progetti che aiutano team come il tuo a migliorare conversione e tempi di risposta commerciale.\n\nSe hai 15 minuti nei prossimi giorni, ti racconto due idee concrete.`,
 7: ];
 8: 
 9: /**
10:  * Restituisce il primo nome da usare nel messaggio.
11:  * Priorit√†: first_name (da Sales Navigator) ‚Üí prima parola di account_name ‚Üí fallback generico.
12:  */
13: function resolveFirstName(lead: LeadRecord): string {
14:     if (lead.first_name && lead.first_name.trim()) {
15:         return lead.first_name.trim();
16:     }
17:     // Fallback: prima parola di account_name se sembra un nome proprio
18:     const clean = lead.account_name.trim();
19:     if (clean) {
20:         const firstWord = clean.split(/\s+/)[0];
21:         // Usa la prima parola solo se non √® tutta maiuscola (es. "ACME" ‚Üí scarta)
22:         if (firstWord !== firstWord.toUpperCase()) {
23:             return firstWord;
24:         }
25:     }
26:     return 'there';
27: }
28: 
29: function getCompanyHint(lead: LeadRecord): string {
30:     if (lead.account_name.trim()) {
31:         return lead.account_name.trim();
32:     }
33:     if (lead.website.trim()) {
34:         return lead.website.trim();
35:     }
36:     return 'la tua realt√†';
37: }
38: 
39: function resolveTemplate(template: string, lead: LeadRecord): string {
40:     return template
41:         .replaceAll('{{firstName}}', resolveFirstName(lead))
42:         .replaceAll('{{companyHint}}', getCompanyHint(lead));
43: }
44: 
45: export function buildFollowUpMessage(lead: LeadRecord): string {
46:     const index = lead.id % templates.length;
47:     return resolveTemplate(templates[index], lead);
48: }
````

## File: src/messagingWorkflow.ts
````typescript
1: import { runWorkflow } from './core/orchestrator';
2: 
3: export async function runMessagingWorkflow(): Promise<void> {
4:     await runWorkflow({
5:         workflow: 'message',
6:         dryRun: false,
7:     });
8: }
````

## File: src/models.ts
````typescript
 1: import {
 2:     addLead as addLeadRepository,
 3:     getDailyStat,
 4:     countLeadsByStatuses,
 5:     countWeeklyInvites as countWeeklyInvitesRepository,
 6:     getLeadsByStatus,
 7:     incrementDailyStat,
 8:     setLeadStatus,
 9: } from './core/repositories';
10: import { LeadRecord, LeadStatus } from './types/domain';
11: 
12: export interface Lead extends LeadRecord { }
13: 
14: export async function addLead(lead: Partial<Lead>): Promise<void> {
15:     await addLeadRepository({
16:         accountName: lead.account_name ?? '',
17:         firstName: lead.first_name ?? '',
18:         lastName: lead.last_name ?? '',
19:         jobTitle: lead.job_title ?? '',
20:         website: lead.website ?? '',
21:         linkedinUrl: lead.linkedin_url ?? '',
22:         listName: lead.list_name ?? 'default',
23:     });
24: }
25: 
26: export async function getPendingLeads(limit: number): Promise<Lead[]> {
27:     return getLeadsByStatus('READY_INVITE', limit);
28: }
29: 
30: export async function getInvitedLeads(): Promise<Lead[]> {
31:     return getLeadsByStatus('INVITED', 1000);
32: }
33: 
34: export async function getAcceptedLeads(limit: number): Promise<Lead[]> {
35:     return getLeadsByStatus('READY_MESSAGE', limit);
36: }
37: 
38: export async function updateLeadStatus(id: number, status: LeadStatus): Promise<void> {
39:     await setLeadStatus(id, status);
40: }
41: 
42: export async function countDailyInvites(dateString: string): Promise<number> {
43:     return getDailyStat(dateString, 'invites_sent');
44: }
45: 
46: export async function countWeeklyInvites(weekStartDate: string): Promise<number> {
47:     return countWeeklyInvitesRepository(weekStartDate);
48: }
49: 
50: export async function incrementDailyInvites(dateString: string): Promise<void> {
51:     await incrementDailyStat(dateString, 'invites_sent');
52: }
53: 
54: export async function countReadyToInvite(): Promise<number> {
55:     return countLeadsByStatuses(['READY_INVITE']);
56: }
````

## File: src/risk/riskEngine.ts
````typescript
  1: import { config } from '../config';
  2: import { RiskInputs, RiskSnapshot } from '../types/domain';
  3: 
  4: function clampScore(value: number): number {
  5:     return Math.max(0, Math.min(100, Math.round(value)));
  6: }
  7: 
  8: export function evaluateRisk(inputs: RiskInputs): RiskSnapshot {
  9:     const score = clampScore(
 10:         inputs.errorRate * 40 +
 11:         inputs.selectorFailureRate * 20 +
 12:         inputs.pendingRatio * 25 +
 13:         Math.min(30, inputs.challengeCount * 20) +
 14:         inputs.inviteVelocityRatio * 15
 15:     );
 16: 
 17:     let action: RiskSnapshot['action'] = 'NORMAL';
 18:     if (score >= config.riskStopThreshold || inputs.pendingRatio >= config.pendingRatioStop || inputs.challengeCount > 0) {
 19:         action = 'STOP';
 20:     } else if (score >= config.riskWarnThreshold || inputs.pendingRatio >= config.pendingRatioWarn) {
 21:         action = 'WARN';
 22:     }
 23: 
 24:     return {
 25:         score,
 26:         pendingRatio: inputs.pendingRatio,
 27:         errorRate: inputs.errorRate,
 28:         selectorFailureRate: inputs.selectorFailureRate,
 29:         challengeCount: inputs.challengeCount,
 30:         inviteVelocityRatio: inputs.inviteVelocityRatio,
 31:         action,
 32:     };
 33: }
 34: 
 35: export function calculateDynamicBudget(
 36:     softCap: number,
 37:     hardCap: number,
 38:     alreadyConsumed: number,
 39:     riskAction: RiskSnapshot['action'],
 40:     accountAgeDays: number
 41: ): number {
 42:     if (alreadyConsumed >= hardCap) {
 43:         return 0;
 44:     }
 45: 
 46:     let effectiveCap = softCap;
 47: 
 48:     // Warm-up policy
 49:     if (accountAgeDays <= 4) {
 50:         effectiveCap = Math.floor(softCap * 0.1); // ~10% first days
 51:     } else if (accountAgeDays <= 14) {
 52:         effectiveCap = Math.floor(softCap * 0.5); // ~50% early weeks
 53:     }
 54: 
 55:     // Risk policy
 56:     if (riskAction === 'WARN') {
 57:         effectiveCap = Math.floor(effectiveCap * 0.5);
 58:     }
 59:     if (riskAction === 'STOP') {
 60:         effectiveCap = 0;
 61:     }
 62: 
 63:     effectiveCap = Math.min(hardCap, Math.max(0, effectiveCap));
 64:     return Math.max(0, effectiveCap - alreadyConsumed);
 65: }
 66: 
 67: export interface CooldownDecision {
 68:     activate: boolean;
 69:     tier: 'none' | 'warn' | 'high';
 70:     minutes: number;
 71:     reason: string | null;
 72: }
 73: 
 74: export function evaluateCooldownDecision(snapshot: RiskSnapshot): CooldownDecision {
 75:     if (!config.cooldownEnabled) {
 76:         return { activate: false, tier: 'none', minutes: 0, reason: null };
 77:     }
 78: 
 79:     if (snapshot.action !== 'WARN') {
 80:         return { activate: false, tier: 'none', minutes: 0, reason: null };
 81:     }
 82: 
 83:     const high = snapshot.score >= config.cooldownHighScore || snapshot.pendingRatio >= config.cooldownPendingHighThreshold;
 84:     if (high) {
 85:         return {
 86:             activate: true,
 87:             tier: 'high',
 88:             minutes: config.cooldownHighMinutes,
 89:             reason: 'risk_cooldown_high',
 90:         };
 91:     }
 92: 
 93:     const warn = snapshot.score >= config.cooldownWarnScore || snapshot.pendingRatio >= config.cooldownPendingThreshold;
 94:     if (warn) {
 95:         return {
 96:             activate: true,
 97:             tier: 'warn',
 98:             minutes: config.cooldownWarnMinutes,
 99:             reason: 'risk_cooldown_warn',
100:         };
101:     }
102: 
103:     return { activate: false, tier: 'none', minutes: 0, reason: null };
104: }
````

## File: src/salesnav/listActions.ts
````typescript
  1: import { getAccountProfileById } from '../accountManager';
  2: import { checkLogin, closeBrowser, humanDelay, humanMouseMove, launchBrowser } from '../browser';
  3: import { normalizeLinkedInUrl } from '../linkedinUrl';
  4: import { navigateToSavedLists, SalesNavSavedList } from './listScraper';
  5: 
  6: export interface SalesNavActionResult {
  7:     ok: boolean;
  8:     accountId: string;
  9:     message: string;
 10:     listName?: string;
 11:     listUrl?: string | null;
 12: }
 13: 
 14: const CREATE_LIST_BUTTON_SELECTOR = [
 15:     'button:has-text("Create list")',
 16:     'button:has-text("Crea lista")',
 17:     'a:has-text("Create list")',
 18:     'a:has-text("Crea lista")',
 19: ].join(', ');
 20: 
 21: const LIST_NAME_INPUT_SELECTOR = [
 22:     'input[placeholder*="List name"]',
 23:     'input[placeholder*="Nome lista"]',
 24:     'input[name*="list"]',
 25:     'input[id*="list"]',
 26: ].join(', ');
 27: 
 28: const CREATE_LIST_CONFIRM_SELECTOR = [
 29:     'button:has-text("Create")',
 30:     'button:has-text("Crea")',
 31:     'button.artdeco-button--primary',
 32: ].join(', ');
 33: 
 34: const SAVE_TO_LIST_BUTTON_SELECTOR = [
 35:     'button:has-text("Save in list")',
 36:     'button:has-text("Salva in lista")',
 37:     'button:has-text("Save")',
 38:     'button:has-text("Salva")',
 39: ].join(', ');
 40: 
 41: const ADD_TO_LIST_CONFIRM_SELECTOR = [
 42:     'button:has-text("Save")',
 43:     'button:has-text("Salva")',
 44:     'button:has-text("Done")',
 45:     'button:has-text("Fatto")',
 46: ].join(', ');
 47: 
 48: function cleanText(value: string): string {
 49:     return value.replace(/\s+/g, ' ').trim();
 50: }
 51: 
 52: function normalizeListName(value: string): string {
 53:     return cleanText(value).toLowerCase();
 54: }
 55: 
 56: function matchSavedListByName(lists: SalesNavSavedList[], listName: string): SalesNavSavedList | null {
 57:     const target = normalizeListName(listName);
 58:     if (!target) return null;
 59: 
 60:     const exact = lists.find((entry) => normalizeListName(entry.name) === target);
 61:     if (exact) return exact;
 62: 
 63:     const partial = lists.find((entry) => {
 64:         const name = normalizeListName(entry.name);
 65:         return name.includes(target) || target.includes(name);
 66:     });
 67:     return partial ?? null;
 68: }
 69: 
 70: async function resolveSavedListUrl(page: import('playwright').Page, listName: string): Promise<string | null> {
 71:     try {
 72:         const lists = await navigateToSavedLists(page);
 73:         const matched = matchSavedListByName(lists, listName);
 74:         return matched?.url ?? null;
 75:     } catch {
 76:         return null;
 77:     }
 78: }
 79: 
 80: export async function createSalesNavList(listName: string, accountId?: string): Promise<SalesNavActionResult> {
 81:     const account = getAccountProfileById(accountId);
 82:     const normalizedListName = cleanText(listName);
 83:     if (!normalizedListName) {
 84:         return { ok: false, accountId: account.id, message: 'Nome lista non valido' };
 85:     }
 86: 
 87:     const session = await launchBrowser({
 88:         sessionDir: account.sessionDir,
 89:         proxy: account.proxy,
 90:     });
 91:     try {
 92:         const loggedIn = await checkLogin(session.page);
 93:         if (!loggedIn) {
 94:             return { ok: false, accountId: account.id, message: 'Sessione non autenticata' };
 95:         }
 96: 
 97:         await session.page.goto('https://www.linkedin.com/sales/lists/people/', { waitUntil: 'domcontentloaded' });
 98:         await humanDelay(session.page, 1400, 2600);
 99: 
100:         const createButton = session.page.locator(CREATE_LIST_BUTTON_SELECTOR).first();
101:         if (await createButton.count() === 0) {
102:             return { ok: false, accountId: account.id, message: 'Bottone Create list non trovato' };
103:         }
104:         await humanMouseMove(session.page, CREATE_LIST_BUTTON_SELECTOR);
105:         await humanDelay(session.page, 150, 350);
106:         await createButton.click();
107:         await humanDelay(session.page, 800, 1600);
108: 
109:         const nameInput = session.page.locator(LIST_NAME_INPUT_SELECTOR).first();
110:         if (await nameInput.count() === 0) {
111:             return { ok: false, accountId: account.id, message: 'Input nome lista non trovato' };
112:         }
113:         await nameInput.fill(normalizedListName);
114:         await humanDelay(session.page, 450, 900);
115: 
116:         const confirmButton = session.page.locator(CREATE_LIST_CONFIRM_SELECTOR).first();
117:         if (await confirmButton.count() === 0) {
118:             return { ok: false, accountId: account.id, message: 'Bottone conferma creazione non trovato' };
119:         }
120:         await humanMouseMove(session.page, CREATE_LIST_CONFIRM_SELECTOR);
121:         await humanDelay(session.page, 120, 320);
122:         await confirmButton.click();
123:         await humanDelay(session.page, 1400, 2600);
124:         const resolvedListUrl = await resolveSavedListUrl(session.page, normalizedListName);
125: 
126:         return {
127:             ok: true,
128:             accountId: account.id,
129:             listName: normalizedListName,
130:             listUrl: resolvedListUrl,
131:             message: `Lista creata (best-effort): ${normalizedListName}`,
132:         };
133:     } finally {
134:         await closeBrowser(session);
135:     }
136: }
137: 
138: export async function addLeadToSalesNavList(leadLinkedinUrl: string, listName: string, accountId?: string): Promise<SalesNavActionResult> {
139:     const account = getAccountProfileById(accountId);
140:     const normalizedListName = cleanText(listName);
141:     const normalizedLeadUrl = normalizeLinkedInUrl(leadLinkedinUrl);
142:     if (!normalizedListName) {
143:         return { ok: false, accountId: account.id, message: 'Nome lista non valido' };
144:     }
145:     if (!normalizedLeadUrl) {
146:         return { ok: false, accountId: account.id, message: 'URL lead non valido' };
147:     }
148: 
149:     const session = await launchBrowser({
150:         sessionDir: account.sessionDir,
151:         proxy: account.proxy,
152:     });
153:     try {
154:         const loggedIn = await checkLogin(session.page);
155:         if (!loggedIn) {
156:             return { ok: false, accountId: account.id, message: 'Sessione non autenticata' };
157:         }
158: 
159:         await session.page.goto(normalizedLeadUrl, { waitUntil: 'domcontentloaded' });
160:         await humanDelay(session.page, 1400, 2600);
161: 
162:         const saveButton = session.page.locator(SAVE_TO_LIST_BUTTON_SELECTOR).first();
163:         if (await saveButton.count() === 0) {
164:             return { ok: false, accountId: account.id, message: 'Bottone Save in list non trovato' };
165:         }
166:         await humanMouseMove(session.page, SAVE_TO_LIST_BUTTON_SELECTOR);
167:         await humanDelay(session.page, 160, 340);
168:         await saveButton.click();
169:         await humanDelay(session.page, 900, 1800);
170: 
171:         const listOption = session.page.locator(`text="${normalizedListName}"`).first();
172:         if (await listOption.count() === 0) {
173:             return {
174:                 ok: false,
175:                 accountId: account.id,
176:                 message: `Lista non trovata nel popup: ${normalizedListName}`,
177:             };
178:         }
179:         await listOption.click();
180:         await humanDelay(session.page, 400, 900);
181: 
182:         const confirmButton = session.page.locator(ADD_TO_LIST_CONFIRM_SELECTOR).first();
183:         if (await confirmButton.count() > 0) {
184:             await humanMouseMove(session.page, ADD_TO_LIST_CONFIRM_SELECTOR);
185:             await humanDelay(session.page, 120, 300);
186:             await confirmButton.click();
187:         }
188:         await humanDelay(session.page, 900, 1800);
189:         const resolvedListUrl = await resolveSavedListUrl(session.page, normalizedListName);
190:         return {
191:             ok: true,
192:             accountId: account.id,
193:             listName: normalizedListName,
194:             listUrl: resolvedListUrl,
195:             message: `Lead aggiunto (best-effort) a lista: ${normalizedListName}`,
196:         };
197:     } finally {
198:         await closeBrowser(session);
199:     }
200: }
````

## File: src/salesnav/listScraper.ts
````typescript
  1: import { Page } from 'playwright';
  2: import { humanDelay, humanMouseMove, simulateHumanReading } from '../browser';
  3: import { isLinkedInUrl, normalizeLinkedInUrl } from '../linkedinUrl';
  4: 
  5: export interface SalesNavSavedList {
  6:     name: string;
  7:     url: string;
  8: }
  9: 
 10: export interface SalesNavLeadCandidate {
 11:     linkedinUrl: string;
 12:     firstName: string;
 13:     lastName: string;
 14:     jobTitle: string;
 15:     accountName: string;
 16:     website: string;
 17: }
 18: 
 19: export interface SalesNavListScrapeOptions {
 20:     listUrl: string;
 21:     maxPages: number;
 22:     leadLimit: number;
 23: }
 24: 
 25: export interface SalesNavListScrapeResult {
 26:     pagesVisited: number;
 27:     candidatesDiscovered: number;
 28:     uniqueCandidates: number;
 29:     leads: SalesNavLeadCandidate[];
 30: }
 31: 
 32: interface RawLeadCandidate {
 33:     href: string;
 34:     anchorText: string;
 35:     lines: string[];
 36: }
 37: 
 38: const SALESNAV_LISTS_URL = 'https://www.linkedin.com/sales/lists/people/';
 39: 
 40: const NEXT_PAGE_SELECTOR = [
 41:     'button[aria-label="Next"]',
 42:     'button[aria-label*="Avanti"]',
 43:     'button.artdeco-pagination__button--next',
 44:     'button:has-text("Next")',
 45:     'button:has-text("Avanti")',
 46: ].join(', ');
 47: 
 48: const SHOW_MORE_SELECTOR = [
 49:     'button:has-text("Show more")',
 50:     'button:has-text("Mostra altri")',
 51:     'button:has-text("Show results")',
 52:     'button:has-text("Mostra risultati")',
 53: ].join(', ');
 54: 
 55: function cleanText(value: string): string {
 56:     return value.replace(/\s+/g, ' ').trim();
 57: }
 58: 
 59: function splitName(fullName: string): { firstName: string; lastName: string } {
 60:     const cleaned = cleanText(fullName)
 61:         .replace(/^(dr|dott|mr|mrs|ms)\.?\s+/i, '')
 62:         .trim();
 63:     if (!cleaned) {
 64:         return { firstName: '', lastName: '' };
 65:     }
 66:     const parts = cleaned.split(' ');
 67:     if (parts.length === 1) {
 68:         return { firstName: parts[0], lastName: '' };
 69:     }
 70:     return {
 71:         firstName: parts[0],
 72:         lastName: parts.slice(1).join(' '),
 73:     };
 74: }
 75: 
 76: function looksLikeNoise(line: string): boolean {
 77:     const normalized = line.toLowerCase();
 78:     if (!normalized) return true;
 79:     return normalized.includes('save')
 80:         || normalized.includes('salva')
 81:         || normalized.includes('message')
 82:         || normalized.includes('messaggio')
 83:         || normalized.includes('connect')
 84:         || normalized.includes('collegati')
 85:         || normalized.includes('mutual')
 86:         || normalized.includes('shared')
 87:         || normalized.includes('lead filter')
 88:         || normalized.includes('filtro')
 89:         || normalized.includes('view profile')
 90:         || normalized.includes('visualizza profilo')
 91:         || normalized.includes('sales navigator');
 92: }
 93: 
 94: function pickJobAndAccount(lines: string[], fullName: string): { jobTitle: string; accountName: string } {
 95:     const normalizedName = cleanText(fullName).toLowerCase();
 96:     const candidates = lines
 97:         .map(cleanText)
 98:         .filter((line) => line.length > 1)
 99:         .filter((line) => line.toLowerCase() !== normalizedName)
100:         .filter((line) => !looksLikeNoise(line));
101: 
102:     let jobTitle = '';
103:     let accountName = '';
104: 
105:     for (const line of candidates) {
106:         if (!jobTitle) {
107:             jobTitle = line;
108:         }
109:         if (!accountName) {
110:             const atMatch = line.match(/\b(?:at|presso)\s+(.+)/i);
111:             if (atMatch?.[1]) {
112:                 accountName = cleanText(atMatch[1]);
113:             }
114:         }
115:     }
116: 
117:     if (!accountName && candidates.length > 1) {
118:         accountName = candidates[1];
119:     }
120:     if (!accountName && candidates.length === 1) {
121:         accountName = candidates[0];
122:     }
123: 
124:     return { jobTitle, accountName };
125: }
126: 
127: function parseRawLeadCandidate(raw: RawLeadCandidate): SalesNavLeadCandidate | null {
128:     const normalizedUrl = normalizeLinkedInUrl(raw.href);
129:     if (!isLinkedInUrl(normalizedUrl)) {
130:         return null;
131:     }
132: 
133:     const fullName = cleanText(raw.anchorText) || cleanText(raw.lines[0] ?? '');
134:     const { firstName, lastName } = splitName(fullName);
135:     const { jobTitle, accountName } = pickJobAndAccount(raw.lines, fullName);
136:     return {
137:         linkedinUrl: normalizedUrl,
138:         firstName,
139:         lastName,
140:         jobTitle,
141:         accountName: accountName || fullName,
142:         website: '',
143:     };
144: }
145: 
146: async function extractSavedLists(page: Page): Promise<SalesNavSavedList[]> {
147:     const rows = await page.evaluate(() => {
148:         const seen = new Set<string>();
149:         const results: Array<{ name: string; url: string }> = [];
150:         const anchors = Array.from(document.querySelectorAll('a[href]')) as HTMLAnchorElement[];
151:         for (const anchor of anchors) {
152:             const href = anchor.href || '';
153:             if (!/linkedin\.com\/sales\/lists\/people\//i.test(href)) continue;
154:             if (href.includes('/sales/lists/people/')) {
155:                 // ignore the root page link itself
156:                 const normalizedHref = href.split('#')[0];
157:                 const pathname = (() => {
158:                     try {
159:                         return new URL(normalizedHref).pathname;
160:                     } catch {
161:                         return '';
162:                     }
163:                 })();
164:                 if (/^\/sales\/lists\/people\/?$/i.test(pathname)) continue;
165:                 if (seen.has(normalizedHref)) continue;
166:                 seen.add(normalizedHref);
167:                 const parentText = (anchor.closest('li, article, div') as HTMLElement | null)?.innerText ?? '';
168:                 const name = (anchor.innerText || parentText || '').replace(/\s+/g, ' ').trim();
169:                 if (!name) continue;
170:                 results.push({ name, url: normalizedHref });
171:             }
172:         }
173:         return results;
174:     });
175: 
176:     const byUrl = new Map<string, SalesNavSavedList>();
177:     for (const row of rows) {
178:         const name = cleanText(row.name);
179:         const url = cleanText(row.url);
180:         if (!name || !url) continue;
181:         byUrl.set(url, { name, url });
182:     }
183:     return Array.from(byUrl.values());
184: }
185: 
186: async function extractRawLeadCandidates(page: Page): Promise<RawLeadCandidate[]> {
187:     return page.evaluate(() => {
188:         const matches: RawLeadCandidate[] = [];
189:         const seen = new Set<string>();
190: 
191:         const anchors = Array.from(document.querySelectorAll('a[href]')) as HTMLAnchorElement[];
192:         for (const anchor of anchors) {
193:             const href = anchor.href || anchor.getAttribute('href') || '';
194:             if (!href) continue;
195:             if (!/linkedin\.com\/(sales\/lead|in\/)/i.test(href)) continue;
196: 
197:             const dedupeKey = href.split('#')[0];
198:             if (seen.has(dedupeKey)) continue;
199:             seen.add(dedupeKey);
200: 
201:             const container = anchor.closest('li, article, .artdeco-entity-lockup, [data-test-search-result]') as HTMLElement | null;
202:             const textSource = container?.innerText ?? anchor.innerText ?? '';
203:             const lines = textSource
204:                 .split('\n')
205:                 .map((line) => line.replace(/\s+/g, ' ').trim())
206:                 .filter((line) => line.length > 0)
207:                 .slice(0, 8);
208: 
209:             matches.push({
210:                 href: dedupeKey,
211:                 anchorText: (anchor.innerText || '').replace(/\s+/g, ' ').trim(),
212:                 lines,
213:             });
214:         }
215: 
216:         return matches;
217:     });
218: }
219: 
220: async function clickShowMoreIfPresent(page: Page): Promise<boolean> {
221:     const button = page.locator(SHOW_MORE_SELECTOR).first();
222:     if (await button.count() === 0) {
223:         return false;
224:     }
225:     const disabled = await button.isDisabled().catch(() => false);
226:     if (disabled) {
227:         return false;
228:     }
229:     await humanMouseMove(page, SHOW_MORE_SELECTOR);
230:     await humanDelay(page, 180, 450);
231:     await button.click();
232:     await humanDelay(page, 1200, 2200);
233:     return true;
234: }
235: 
236: async function goToNextPage(page: Page): Promise<boolean> {
237:     const nextButton = page.locator(NEXT_PAGE_SELECTOR).first();
238:     if (await nextButton.count() === 0) {
239:         return false;
240:     }
241: 
242:     const ariaDisabled = (await nextButton.getAttribute('aria-disabled'))?.toLowerCase() === 'true';
243:     const disabled = ariaDisabled || await nextButton.isDisabled().catch(() => false);
244:     if (disabled) {
245:         return false;
246:     }
247: 
248:     await humanMouseMove(page, NEXT_PAGE_SELECTOR);
249:     await humanDelay(page, 180, 420);
250:     await nextButton.click();
251:     await humanDelay(page, 1300, 2600);
252:     return true;
253: }
254: 
255: export async function navigateToSavedLists(page: Page): Promise<SalesNavSavedList[]> {
256:     await page.goto(SALESNAV_LISTS_URL, { waitUntil: 'domcontentloaded' });
257:     await humanDelay(page, 1800, 3200);
258:     await simulateHumanReading(page);
259:     return extractSavedLists(page);
260: }
261: 
262: export async function scrapeLeadsFromSalesNavList(page: Page, options: SalesNavListScrapeOptions): Promise<SalesNavListScrapeResult> {
263:     const maxPages = Math.max(1, options.maxPages);
264:     const leadLimit = Math.max(1, options.leadLimit);
265: 
266:     await page.goto(options.listUrl, { waitUntil: 'domcontentloaded' });
267:     await humanDelay(page, 1500, 2800);
268: 
269:     const byUrl = new Map<string, SalesNavLeadCandidate>();
270:     let pagesVisited = 0;
271:     let candidatesDiscovered = 0;
272: 
273:     for (let pageNumber = 1; pageNumber <= maxPages; pageNumber++) {
274:         pagesVisited = pageNumber;
275:         await simulateHumanReading(page);
276: 
277:         // Prova 1-2 volte a espandere risultati nella pagina corrente.
278:         for (let i = 0; i < 2; i++) {
279:             const expanded = await clickShowMoreIfPresent(page);
280:             if (!expanded) break;
281:             await simulateHumanReading(page);
282:         }
283: 
284:         const rawCandidates = await extractRawLeadCandidates(page);
285:         candidatesDiscovered += rawCandidates.length;
286:         for (const raw of rawCandidates) {
287:             const parsed = parseRawLeadCandidate(raw);
288:             if (!parsed) continue;
289:             byUrl.set(parsed.linkedinUrl, parsed);
290:             if (byUrl.size >= leadLimit) {
291:                 break;
292:             }
293:         }
294: 
295:         if (byUrl.size >= leadLimit) {
296:             break;
297:         }
298:         if (pageNumber >= maxPages) {
299:             break;
300:         }
301: 
302:         const moved = await goToNextPage(page);
303:         if (!moved) {
304:             break;
305:         }
306:     }
307: 
308:     return {
309:         pagesVisited,
310:         candidatesDiscovered,
311:         uniqueCandidates: byUrl.size,
312:         leads: Array.from(byUrl.values()).slice(0, leadLimit),
313:     };
314: }
````

## File: src/scripts/rampUp.ts
````typescript
 1: import { initDatabase, closeDatabase } from '../db';
 2: import { getRiskInputs, listLeadCampaignConfigs, updateLeadCampaignConfig } from '../core/repositories';
 3: import { evaluateRisk } from '../risk/riskEngine';
 4: import { config, getLocalDateString } from '../config';
 5: 
 6: const RAMP_UP_SCHEDULE = [
 7:     { day: 1, inviteCap: 5, messageCap: 5 },
 8:     { day: 2, inviteCap: 10, messageCap: 10 },
 9:     { day: 3, inviteCap: 15, messageCap: 15 },
10:     { day: 4, inviteCap: 20, messageCap: 20 },
11:     { day: 5, inviteCap: 25, messageCap: 30 },
12:     { day: 6, inviteCap: 30, messageCap: 40 },
13:     { day: 7, inviteCap: 40, messageCap: 50 } // Obiettivo finale a regime moderato
14: ];
15: 
16: async function runRampUp(listName: string, targetDay: number | 'auto') {
17:     try {
18:         await initDatabase();
19: 
20:         // 1. Check current risk
21:         const localDate = getLocalDateString();
22:         const riskInputs = await getRiskInputs(localDate, config.hardInviteCap);
23:         const evaluation = evaluateRisk(riskInputs);
24: 
25:         console.log(`[Ramp-Up] Valutazione Rischio Attuale: ${evaluation.score}/100 [Azione: ${evaluation.action}]`);
26: 
27:         if (evaluation.action === 'WARN' || evaluation.action === 'STOP') {
28:             console.error(`[Ramp-Up] ‚ùå Rischio troppo elevato (${evaluation.action}) per scalare i limiti. Rimandare ad andamento normalizzato.`);
29:             process.exit(1);
30:         }
31: 
32:         // 2. Resolve the target lists
33:         const configs = await listLeadCampaignConfigs();
34:         const targetConfigs = listName === 'all'
35:             ? configs
36:             : configs.filter(c => c.name.toLowerCase() === listName.toLowerCase());
37: 
38:         if (targetConfigs.length === 0) {
39:             console.error(`[Ramp-Up] ‚ùå Nessuna configurazione trovata per la lista: ${listName}`);
40:             process.exit(1);
41:         }
42: 
43:         // 3. Apply the ramp up based on day
44:         let schedule;
45:         if (targetDay === 'auto') {
46:             // Find the lowest current invite cap to determine the starting point safely
47:             const minCurrentCap = Math.min(...targetConfigs.map(c => c.dailyInviteCap ?? 0));
48:             // Find the first schedule step that is higher than the current min cap
49:             schedule = RAMP_UP_SCHEDULE.find(s => s.inviteCap > minCurrentCap) || RAMP_UP_SCHEDULE[RAMP_UP_SCHEDULE.length - 1];
50:             console.log(`[Ramp-Up] Auto-resolve: limite attuale minimo = ${minCurrentCap}. Passiamo al Giorno ${schedule.day}.`);
51:         } else {
52:             schedule = RAMP_UP_SCHEDULE.find(s => s.day === targetDay) || RAMP_UP_SCHEDULE[RAMP_UP_SCHEDULE.length - 1];
53:         }
54: 
55:         console.log(`[Ramp-Up] Applicazione parametri del Giorno ${schedule.day}`);
56:         console.log(` -> Nuovi Limiti: ${schedule.inviteCap} Inviti / ${schedule.messageCap} Messaggi`);
57: 
58:         for (const cfg of targetConfigs) {
59:             console.log(` - Aggiornamento lista: ${cfg.name}`);
60:             await updateLeadCampaignConfig(cfg.name, {
61:                 dailyInviteCap: schedule.inviteCap,
62:                 dailyMessageCap: schedule.messageCap,
63:                 isActive: true
64:             });
65:         }
66: 
67:         console.log(`[Ramp-Up] ‚úÖ Limiti aggiornati con successo.`);
68: 
69:     } catch (err) {
70:         console.error('[Ramp-Up] Errore:', err);
71:         process.exitCode = 1;
72:     } finally {
73:         await closeDatabase();
74:     }
75: }
76: 
77: const args = process.argv.slice(2);
78: if (args.includes('--help') || args.length === 0) {
79:     console.log(`
80: Uso: ts-node src/scripts/rampUp.ts <list-name|all> <day-number>
81: 
82: Esempio:
83:   ts-node src/scripts/rampUp.ts "My List" 3
84:   ts-node src/scripts/rampUp.ts all 1
85:     `);
86:     process.exit(0);
87: }
88: 
89: const listTarget = args[0];
90: const dayTarget = parseInt(args[1], 10) || 1;
91: 
92: runRampUp(listTarget, dayTarget).catch(console.error);
````

## File: src/security/filesystem.ts
````typescript
 1: import fs from 'fs';
 2: import path from 'path';
 3: 
 4: function chmodSafe(targetPath: string, mode: number): void {
 5:     if (process.platform === 'win32') {
 6:         return;
 7:     }
 8:     try {
 9:         fs.chmodSync(targetPath, mode);
10:     } catch {
11:         // Best effort: non bloccare runtime in caso di FS non compatibile.
12:     }
13: }
14: 
15: export function ensureDirectoryPrivate(directoryPath: string): void {
16:     if (!fs.existsSync(directoryPath)) {
17:         fs.mkdirSync(directoryPath, { recursive: true });
18:     }
19:     chmodSafe(directoryPath, 0o700);
20: }
21: 
22: export function ensureParentDirectoryPrivate(filePath: string): void {
23:     const directoryPath = path.dirname(filePath);
24:     ensureDirectoryPrivate(directoryPath);
25: }
26: 
27: export function ensureFilePrivate(filePath: string): void {
28:     if (!fs.existsSync(filePath)) {
29:         return;
30:     }
31:     chmodSafe(filePath, 0o600);
32: }
````

## File: src/sync/eventSync.ts
````typescript
 1: import { config, EventSyncSink } from '../config';
 2: import { SyncStatus, getSyncStatus as getSupabaseSyncStatus, runSupabaseSyncOnce } from './supabaseSyncWorker';
 3: import { WebhookSyncStatus, getWebhookSyncStatus, runWebhookSyncOnce } from './webhookSyncWorker';
 4: 
 5: export interface EventSyncStatus {
 6:     activeSink: EventSyncSink;
 7:     enabled: boolean;
 8:     configured: boolean;
 9:     pendingOutbox: number;
10:     warning: string | null;
11:     supabase: SyncStatus;
12:     webhook: WebhookSyncStatus;
13: }
14: 
15: function buildSinkWarning(supabase: SyncStatus, webhook: WebhookSyncStatus): string | null {
16:     if (config.supabaseSyncEnabled && config.webhookSyncEnabled) {
17:         return `Entrambi i sink sono attivi ma verra usato solo EVENT_SYNC_SINK=${config.eventSyncSink}.`;
18:     }
19:     if (config.eventSyncSink === 'SUPABASE' && !config.supabaseSyncEnabled) {
20:         return 'EVENT_SYNC_SINK=SUPABASE ma SUPABASE_SYNC_ENABLED=false.';
21:     }
22:     if (config.eventSyncSink === 'WEBHOOK' && !config.webhookSyncEnabled) {
23:         return 'EVENT_SYNC_SINK=WEBHOOK ma WEBHOOK_SYNC_ENABLED=false.';
24:     }
25:     if (config.eventSyncSink === 'SUPABASE' && config.supabaseSyncEnabled && !supabase.configured) {
26:         return 'SUPABASE_SYNC_ENABLED=true ma SUPABASE_URL/SUPABASE_SERVICE_ROLE_KEY non configurati.';
27:     }
28:     if (config.eventSyncSink === 'WEBHOOK' && config.webhookSyncEnabled && !webhook.configured) {
29:         return 'WEBHOOK_SYNC_ENABLED=true ma WEBHOOK_SYNC_URL non configurato.';
30:     }
31:     return null;
32: }
33: 
34: export async function getEventSyncStatus(): Promise<EventSyncStatus> {
35:     const [supabase, webhook] = await Promise.all([getSupabaseSyncStatus(), getWebhookSyncStatus()]);
36:     const warning = buildSinkWarning(supabase, webhook);
37: 
38:     if (config.eventSyncSink === 'NONE') {
39:         return {
40:             activeSink: 'NONE',
41:             enabled: false,
42:             configured: true,
43:             pendingOutbox: supabase.pendingOutbox,
44:             warning,
45:             supabase,
46:             webhook,
47:         };
48:     }
49: 
50:     const active = config.eventSyncSink === 'WEBHOOK' ? webhook : supabase;
51:     return {
52:         activeSink: config.eventSyncSink,
53:         enabled: active.enabled,
54:         configured: active.configured,
55:         pendingOutbox: active.pendingOutbox,
56:         warning,
57:         supabase,
58:         webhook,
59:     };
60: }
61: 
62: export async function runEventSyncOnce(): Promise<void> {
63:     if (config.eventSyncSink === 'NONE') {
64:         return;
65:     }
66: 
67:     if (config.eventSyncSink === 'WEBHOOK') {
68:         await runWebhookSyncOnce();
69:         return;
70:     }
71: 
72:     await runSupabaseSyncOnce();
73: }
````

## File: src/sync/supabase.schema.sql
````sql
 1: create table if not exists public.cp_events (
 2:     id bigserial primary key,
 3:     topic text not null,
 4:     payload jsonb not null,
 5:     idempotency_key text not null unique,
 6:     created_at timestamptz not null default now()
 7: );
 8: 
 9: create table if not exists public.cp_daily_kpis (
10:     id bigserial primary key,
11:     local_date date not null,
12:     metric_name text not null,
13:     metric_value numeric not null,
14:     created_at timestamptz not null default now()
15: );
16: 
17: create table if not exists public.cp_incidents (
18:     id bigserial primary key,
19:     incident_type text not null,
20:     severity text not null,
21:     details jsonb not null,
22:     opened_at timestamptz not null default now()
23: );
24: 
25: create table if not exists public.cp_worker_runs (
26:     id bigserial primary key,
27:     worker_name text not null,
28:     status text not null,
29:     details jsonb not null,
30:     created_at timestamptz not null default now()
31: );
````

## File: src/telemetry/dailyReporter.ts
````typescript
 1: import { sendTelegramAlert } from './alerts';
 2: import { getDailyStatsSnapshot } from '../core/repositories';
 3: import { getDatabase } from '../db';
 4: import { getLocalDateString } from '../config';
 5: 
 6: export async function generateAndSendDailyReport(targetDate?: string): Promise<boolean> {
 7:     const localDate = targetDate || getLocalDateString();
 8: 
 9:     // Raccogliamo i dati aggregati di tutto il giorno da `daily_stats`
10:     const stats = await getDailyStatsSnapshot(localDate);
11: 
12:     // Contiamo le conversioni e l'impatto funnel globale attingendo alla tabella leads
13:     const db = await getDatabase();
14: 
15:     const leadsAccepted = await db.get<{ count: number }>(`
16:         SELECT COUNT(*) as count FROM leads WHERE accepted_at LIKE ? || '%'
17:     `, [localDate]);
18: 
19:     const leadsMessaged = await db.get<{ count: number }>(`
20:         SELECT COUNT(*) as count FROM leads WHERE messaged_at LIKE ? || '%'
21:     `, [localDate]);
22: 
23:     const leadsReplied = await db.get<{ count: number }>(`
24:         SELECT COUNT(*) as count FROM leads WHERE status = 'REPLIED' AND updated_at LIKE ? || '%'
25:     `, [localDate]);
26: 
27:     const campaignRunsStats = await db.get<{
28:         total_runs: number,
29:         total_discovered: number,
30:         failed_runs: number
31:     }>(`
32:         SELECT 
33:             COUNT(id) as total_runs, 
34:             COALESCE(SUM(profiles_discovered), 0) as total_discovered,
35:             SUM(CASE WHEN status = 'FAILED' THEN 1 ELSE 0 END) as failed_runs
36:         FROM campaign_runs 
37:         WHERE start_time LIKE ? || '%'
38:     `, [localDate]);
39: 
40:     // Format Report Markdown per Telegram
41:     const reportText = [
42:         `üìä *Daily Performance Summary (${localDate})* üìä`,
43:         `\n*üî• Funnel Metrics*`,
44:         `‚Ä¢ Nuovi Lead Scoperti: *${campaignRunsStats?.total_discovered ?? 0}*`,
45:         `‚Ä¢ Inviti Spediti: *${stats.invitesSent}*`,
46:         `‚Ä¢ Nuove Connessioni Accettate: *${leadsAccepted?.count ?? 0}*`,
47:         `‚Ä¢ Messaggi Follow-Up: *${leadsMessaged?.count ?? 0}*`,
48:         `‚Ä¢ Risposte Ricevute: *${leadsReplied?.count ?? 0}*`,
49:         `\n*ü§ñ Bot Execution*`,
50:         `‚Ä¢ Campaign Runs Totali: *${campaignRunsStats?.total_runs ?? 0}*`,
51:         `‚Ä¢ Fallimenti Critici Runs: *${campaignRunsStats?.failed_runs ?? 0}*`,
52:         `\n*‚ö†Ô∏è Risk & Health*`,
53:         `‚Ä¢ Errori Esecuzione (Job/Orchestrator): *${stats.runErrors}*`,
54:         `‚Ä¢ Problemi Selettori UI: *${stats.selectorFailures}*`,
55:         `‚Ä¢ Challenge LinkedIn Apparse: *${stats.challengesCount}*`
56:     ].join('\n');
57: 
58:     // Manda usando lo stesso sendTelegramAlert.
59:     // Nessun severity prefix o usiamo `info`. Useremo un titolo per mascherare il pallino.
60:     await sendTelegramAlert(reportText, 'LinkedIn Bot Daily Report', 'info');
61: 
62:     console.log(`[DAILY_REPORTER] Report inviato a Telegram per la data ${localDate}`);
63:     return true;
64: }
````

## File: src/telemetry/kpiReporter.ts
````typescript
 1: import { getGlobalKPIData, getRiskInputs } from '../core/repositories';
 2: import { evaluateRisk } from '../risk/riskEngine';
 3: import { getLocalDateString, config } from '../config';
 4: 
 5: export async function printDashboard(): Promise<void> {
 6:     const kpi = await getGlobalKPIData();
 7:     const localDate = getLocalDateString();
 8:     const riskInputs = await getRiskInputs(localDate, config.hardInviteCap);
 9:     const risk = await evaluateRisk(riskInputs);
10: 
11:     const invited = kpi.statusCounts['INVITED'] || 0;
12:     const accepted = kpi.statusCounts['ACCEPTED'] || 0;
13:     const readyMessage = kpi.statusCounts['READY_MESSAGE'] || 0;
14:     const messaged = kpi.statusCounts['MESSAGED'] || 0;
15:     const replied = kpi.statusCounts['REPLIED'] || 0;
16:     const pendingHygiene = kpi.statusCounts['WITHDRAWN'] || 0;
17: 
18:     const totalAccepted = accepted + readyMessage + messaged + replied;
19:     const totalMessaged = messaged + replied;
20: 
21:     const inviteToAcceptRate = invited + totalAccepted > 0
22:         ? ((totalAccepted / (invited + totalAccepted)) * 100).toFixed(1) + '%'
23:         : '0.0%';
24: 
25:     const acceptToReplyRate = totalAccepted > 0
26:         ? ((replied / totalAccepted) * 100).toFixed(1) + '%'
27:         : '0.0%';
28: 
29:     console.log('\n======================================================');
30:     console.log('                 üìä DASHBOARD KPIs üìä                 ');
31:     console.log('======================================================\n');
32: 
33:     console.log('--- 1. FUNNEL & CONVERSION (Total Database) ---');
34:     console.log(`  Total Leads:       ${kpi.totalLeads}`);
35:     console.log(`  Invited (Pending): ${invited}`);
36:     console.log(`  Total Accepted:    ${totalAccepted}  --> (Acceptance Rate: ${inviteToAcceptRate})`);
37:     console.log(`  Total Messaged:    ${totalMessaged}`);
38:     console.log(`  Total Replied:     ${replied}  --> (Reply Rate from Accepted: ${acceptToReplyRate})`);
39:     console.log(`  Withdrawn:         ${pendingHygiene}`);
40:     console.log('');
41: 
42:     console.log('--- 2. ACTIVE SYSTEM STATUS ---');
43:     console.log(`  Active Campaigns:  ${kpi.activeCampaigns}`);
44:     console.log(`  Acceptances (7d):  ${kpi.totalAcceptances7d}`);
45:     console.log('');
46: 
47:     console.log('--- 3. RISK ENGINE SNAPSHOT ---');
48:     console.log(`  Global Action:     ${risk.action}`);
49:     console.log(`  Risk Score:        ${risk.score.toFixed(1)}`);
50:     console.log('======================================================\n');
51: }
````

## File: src/telemetry/logger.ts
````typescript
 1: import { recordRunLog } from '../core/repositories';
 2: import { sanitizeForLogs } from '../security/redaction';
 3: 
 4: export async function logInfo(event: string, payload: Record<string, unknown> = {}): Promise<void> {
 5:     const safePayload = sanitizeForLogs(payload);
 6:     console.log(`[INFO] ${event}`, safePayload);
 7:     await recordRunLog('INFO', event, safePayload);
 8: }
 9: 
10: export async function logWarn(event: string, payload: Record<string, unknown> = {}): Promise<void> {
11:     const safePayload = sanitizeForLogs(payload);
12:     console.warn(`[WARN] ${event}`, safePayload);
13:     await recordRunLog('WARN', event, safePayload);
14: }
15: 
16: export async function logError(event: string, payload: Record<string, unknown> = {}): Promise<void> {
17:     const safePayload = sanitizeForLogs(payload);
18:     console.error(`[ERROR] ${event}`, safePayload);
19:     await recordRunLog('ERROR', event, safePayload);
20: }
````

## File: src/validation/messageValidator.ts
````typescript
 1: import crypto from 'crypto';
 2: import { MessageValidationResult } from '../types/domain';
 3: 
 4: export interface MessageValidationContext {
 5:     duplicateCountLast24h: number;
 6:     maxLen?: number;
 7: }
 8: 
 9: export function extractUnresolvedPlaceholders(message: string): string[] {
10:     const matches = message.match(/\{\{[^}]+\}\}|\[[^\]]+\]/g);
11:     return matches ?? [];
12: }
13: 
14: export function hashMessage(message: string): string {
15:     return crypto.createHash('sha256').update(message).digest('hex');
16: }
17: 
18: export function validateMessageContent(message: string, context: MessageValidationContext): MessageValidationResult {
19:     const reasons: string[] = [];
20:     const trimmed = message.trim();
21:     const maxLen = context.maxLen ?? 550;
22: 
23:     if (!trimmed) {
24:         reasons.push('Messaggio vuoto.');
25:     }
26:     if (trimmed.length > maxLen) {
27:         reasons.push(`Messaggio troppo lungo (${trimmed.length}/${maxLen}).`);
28:     }
29:     const unresolved = extractUnresolvedPlaceholders(trimmed);
30:     if (unresolved.length > 0) {
31:         reasons.push(`Placeholder non risolti: ${unresolved.join(', ')}`);
32:     }
33:     if (context.duplicateCountLast24h >= 3) {
34:         reasons.push('Messaggio troppo ripetitivo nelle ultime 24h.');
35:     }
36: 
37:     return {
38:         valid: reasons.length === 0,
39:         reasons,
40:     };
41: }
````

## File: src/workers/errors.ts
````typescript
 1: export class RetryableWorkerError extends Error {
 2:     public readonly code: string;
 3: 
 4:     constructor(message: string, code: string = 'RETRYABLE') {
 5:         super(message);
 6:         this.name = 'RetryableWorkerError';
 7:         this.code = code;
 8:     }
 9: }
10: 
11: export class ChallengeDetectedError extends Error {
12:     constructor(message: string = 'Challenge/CAPTCHA rilevato') {
13:         super(message);
14:         this.name = 'ChallengeDetectedError';
15:     }
16: }
````

## File: src/workers/hygieneWorker.ts
````typescript
 1: import { WorkerContext } from './context';
 2: import { getExpiredInvitedLeads } from '../core/repositories';
 3: import { transitionLead } from '../core/leadStateService';
 4: import { logInfo, logError } from '../telemetry/logger';
 5: import { humanDelay } from '../browser';
 6: import { config } from '../config';
 7: 
 8: export interface HygieneJobPayload {
 9:     accountId: string;
10: }
11: 
12: export async function processHygieneJob(payload: { accountId: string }, context: WorkerContext): Promise<void> {
13:     if (!config.withdrawInvitesEnabled) return;
14: 
15:     const expired = await getExpiredInvitedLeads(payload.accountId, config.pendingInviteMaxDays);
16:     if (!expired || expired.length === 0) {
17:         await logInfo('hygiene.no_expired_invites', { accountId: payload.accountId });
18:         return;
19:     }
20: 
21:     await logInfo('hygiene.found_expired_invites', { count: expired.length, accountId: payload.accountId });
22:     const page = context.session.page;
23: 
24:     for (const lead of expired) {
25:         if (context.dryRun) {
26:             console.log(`[DRY RUN] Hygiene ritirerebbe invito per lead ${lead.linkedin_url}`);
27:             continue;
28:         }
29: 
30:         try {
31:             await page.goto(lead.linkedin_url, { waitUntil: 'domcontentloaded' });
32:             await humanDelay(page, 2000, 4000);
33: 
34:             // Cerca bottone "In attesa" / "Pending"
35:             const pendingBtn = page.locator('button:has-text("Pending"), button:has-text("In attesa")').first();
36:             if (await pendingBtn.count() > 0) {
37:                 await pendingBtn.click();
38:                 await humanDelay(page, 700, 1500);
39: 
40:                 // Nel modale, cerca "Ritira" / "Withdraw"
41:                 const withdrawAction = page.locator('div.artdeco-dropdown__content button:has-text("Withdraw"), div.artdeco-dropdown__content button:has-text("Ritira")').first();
42:                 if (await withdrawAction.isVisible()) {
43:                     await withdrawAction.click();
44:                     await humanDelay(page, 700, 1200);
45: 
46:                     // Conferma finale nel dialog modale
47:                     const confirmDialog = page.locator('.artdeco-modal button.artdeco-button--primary:has-text("Withdraw"), .artdeco-modal button.artdeco-button--primary:has-text("Ritira")').first();
48:                     if (await confirmDialog.isVisible()) {
49:                         await confirmDialog.click();
50:                         await transitionLead(lead.id, 'WITHDRAWN', 'auto_hygiene_policy', { days_old: config.pendingInviteMaxDays });
51:                         await logInfo('hygiene.invite_withdrawn', { leadId: lead.id, accountId: payload.accountId });
52:                     }
53:                 }
54:             } else {
55:                 // Se non troviamo il pending, lo marchiamo in review
56:                 await transitionLead(lead.id, 'REVIEW_REQUIRED', 'hygiene_button_pending_not_found');
57:             }
58: 
59:             await humanDelay(page, 1500, 3000);
60:         } catch (e: unknown) {
61:             const message = e instanceof Error ? e.message : String(e);
62:             await logError('hygiene.worker.error', { leadId: lead.id, error: message });
63:             await transitionLead(lead.id, 'REVIEW_REQUIRED', 'hygiene_error_on_dom_execution');
64:         }
65:     }
66: }
````

## File: src/workers/inboxWorker.ts
````typescript
 1: import { humanDelay, humanMouseMove, simulateHumanReading } from '../browser';
 2: import { WorkerContext } from './context';
 3: import { analyzeIncomingMessage } from '../ai/sentimentAnalysis';
 4: import { logInfo, logWarn } from '../telemetry/logger';
 5: 
 6: export interface InboxJobPayload {
 7:     accountId: string;
 8: }
 9: 
10: export async function processInboxJob(payload: InboxJobPayload, context: WorkerContext): Promise<void> {
11:     const page = context.session.page;
12:     await page.goto('https://www.linkedin.com/messaging/', { waitUntil: 'domcontentloaded' });
13:     await simulateHumanReading(page);
14: 
15:     // Aspetta che i messaggi vengano caricati
16:     try {
17:         await page.waitForSelector('.msg-conversation-listitem', { timeout: 10000 });
18:     } catch {
19:         await logWarn('inbox.no_conversations', { message: 'Nessuna conversazione trovata o timeout' });
20:         return;
21:     }
22: 
23:     const unreadConversations = page.locator('.msg-conversation-listitem:has(.msg-conversation-card__unread-count)');
24:     const count = await unreadConversations.count();
25: 
26:     if (count === 0) {
27:         await logInfo('inbox.no_unread', { message: 'Nessun messaggio non letto trovato' });
28:         return;
29:     }
30: 
31:     for (let i = 0; i < Math.min(count, 5); i++) {
32:         const convo = unreadConversations.nth(i);
33:         await humanMouseMove(page, '.msg-conversation-listitem:has(.msg-conversation-card__unread-count)');
34:         await humanDelay(page, 200, 600);
35:         await convo.click();
36: 
37:         await humanDelay(page, 1500, 3000); // Wait for chat to load
38: 
39:         // Estrai l'ultimo messaggio visibile dell'interlocutore
40:         const lastMessageLocator = page.locator('.msg-s-message-list__event:not([data-msg-s-message-event-is-me="true"]) .msg-s-event-listitem__body').last();
41: 
42:         if (await lastMessageLocator.isVisible()) {
43:             const rawText = await lastMessageLocator.innerText();
44:             if (rawText && rawText.trim().length > 0) {
45:                 // Analisi Sentiment (NLP)
46:                 const sentiment = await analyzeIncomingMessage(rawText.trim());
47:                 await logInfo('inbox.analyzed_message', {
48:                     textExcerpt: rawText.substring(0, 30),
49:                     intent: sentiment.intent,
50:                     confidence: sentiment.confidence
51:                 });
52: 
53:                 //TODO: Aggiorna lo stato del Lead in base all'intent (es. tag 'INTERESTED' o blocca bot)
54:             }
55:         }
56: 
57:         await humanDelay(page, 1000, 2000);
58:     }
59: }
````

## File: src/workers/randomActivityWorker.ts
````typescript
  1: import { getAccountProfileById } from '../accountManager';
  2: import { checkLogin, closeBrowser, humanDelay, launchBrowser, randomMouseMove, simulateHumanReading } from '../browser';
  3: 
  4: export interface RandomActivityOptions {
  5:     accountId?: string;
  6:     maxActions: number;
  7:     dryRun: boolean;
  8: }
  9: 
 10: export interface RandomActivityReport {
 11:     accountId: string;
 12:     dryRun: boolean;
 13:     actionsRequested: number;
 14:     actionsExecuted: number;
 15:     visitedUrls: string[];
 16:     profileVisits: number;
 17:     errors: number;
 18: }
 19: 
 20: type Activity = 'home' | 'notifications' | 'network' | 'settings' | 'profile_from_page';
 21: 
 22: const STATIC_ACTIVITY_URLS: Record<Exclude<Activity, 'profile_from_page'>, string> = {
 23:     home: 'https://www.linkedin.com/feed/',
 24:     notifications: 'https://www.linkedin.com/notifications/',
 25:     network: 'https://www.linkedin.com/mynetwork/',
 26:     settings: 'https://www.linkedin.com/mypreferences/d/categories/account',
 27: };
 28: 
 29: function pickRandom<T>(items: T[]): T {
 30:     return items[Math.floor(Math.random() * items.length)];
 31: }
 32: 
 33: async function extractProfileUrlsFromCurrentPage(page: import('playwright').Page): Promise<string[]> {
 34:     const urls = await page.evaluate(() => {
 35:         const anchors = Array.from(document.querySelectorAll('a[href]')) as HTMLAnchorElement[];
 36:         return anchors
 37:             .map((anchor) => anchor.href || '')
 38:             .filter((href) => /linkedin\.com\/in\//i.test(href))
 39:             .map((href) => href.split('?')[0])
 40:             .slice(0, 20);
 41:     }).catch(() => [] as string[]);
 42:     return Array.from(new Set(urls));
 43: }
 44: 
 45: async function runSingleActivity(
 46:     page: import('playwright').Page,
 47:     activity: Activity,
 48:     report: RandomActivityReport
 49: ): Promise<void> {
 50:     if (activity === 'profile_from_page') {
 51:         const profiles = await extractProfileUrlsFromCurrentPage(page);
 52:         if (profiles.length === 0) {
 53:             return;
 54:         }
 55:         const profileUrl = pickRandom(profiles);
 56:         await page.goto(profileUrl, { waitUntil: 'domcontentloaded' });
 57:         report.visitedUrls.push(profileUrl);
 58:         report.profileVisits += 1;
 59:         await humanDelay(page, 2000, 4200);
 60:         await simulateHumanReading(page);
 61:         return;
 62:     }
 63: 
 64:     const targetUrl = STATIC_ACTIVITY_URLS[activity];
 65:     await page.goto(targetUrl, { waitUntil: 'domcontentloaded' });
 66:     report.visitedUrls.push(targetUrl);
 67:     await humanDelay(page, 1800, 3600);
 68:     await simulateHumanReading(page);
 69: 
 70:     if (Math.random() < 0.35) {
 71:         await randomMouseMove(page);
 72:     }
 73: }
 74: 
 75: export async function runRandomLinkedinActivity(options: RandomActivityOptions): Promise<RandomActivityReport> {
 76:     const account = getAccountProfileById(options.accountId);
 77:     const actionsRequested = Math.max(1, options.maxActions);
 78: 
 79:     const report: RandomActivityReport = {
 80:         accountId: account.id,
 81:         dryRun: options.dryRun,
 82:         actionsRequested,
 83:         actionsExecuted: 0,
 84:         visitedUrls: [],
 85:         profileVisits: 0,
 86:         errors: 0,
 87:     };
 88: 
 89:     if (options.dryRun) {
 90:         return report;
 91:     }
 92: 
 93:     const session = await launchBrowser({
 94:         sessionDir: account.sessionDir,
 95:         proxy: account.proxy,
 96:     });
 97:     try {
 98:         const loggedIn = await checkLogin(session.page);
 99:         if (!loggedIn) {
100:             return report;
101:         }
102: 
103:         const activityPool: Activity[] = [
104:             'home',
105:             'notifications',
106:             'network',
107:             'settings',
108:             'profile_from_page',
109:         ];
110: 
111:         for (let i = 0; i < actionsRequested; i++) {
112:             const activity = pickRandom(activityPool);
113:             try {
114:                 await runSingleActivity(session.page, activity, report);
115:                 report.actionsExecuted += 1;
116:             } catch {
117:                 report.errors += 1;
118:             }
119:             await humanDelay(session.page, 1200, 2800);
120:         }
121: 
122:         return report;
123:     } finally {
124:         await closeBrowser(session);
125:     }
126: }
````

## File: tsconfig.json
````json
 1: {
 2:     "compilerOptions": {
 3:         "target": "ES2022",
 4:         "module": "CommonJS",
 5:         "outDir": "./dist",
 6:         "rootDir": "./src",
 7:         "strict": true,
 8:         "esModuleInterop": true,
 9:         "skipLibCheck": true,
10:         "forceConsistentCasingInFileNames": true,
11:         "resolveJsonModule": true
12:     },
13:     "include": [
14:         "src/**/*"
15:     ],
16:     "exclude": [
17:         "node_modules",
18:         "dist"
19:     ]
20: }
````

## File: INTEGRATIONS.md
````markdown
 1: # Integrations Guide
 2: 
 3: This bot can export control-plane events from `outbox_events` to one sink at a time:
 4: - `SUPABASE` (table `cp_events`)
 5: - `WEBHOOK` (for n8n, Make, Pipedream, custom middleware)
 6: 
 7: In addition, when enabled, it can pull campaign configuration from Supabase table `campaigns`
 8: and apply it to local `lead_lists` (control-plane mode).
 9: 
10: Set the active sink with:
11: 
12: ```env
13: EVENT_SYNC_SINK=SUPABASE
14: ```
15: 
16: Allowed values: `SUPABASE`, `WEBHOOK`, `NONE`.
17: 
18: ## n8n Setup (recommended external orchestrator)
19: 
20: 1. Create a workflow with a `Webhook` trigger (POST).
21: 2. Add an auth guard step:
22:    - verify `x-signature-sha256` if `WEBHOOK_SYNC_SECRET` is configured
23:    - deduplicate by `x-idempotency-key`
24: 3. Route by `topic` (for example `lead.transition`, `lead.reconciled`, `scheduler.snapshot`, `incident.opened`).
25: 4. Add actions (alerts, CRM update, BI, ticketing, etc.).
26: 
27: Bot `.env` example:
28: 
29: ```env
30: EVENT_SYNC_SINK=WEBHOOK
31: WEBHOOK_SYNC_ENABLED=true
32: WEBHOOK_SYNC_URL=https://your-n8n-host/webhook/linkedin-events
33: WEBHOOK_SYNC_SECRET=replace_with_long_random_secret
34: WEBHOOK_SYNC_BATCH_SIZE=100
35: WEBHOOK_SYNC_TIMEOUT_MS=10000
36: WEBHOOK_SYNC_MAX_RETRIES=8
37: 
38: # Optional: disable Supabase sink if not used
39: SUPABASE_SYNC_ENABLED=false
40: ```
41: 
42: ## Supabase Control Plane (campaign configs)
43: 
44: Enable remote campaign management:
45: 
46: ```env
47: SUPABASE_SYNC_ENABLED=true
48: SUPABASE_CONTROL_PLANE_ENABLED=true
49: SUPABASE_CONTROL_PLANE_SYNC_INTERVAL_MS=300000
50: SUPABASE_CONTROL_PLANE_MAX_CAMPAIGNS=500
51: ```
52: 
53: Source table: `campaigns` with fields:
54: - `name`
55: - `is_active`
56: - `priority`
57: - `daily_invite_cap`
58: - `daily_message_cap`
59: 
60: The bot maps those fields into local `lead_lists` (source=`control_plane`).
61: 
62: ## Payload format sent to Webhook sink
63: 
64: ```json
65: {
66:   "topic": "lead.transition",
67:   "payload": { "leadId": 123, "fromStatus": "READY_INVITE", "toStatus": "INVITED" },
68:   "idempotencyKey": "lead.transition:123:READY_INVITE:INVITED:invite_sent",
69:   "createdAt": "2026-02-25 20:10:00"
70: }
71: ```
72: 
73: Headers:
74: - `x-idempotency-key`
75: - `x-event-topic`
76: - `x-signature-sha256` (only if `WEBHOOK_SYNC_SECRET` is configured)
77: 
78: ## Operational commands
79: 
80: - Check sink status: `.\bot.ps1 sync-status`
81: - Force one sync batch: `.\bot.ps1 sync-run-once`
82: - Force control-plane pull now: `.\bot.ps1 control-plane-sync --force`
83: 
84: ## Notes
85: 
86: - Do not enable stealth/evasion tooling. Keep automation conservative and policy-safe.
87: - Keep only one active sink in production to avoid configuration ambiguity.
88: - If both sink toggles are enabled, `EVENT_SYNC_SINK` decides which sink is used.
````

## File: SECURITY.md
````markdown
 1: # Security & Privacy Hardening
 2: 
 3: ## What is already hardened
 4: - No stealth/evasion browser plugins in runtime dependencies.
 5: - No fingerprint-evasion runtime patch injected into browser pages.
 6: - Automatic pause/quarantine on risk bursts.
 7: - Sensitive log redaction (`token`, `key`, `cookie`, JWT-like values).
 8: - Local session and DB storage created with private-permission best effort.
 9: - Privacy retention cleanup command to reduce stored historical data.
10: - AI integration is fail-safe: if AI API fails, bot falls back to local template/heuristics.
11: 
12: ## Daily operator workflow
13: 1. `.\bot.ps1 doctor`
14: 2. `.\bot.ps1 status`
15: 3. Run jobs only if `sessionLoginOk=true`, `quarantine=false`, `pause.paused=false`.
16: 
17: ## Emergency controls
18: - Pause immediately: `.\bot.ps1 pause 180 suspicious_activity`
19: - Resume: `.\bot.ps1 resume`
20: - Remove quarantine after manual checks: `.\bot.ps1 unquarantine`
21: - Inspect incidents: `.\bot.ps1 incidents`
22: - Resolve incident: `.\bot.ps1 incident-resolve <id>`
23: 
24: ## Privacy retention
25: - Default retention from `.env` via `RETENTION_DAYS` (recommended: `45`).
26: - Cleanup old operational data:
27:   - `.\bot.ps1 privacy-cleanup`
28:   - `.\bot.ps1 privacy-cleanup --days 30`
29: 
30: This cleanup removes only old operational history (`run_logs`, `job_attempts`, `lead_events`, `message_history`, delivered `outbox_events`, resolved incidents).  
31: It does not delete active leads/jobs.
32: 
33: ## Host machine recommendations
34: - Keep OS and browser updated automatically.
35: - Use full-disk encryption (BitLocker on Windows).
36: - Keep a dedicated OS user profile for automation.
37: - Use a password manager and enable 2FA on LinkedIn and email.
38: - Restrict remote-access software and unknown browser extensions.
39: 
40: ## AI key hygiene (if enabled)
41: - Keep `OPENAI_API_KEY` only in local `.env` (never in repository files).
42: - Rotate key periodically and after any suspected leak.
43: - Keep `AI_PERSONALIZATION_ENABLED=false` / `AI_GUARDIAN_ENABLED=false` until dry-run validation is complete.
44: - Keep `AI_ALLOW_REMOTE_ENDPOINT=false` for local-first AI and explicit privacy control.
45: - If you need cloud AI (`api.openai.com`), set `AI_ALLOW_REMOTE_ENDPOINT=true` intentionally.
46: 
47: ## Database guardrail
48: - SQLite is blocked in `NODE_ENV=production` unless `ALLOW_SQLITE_IN_PRODUCTION=true` is set explicitly.
49: - Recommended production target: PostgreSQL with encrypted storage and managed backups.
50: 
51: ## Dependency note
52: `npm audit` currently reports high advisories related to `sqlite3` build-chain dependencies (`node-gyp` / `tar`) during install tooling.  
53: The runtime currently requires `sqlite3`; monitor upstream advisories and patch quickly when a safe upgrade path appears.
````

## File: src/ai/messagePersonalizer.ts
````typescript
  1: import { config } from '../config';
  2: import { buildFollowUpMessage } from '../messages';
  3: import { LeadRecord } from '../types/domain';
  4: import { requestOpenAIText } from './openaiClient';
  5: import { logWarn } from '../telemetry/logger';
  6: import { SemanticChecker } from './semanticChecker';
  7: 
  8: export interface PersonalizedMessageResult {
  9:     message: string;
 10:     source: 'template' | 'ai';
 11:     model: string | null;
 12: }
 13: 
 14: function trimToMaxChars(input: string, maxChars: number): string {
 15:     const normalized = input.replace(/\s+\n/g, '\n').replace(/\n{3,}/g, '\n\n').trim();
 16:     if (normalized.length <= maxChars) {
 17:         return normalized;
 18:     }
 19:     return normalized.slice(0, maxChars).trim();
 20: }
 21: 
 22: function safeFirstName(lead: LeadRecord): string {
 23:     const value = (lead.first_name ?? '').trim();
 24:     if (value) return value;
 25:     return 'there';
 26: }
 27: 
 28: export async function buildPersonalizedFollowUpMessage(lead: LeadRecord): Promise<PersonalizedMessageResult> {
 29:     const template = buildFollowUpMessage(lead);
 30:     if (!config.aiPersonalizationEnabled || !config.openaiApiKey) {
 31:         return {
 32:             message: trimToMaxChars(template, config.aiMessageMaxChars),
 33:             source: 'template',
 34:             model: null,
 35:         };
 36:     }
 37: 
 38:     const systemPrompt = [
 39:         'Sei un assistant B2B per outreach LinkedIn in italiano.',
 40:         'Genera un singolo messaggio breve, naturale, professionale.',
 41:         `Massimo ${config.aiMessageMaxChars} caratteri.`,
 42:         'Niente hype, niente emoji, niente claim aggressivi, niente link.',
 43:         'Mantieni tono rispettoso e personalizzato sul profilo.',
 44:     ].join(' ');
 45: 
 46:     const userPrompt = JSON.stringify({
 47:         firstName: safeFirstName(lead),
 48:         lastName: lead.last_name,
 49:         company: lead.account_name,
 50:         role: lead.job_title,
 51:         website: lead.website,
 52:         fallbackTemplate: template,
 53:     });
 54: 
 55:     let finalMessage = '';
 56:     let attempt = 0;
 57: 
 58:     while (attempt < 3) {
 59:         attempt++;
 60:         try {
 61:             const generated = await requestOpenAIText({
 62:                 system: systemPrompt,
 63:                 user: `Dati lead: ${userPrompt}`,
 64:                 maxOutputTokens: 220,
 65:                 temperature: 0.6 + (attempt * 0.15),
 66:             });
 67:             const candidate = trimToMaxChars(generated, config.aiMessageMaxChars);
 68: 
 69:             if (!candidate) continue;
 70: 
 71:             if (await SemanticChecker.isTooSimilar(candidate, 0.85)) {
 72:                 await logWarn('ai.personalization.too_similar_retry', { leadId: lead.id, attempt });
 73:                 continue;
 74:             }
 75: 
 76:             finalMessage = candidate;
 77:             break;
 78:         } catch (error) {
 79:             await logWarn('ai.personalization.error', {
 80:                 leadId: lead.id,
 81:                 error: error instanceof Error ? error.message : String(error),
 82:             });
 83:             break; // Se fallisce API usciamo dal loop e andiamo in fallback
 84:         }
 85:     }
 86: 
 87:     if (!finalMessage) {
 88:         await logWarn('ai.personalization.fallback_template', { leadId: lead.id, reason: 'Exhausted attempts or error' });
 89:         return {
 90:             message: trimToMaxChars(template, config.aiMessageMaxChars),
 91:             source: 'template',
 92:             model: null,
 93:         };
 94:     }
 95: 
 96:     await SemanticChecker.remember(finalMessage);
 97:     return {
 98:         message: finalMessage,
 99:         source: 'ai',
100:         model: config.aiModel,
101:     };
102: }
````

## File: src/cloud/cloudBridge.ts
````typescript
 1: /**
 2:  * cloudBridge.ts
 3:  *
 4:  * Wrapper non-bloccanti che replicano le operazioni DB locali
 5:  * verso Supabase in background. Il flusso principale NON √® mai
 6:  * interrotto da un errore cloud: i dati locali (SQLite) rimangono
 7:  * la source of truth assoluta.
 8:  *
 9:  * Utilizzo tipico:
10:  *   // Operazione locale (bloccante)
11:  *   await setLeadStatus(leadId, 'INVITED');
12:  *   // Replica cloud (non-bloccante, fire-and-forget)
13:  *   void bridgeLeadStatus(lead.linkedin_url, 'INVITED', { invited_at: new Date().toISOString() });
14:  */
15: 
16: import {
17:     upsertCloudLead,
18:     updateCloudLeadStatus,
19:     incrementCloudDailyStat,
20:     updateCloudAccountHealth,
21:     CloudLeadUpsert,
22: } from './supabaseDataClient';
23: 
24: // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
25: // Lead Bridge
26: // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
27: 
28: /**
29:  * Replica l'upsert di un lead verso il cloud.
30:  * Chiamare dopo addLead() o upsertSalesNavigatorLead() locale.
31:  */
32: export function bridgeLeadUpsert(lead: CloudLeadUpsert): void {
33:     void upsertCloudLead(lead).catch(() => {
34:         // Silenzioso: l'outbox locale gestir√† il retry se necessario
35:     });
36: }
37: 
38: /**
39:  * Replica una transizione di status di un lead verso il cloud.
40:  * Chiamare dopo setLeadStatus() locale.
41:  */
42: export function bridgeLeadStatus(
43:     linkedinUrl: string,
44:     status: string,
45:     timestamps?: {
46:         invited_at?: string | null;
47:         accepted_at?: string | null;
48:         messaged_at?: string | null;
49:         last_error?: string | null;
50:         blocked_reason?: string | null;
51:         about?: string | null;
52:         experience?: string | null;
53:         invite_prompt_variant?: string | null;
54:         invite_note_sent?: string | null;
55:     }
56: ): void {
57:     void updateCloudLeadStatus(linkedinUrl, status, timestamps).catch(() => {
58:         // Silenzioso
59:     });
60: }
61: 
62: // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
63: // Stats Bridge
64: // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
65: 
66: /**
67:  * Replica un incremento di statistica giornaliera verso il cloud.
68:  * Chiamare dopo incrementDailyStat() locale.
69:  */
70: export function bridgeDailyStat(
71:     localDate: string,
72:     accountId: string,
73:     field: 'invites_sent' | 'messages_sent' | 'acceptances' | 'replies' | 'challenges_count' | 'selector_failures' | 'run_errors',
74:     amount: number = 1
75: ): void {
76:     void incrementCloudDailyStat({ local_date: localDate, account_id: accountId, field, amount }).catch(() => {
77:         // Silenzioso
78:     });
79: }
80: 
81: // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
82: // Account Bridge
83: // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
84: 
85: /**
86:  * Aggiorna la health di un account su Supabase.
87:  * Chiamare dopo quarantineAccount() o pauseAutomation().
88:  */
89: export function bridgeAccountHealth(
90:     accountId: string,
91:     health: 'GREEN' | 'YELLOW' | 'RED',
92:     quarantineReason?: string | null,
93:     quarantineUntil?: string | null
94: ): void {
95:     void updateCloudAccountHealth(accountId, health, quarantineReason, quarantineUntil).catch(() => {
96:         // Silenzioso
97:     });
98: }
````

## File: src/core/companyEnrichment.ts
````typescript
  1: import { checkLogin, closeBrowser, detectChallenge, humanDelay, launchBrowser } from '../browser';
  2: import { config } from '../config';
  3: import { quarantineAccount } from '../risk/incidentManager';
  4: import { logInfo, logWarn } from '../telemetry/logger';
  5: import {
  6:     addLead,
  7:     CompanyTargetRecord,
  8:     getCompanyTargetsForEnrichment,
  9:     setCompanyTargetStatus,
 10: } from './repositories';
 11: import { scoreLeadProfile } from '../ai/leadScorer';
 12: 
 13: export interface CompanyEnrichmentOptions {
 14:     limit?: number;
 15:     maxProfilesPerCompany?: number;
 16:     dryRun?: boolean;
 17: }
 18: 
 19: export interface CompanyEnrichmentReport {
 20:     scanned: number;
 21:     matched: number;
 22:     createdLeads: number;
 23:     noMatch: number;
 24:     errors: number;
 25:     dryRun: boolean;
 26: }
 27: 
 28: function normalizeProfileUrl(raw: string): string | null {
 29:     try {
 30:         const parsed = new URL(raw);
 31:         if (!parsed.hostname.toLowerCase().includes('linkedin.com')) return null;
 32:         const path = parsed.pathname.replace(/\/+$/, '');
 33:         if (!path.startsWith('/in/')) return null;
 34:         return `https://www.linkedin.com${path}/`;
 35:     } catch {
 36:         return null;
 37:     }
 38: }
 39: 
 40: function toTitleCase(input: string): string {
 41:     if (!input) return '';
 42:     return input.charAt(0).toUpperCase() + input.slice(1).toLowerCase();
 43: }
 44: 
 45: function parseNamesFromProfileUrl(profileUrl: string): { firstName: string; lastName: string } {
 46:     try {
 47:         const parsed = new URL(profileUrl);
 48:         const slug = parsed.pathname.replace('/in/', '').replace(/\/+$/, '');
 49:         const clean = slug.replace(/[-_]/g, ' ').replace(/\d+/g, ' ').replace(/\s+/g, ' ').trim();
 50:         if (!clean) return { firstName: '', lastName: '' };
 51: 
 52:         const parts = clean.split(' ').filter((part) => /^[A-Za-z√Ä-√ø]{2,}$/.test(part));
 53:         if (parts.length === 0) return { firstName: '', lastName: '' };
 54:         if (parts.length === 1) return { firstName: toTitleCase(parts[0]), lastName: '' };
 55: 
 56:         return {
 57:             firstName: toTitleCase(parts[0]),
 58:             lastName: parts.slice(1).map(toTitleCase).join(' '),
 59:         };
 60:     } catch {
 61:         return { firstName: '', lastName: '' };
 62:     }
 63: }
 64: 
 65: function extractDomain(website: string): string {
 66:     const raw = (website ?? '').trim();
 67:     if (!raw) return '';
 68:     try {
 69:         const parsed = raw.startsWith('http://') || raw.startsWith('https://')
 70:             ? new URL(raw)
 71:             : new URL(`https://${raw}`);
 72:         return parsed.hostname.replace(/^www\./i, '');
 73:     } catch {
 74:         return raw.replace(/^https?:\/\//i, '').replace(/^www\./i, '').split('/')[0];
 75:     }
 76: }
 77: 
 78: function buildSearchQuery(target: CompanyTargetRecord): string {
 79:     const company = (target.account_name ?? '').trim();
 80:     const domain = extractDomain(target.website);
 81:     const terms = [company, domain].filter((v) => v.length > 0);
 82:     return terms.join(' ').trim();
 83: }
 84: 
 85: function buildSearchQueries(target: CompanyTargetRecord): string[] {
 86:     const company = (target.account_name ?? '').trim();
 87:     const domain = extractDomain(target.website);
 88:     const candidates = [
 89:         buildSearchQuery(target),
 90:         company,
 91:         domain,
 92:     ].filter((value) => value.length > 0);
 93: 
 94:     const unique = new Set<string>();
 95:     for (const value of candidates) {
 96:         unique.add(value);
 97:     }
 98:     return Array.from(unique);
 99: }
100: 
101: export interface ExtractedProfile {
102:     url: string;
103:     headline: string | null;
104: }
105: 
106: async function extractProfiles(page: Parameters<typeof detectChallenge>[0], maxProfiles: number): Promise<ExtractedProfile[]> {
107:     const rawData = await page.$$eval('li.reusable-search__result-container', (elements) => {
108:         return elements.map(el => {
109:             const anchor = el.querySelector('span.entity-result__title-text a.app-aware-link[href*="/in/"]') as HTMLAnchorElement
110:                 || el.querySelector('a[href*="/in/"]') as HTMLAnchorElement;
111:             const url = anchor ? anchor.href : null;
112:             const headlineEl = el.querySelector('.entity-result__primary-subtitle');
113:             const headline = headlineEl ? (headlineEl.textContent || '').trim() : null;
114:             return { url, headline };
115:         }).filter(r => !!r.url) as { url: string; headline: string | null }[];
116:     });
117: 
118:     if (rawData.length === 0) {
119:         const rawUrls = await page.$$eval('a[href*="/in/"]', (anchors) =>
120:             anchors.map((anchor) => (anchor as HTMLAnchorElement).href).filter((href) => !!href)
121:         );
122:         rawUrls.forEach(u => rawData.push({ url: u, headline: null }));
123:     }
124: 
125:     const unique = new Map<string, ExtractedProfile>();
126:     for (const raw of rawData) {
127:         const normalized = normalizeProfileUrl(raw.url);
128:         if (!normalized) continue;
129:         if (!unique.has(normalized)) {
130:             unique.set(normalized, { url: normalized, headline: raw.headline });
131:         }
132:         if (unique.size >= maxProfiles) break;
133:     }
134: 
135:     return Array.from(unique.values());
136: }
137: 
138: async function processCompanyTarget(
139:     target: CompanyTargetRecord,
140:     options: Required<CompanyEnrichmentOptions>,
141:     page: Parameters<typeof checkLogin>[0]
142: ): Promise<{ matched: boolean; createdLeads: number; noMatch: boolean; error: string | null }> {
143:     const queries = buildSearchQueries(target);
144:     if (queries.length === 0) {
145:         return { matched: false, createdLeads: 0, noMatch: true, error: null };
146:     }
147: 
148:     let profiles: ExtractedProfile[] = [];
149:     for (const query of queries) {
150:         const searchUrl = `https://www.linkedin.com/search/results/people/?keywords=${encodeURIComponent(query)}`;
151:         await page.goto(searchUrl, { waitUntil: 'domcontentloaded' });
152:         await humanDelay(page, 1700, 3000);
153: 
154:         if (await detectChallenge(page)) {
155:             await quarantineAccount('COMPANY_ENRICHMENT_CHALLENGE', {
156:                 targetId: target.id,
157:                 listName: target.list_name,
158:                 accountName: target.account_name,
159:             });
160:             throw new Error('Challenge rilevato durante enrichment');
161:         }
162: 
163:         profiles = await extractProfiles(page, options.maxProfilesPerCompany);
164:         if (profiles.length > 0) {
165:             break;
166:         }
167:     }
168:     if (profiles.length === 0) {
169:         return { matched: false, createdLeads: 0, noMatch: true, error: null };
170:     }
171: 
172:     let createdLeads = 0;
173:     if (!options.dryRun) {
174:         for (const profile of profiles) {
175:             const names = parseNamesFromProfileUrl(profile.url);
176: 
177:             let confidenceScore = null;
178:             let leadScore = null;
179:             let leadStatus: 'NEW' | 'REVIEW_REQUIRED' = 'NEW';
180: 
181:             if (config.openaiApiKey) {
182:                 try {
183:                     const scoreResult = await scoreLeadProfile(target.account_name, `${names.firstName} ${names.lastName}`, profile.headline);
184:                     confidenceScore = scoreResult.confidenceScore;
185:                     leadScore = scoreResult.leadScore;
186: 
187:                     if (confidenceScore < 70 || leadScore < 40) {
188:                         leadStatus = 'REVIEW_REQUIRED';
189:                         await logInfo('company_enrichment.low_score', { url: profile.url, confidenceScore, leadScore, reason: scoreResult.reason });
190:                     }
191:                 } catch (err) {
192:                     await logWarn('company_enrichment.scoring_error', { url: profile.url, error: String(err) });
193:                 }
194:             }
195: 
196:             const inserted = await addLead({
197:                 accountName: target.account_name,
198:                 firstName: names.firstName,
199:                 lastName: names.lastName,
200:                 jobTitle: profile.headline || '',
201:                 website: target.website,
202:                 linkedinUrl: profile.url,
203:                 listName: target.list_name,
204:                 leadScore,
205:                 confidenceScore,
206:                 status: leadStatus
207:             });
208:             if (inserted) {
209:                 createdLeads += 1;
210:             }
211:         }
212:     } else {
213:         createdLeads = profiles.length;
214:     }
215: 
216:     return { matched: true, createdLeads, noMatch: false, error: null };
217: }
218: 
219: export async function runCompanyEnrichmentBatch(options: CompanyEnrichmentOptions = {}): Promise<CompanyEnrichmentReport> {
220:     const resolved: Required<CompanyEnrichmentOptions> = {
221:         limit: Math.max(1, options.limit ?? config.companyEnrichmentBatch),
222:         maxProfilesPerCompany: Math.max(1, options.maxProfilesPerCompany ?? config.companyEnrichmentMaxProfilesPerCompany),
223:         dryRun: options.dryRun ?? false,
224:     };
225: 
226:     const targets = await getCompanyTargetsForEnrichment(resolved.limit);
227:     const report: CompanyEnrichmentReport = {
228:         scanned: 0,
229:         matched: 0,
230:         createdLeads: 0,
231:         noMatch: 0,
232:         errors: 0,
233:         dryRun: resolved.dryRun,
234:     };
235: 
236:     if (targets.length === 0) {
237:         return report;
238:     }
239: 
240:     const session = await launchBrowser();
241:     try {
242:         const loggedIn = await checkLogin(session.page);
243:         if (!loggedIn) {
244:             await quarantineAccount('COMPANY_ENRICHMENT_LOGIN_MISSING', {
245:                 reason: 'Sessione non autenticata durante enrichment automatico',
246:             });
247:             await logWarn('company_enrichment.skipped.login_missing', { targets: targets.length });
248:             return report;
249:         }
250: 
251:         for (const target of targets) {
252:             report.scanned += 1;
253:             try {
254:                 const result = await processCompanyTarget(target, resolved, session.page);
255:                 if (result.matched) {
256:                     report.matched += 1;
257:                     report.createdLeads += result.createdLeads;
258:                     if (!resolved.dryRun) {
259:                         await setCompanyTargetStatus(target.id, 'ENRICHED', null);
260:                     }
261:                 } else if (result.noMatch) {
262:                     report.noMatch += 1;
263:                     if (!resolved.dryRun) {
264:                         await setCompanyTargetStatus(target.id, 'NO_MATCH', null);
265:                     }
266:                 }
267:             } catch (error) {
268:                 const message = error instanceof Error ? error.message : String(error);
269:                 report.errors += 1;
270:                 if (!resolved.dryRun) {
271:                     await setCompanyTargetStatus(target.id, 'ERROR', message);
272:                 }
273:                 await logWarn('company_enrichment.target_failed', {
274:                     targetId: target.id,
275:                     listName: target.list_name,
276:                     accountName: target.account_name,
277:                     error: message,
278:                 });
279:                 if (/challenge/i.test(message)) {
280:                     break;
281:                 }
282:             }
283:         }
284:     } finally {
285:         await closeBrowser(session);
286:     }
287: 
288:     await logInfo('company_enrichment.batch', {
289:         scanned: report.scanned,
290:         matched: report.matched,
291:         createdLeads: report.createdLeads,
292:         noMatch: report.noMatch,
293:         errors: report.errors,
294:         dryRun: report.dryRun,
295:     });
296:     return report;
297: }
````

## File: src/core/doctor.ts
````typescript
  1: import { config, isWorkingHour } from '../config';
  2: import { checkLogin, closeBrowser, launchBrowser } from '../browser';
  3: import { getRuntimeAccountProfiles } from '../accountManager';
  4: import { getEventSyncStatus } from '../sync/eventSync';
  5: import { getRuntimeFlag, listOpenIncidents } from './repositories';
  6: 
  7: export interface DoctorAccountSessionReport {
  8:     accountId: string;
  9:     sessionDir: string;
 10:     sessionLoginOk: boolean;
 11: }
 12: 
 13: export interface DoctorReport {
 14:     dbPath: string;
 15:     workingHoursOk: boolean;
 16:     sessionLoginOk: boolean;
 17:     accountSessions: DoctorAccountSessionReport[];
 18:     quarantine: boolean;
 19:     sync: {
 20:         activeSink: 'SUPABASE' | 'WEBHOOK' | 'NONE';
 21:         enabled: boolean;
 22:         configured: boolean;
 23:         pendingOutbox: number;
 24:         warning: string | null;
 25:     };
 26:     compliance: {
 27:         enforced: boolean;
 28:         ok: boolean;
 29:         violations: string[];
 30:         limits: {
 31:             softInviteCap: number;
 32:             hardInviteCap: number;
 33:             weeklyInviteLimit: number;
 34:             softMsgCap: number;
 35:             hardMsgCap: number;
 36:         };
 37:     };
 38:     openIncidents: number;
 39: }
 40: 
 41: function evaluateCompliance(): DoctorReport['compliance'] {
 42:     const violations: string[] = [];
 43: 
 44:     if (config.softInviteCap > config.hardInviteCap) {
 45:         violations.push(`SOFT_INVITE_CAP (${config.softInviteCap}) > HARD_INVITE_CAP (${config.hardInviteCap})`);
 46:     }
 47:     if (config.softMsgCap > config.hardMsgCap) {
 48:         violations.push(`SOFT_MSG_CAP (${config.softMsgCap}) > HARD_MSG_CAP (${config.hardMsgCap})`);
 49:     }
 50:     if (config.hardInviteCap > config.complianceMaxHardInviteCap) {
 51:         violations.push(`HARD_INVITE_CAP (${config.hardInviteCap}) supera il massimo compliance (${config.complianceMaxHardInviteCap})`);
 52:     }
 53:     if (config.weeklyInviteLimit > config.complianceMaxWeeklyInviteLimit) {
 54:         violations.push(`WEEKLY_INVITE_LIMIT (${config.weeklyInviteLimit}) supera il massimo compliance (${config.complianceMaxWeeklyInviteLimit})`);
 55:     }
 56:     if (config.hardMsgCap > config.complianceMaxHardMsgCap) {
 57:         violations.push(`HARD_MSG_CAP (${config.hardMsgCap}) supera il massimo compliance (${config.complianceMaxHardMsgCap})`);
 58:     }
 59: 
 60:     const enforced = config.complianceEnforced;
 61:     return {
 62:         enforced,
 63:         ok: !enforced || violations.length === 0,
 64:         violations,
 65:         limits: {
 66:             softInviteCap: config.softInviteCap,
 67:             hardInviteCap: config.hardInviteCap,
 68:             weeklyInviteLimit: config.weeklyInviteLimit,
 69:             softMsgCap: config.softMsgCap,
 70:             hardMsgCap: config.hardMsgCap,
 71:         },
 72:     };
 73: }
 74: 
 75: export async function runDoctor(): Promise<DoctorReport> {
 76:     const quarantine = (await getRuntimeFlag('account_quarantine')) === 'true';
 77:     const sync = await getEventSyncStatus();
 78:     const incidents = await listOpenIncidents();
 79:     const compliance = evaluateCompliance();
 80: 
 81:     const accountSessions: DoctorAccountSessionReport[] = [];
 82:     const accounts = getRuntimeAccountProfiles();
 83:     for (const account of accounts) {
 84:         const session = await launchBrowser({
 85:             sessionDir: account.sessionDir,
 86:             proxy: account.proxy,
 87:         });
 88:         try {
 89:             const sessionLoginOk = await checkLogin(session.page);
 90:             accountSessions.push({
 91:                 accountId: account.id,
 92:                 sessionDir: account.sessionDir,
 93:                 sessionLoginOk,
 94:             });
 95:         } finally {
 96:             await closeBrowser(session);
 97:         }
 98:     }
 99:     const sessionLoginOk = accountSessions.every((entry) => entry.sessionLoginOk);
100: 
101:     return {
102:         dbPath: config.dbPath,
103:         workingHoursOk: isWorkingHour(),
104:         sessionLoginOk,
105:         accountSessions,
106:         quarantine,
107:         sync: {
108:             activeSink: sync.activeSink,
109:             enabled: sync.enabled,
110:             configured: sync.configured,
111:             pendingOutbox: sync.pendingOutbox,
112:             warning: sync.warning,
113:         },
114:         compliance,
115:         openIncidents: incidents.length,
116:     };
117: }
````

## File: src/core/leadStateService.ts
````typescript
  1: import { appendLeadEvent, getLeadById, pushOutboxEvent, setLeadStatus } from './repositories';
  2: import { LeadStatus } from '../types/domain';
  3: 
  4: const allowedTransitions: Record<Exclude<LeadStatus, 'PENDING'>, LeadStatus[]> = {
  5:     NEW: ['READY_INVITE', 'BLOCKED', 'REVIEW_REQUIRED', 'DEAD'],
  6:     READY_INVITE: ['INVITED', 'SKIPPED', 'BLOCKED', 'REVIEW_REQUIRED', 'DEAD'],
  7:     INVITED: ['ACCEPTED', 'CONNECTED', 'BLOCKED', 'REVIEW_REQUIRED', 'WITHDRAWN', 'DEAD'],
  8:     ACCEPTED: ['READY_MESSAGE', 'CONNECTED', 'BLOCKED', 'REVIEW_REQUIRED', 'DEAD'],
  9:     CONNECTED: ['READY_MESSAGE', 'BLOCKED', 'REVIEW_REQUIRED', 'DEAD'],
 10:     READY_MESSAGE: ['MESSAGED', 'BLOCKED', 'REVIEW_REQUIRED', 'DEAD'],
 11:     MESSAGED: ['REPLIED', 'REVIEW_REQUIRED'],
 12:     REPLIED: [],
 13:     SKIPPED: [],
 14:     BLOCKED: [],
 15:     DEAD: [],
 16:     REVIEW_REQUIRED: ['READY_INVITE', 'READY_MESSAGE', 'INVITED', 'BLOCKED', 'DEAD', 'WITHDRAWN'],
 17:     WITHDRAWN: ['READY_INVITE', 'DEAD'],
 18: };
 19: 
 20: function normalize(status: LeadStatus): Exclude<LeadStatus, 'PENDING'> {
 21:     if (status === 'PENDING') {
 22:         return 'READY_INVITE';
 23:     }
 24:     return status;
 25: }
 26: 
 27: export function isValidLeadTransition(fromStatus: LeadStatus, toStatus: LeadStatus): boolean {
 28:     const normalizedFrom = normalize(fromStatus);
 29:     const normalizedTo = normalize(toStatus);
 30:     const nextAllowed = allowedTransitions[normalizedFrom];
 31:     return nextAllowed.includes(normalizedTo);
 32: }
 33: 
 34: export async function transitionLead(
 35:     leadId: number,
 36:     toStatus: LeadStatus,
 37:     reason: string,
 38:     metadata: Record<string, unknown> = {}
 39: ): Promise<void> {
 40:     const lead = await getLeadById(leadId);
 41:     if (!lead) {
 42:         throw new Error(`Lead ${leadId} non trovato.`);
 43:     }
 44: 
 45:     const fromStatus = normalize(lead.status);
 46:     const targetStatus = normalize(toStatus);
 47:     if (!isValidLeadTransition(fromStatus, targetStatus)) {
 48:         throw new Error(`Transizione non consentita: ${fromStatus} -> ${targetStatus}.`);
 49:     }
 50: 
 51:     const blockedReason = targetStatus === 'BLOCKED' ? reason : undefined;
 52:     await setLeadStatus(leadId, targetStatus, undefined, blockedReason);
 53:     await appendLeadEvent(leadId, fromStatus, targetStatus, reason, metadata);
 54:     await pushOutboxEvent(
 55:         'lead.transition',
 56:         {
 57:             leadId,
 58:             fromStatus,
 59:             toStatus: targetStatus,
 60:             reason,
 61:             metadata,
 62:         },
 63:         `lead.transition:${leadId}:${fromStatus}:${targetStatus}:${reason}`
 64:     );
 65: }
 66: 
 67: export async function reconcileLeadStatus(
 68:     leadId: number,
 69:     toStatus: LeadStatus,
 70:     reason: string,
 71:     metadata: Record<string, unknown> = {}
 72: ): Promise<void> {
 73:     const lead = await getLeadById(leadId);
 74:     if (!lead) {
 75:         throw new Error(`Lead ${leadId} non trovato.`);
 76:     }
 77: 
 78:     const fromStatus = normalize(lead.status);
 79:     const targetStatus = normalize(toStatus);
 80:     if (fromStatus === targetStatus) {
 81:         return;
 82:     }
 83: 
 84:     await setLeadStatus(leadId, targetStatus);
 85:     await appendLeadEvent(leadId, fromStatus, targetStatus, reason, {
 86:         ...metadata,
 87:         reconcile: true,
 88:     });
 89:     await pushOutboxEvent(
 90:         'lead.reconciled',
 91:         {
 92:             leadId,
 93:             fromStatus,
 94:             toStatus: targetStatus,
 95:             reason,
 96:             metadata,
 97:         },
 98:         `lead.reconciled:${leadId}:${fromStatus}:${targetStatus}:${reason}`
 99:     );
100: }
````

## File: src/noteGenerator.ts
````typescript
 1: /**
 2:  * Generatore di note per gli inviti LinkedIn.
 3:  * Usa template predefiniti variati per evitare pattern ripetitivi.
 4:  * Tutte le note restano sotto i 300 caratteri (limite LinkedIn).
 5:  */
 6: 
 7: export interface TemplateNoteResult {
 8:     note: string;
 9:     variant: string;
10: }
11: 
12: const NOTE_TEMPLATES: ReadonlyArray<{ variant: string; render: (firstName: string) => string }> = [
13:     { variant: 'TPL_CASUAL_INTEREST', render: (n) => `Ciao ${n}, ho trovato il tuo profilo interessante e mi piacerebbe aggiungerti alla mia rete. A presto!` },
14:     { variant: 'TPL_PROFESSIONAL_FOLLOW', render: (n) => `Ciao ${n}, seguo il tuo lavoro con interesse. Sarebbe un piacere connetterci!` },
15:     { variant: 'TPL_COMMON_INTERESTS', render: (n) => `Salve ${n}, ho visto il tuo profilo e penso potremmo avere interessi in comune. Ti aggiungo volentieri!` },
16:     { variant: 'TPL_NETWORK_EXPANSION', render: (n) => `Ciao ${n}, mi piacerebbe connettermi con te per ampliare la mia rete professionale. Buona giornata!` },
17:     { variant: 'TPL_BACKGROUND_APPRECIATION', render: (n) => `Ciao ${n}, ho apprezzato il tuo background professionale. Sarebbe bello entrare in contatto!` },
18:     { variant: 'TPL_ATTENTION_GRABBER', render: (n) => `Salve ${n}, il tuo profilo ha attirato la mia attenzione. Ti propongo di connetterci!` },
19:     { variant: 'TPL_MUTUAL_BENEFIT', render: (n) => `Ciao ${n}, credo che possiamo trarre reciproco beneficio da questa connessione. A presto!` },
20:     { variant: 'TPL_LIKE_MINDED', render: (n) => `Ciao ${n}, mi farebbe piacere allargare la mia rete con professionisti come te. Collegati con me!` },
21: ];
22: 
23: /**
24:  * Ritorna una nota di invito personalizzata con il nome del lead e il suo ID variante per A/B Testing.
25:  * La selezione del template √® pseudo-casuale.
26:  */
27: export function generateInviteNote(firstName: string): TemplateNoteResult {
28:     const name = firstName.trim() || 'collega';
29:     const index = Math.floor(Math.random() * NOTE_TEMPLATES.length);
30:     const selected = NOTE_TEMPLATES[index];
31:     return {
32:         note: selected.render(name),
33:         variant: selected.variant,
34:     };
35: }
````

## File: src/security/redaction.ts
````typescript
 1: const MAX_RECURSION_DEPTH = 6;
 2: const REDACTED = '[REDACTED]';
 3: 
 4: const SENSITIVE_KEY_PATTERN = /(token|secret|password|pass|key|cookie|authorization|session|bearer)/i;
 5: 
 6: const JWT_PATTERN = /\b[A-Za-z0-9_-]{20,}\.[A-Za-z0-9_-]{20,}\.[A-Za-z0-9_-]{20,}\b/g;
 7: const SUPABASE_KEY_PATTERN = /\bsb_(publishable|secret)_[A-Za-z0-9_-]{20,}\b/gi;
 8: const API_KEY_PATTERN = /\b(sk|pk|rk)_[A-Za-z0-9_-]{16,}\b/gi;
 9: const TELEGRAM_BOT_TOKEN_PATTERN = /\b\d{8,}:[A-Za-z0-9_-]{20,}\b/g;
10: 
11: const EMAIL_PATTERN = /\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/gi;
12: const LINKEDIN_URL_PATTERN = /https?:\/\/(www\.)?linkedin\.com\/(in|profile)\/[A-Za-z0-9_-]+/gi;
13: const PHONE_PATTERN = /\+?\d{1,4}[-.\s]?\(?\d{1,3}\)?[-.\s]?\d{1,4}[-.\s]?\d{1,4}[-.\s]?\d{1,9}/g;
14: const PII_REDACTED = '[PII_REDACTED]';
15: 
16: function sanitizeString(input: string): string {
17:     return input
18:         .replace(JWT_PATTERN, REDACTED)
19:         .replace(SUPABASE_KEY_PATTERN, REDACTED)
20:         .replace(API_KEY_PATTERN, REDACTED)
21:         .replace(TELEGRAM_BOT_TOKEN_PATTERN, REDACTED)
22:         .replace(EMAIL_PATTERN, PII_REDACTED)
23:         .replace(LINKEDIN_URL_PATTERN, PII_REDACTED)
24:         .replace(PHONE_PATTERN, PII_REDACTED);
25: }
26: 
27: function sanitizeArray(input: unknown[], depth: number): unknown[] {
28:     if (depth > MAX_RECURSION_DEPTH) {
29:         return ['[MAX_DEPTH_REACHED]'];
30:     }
31:     return input.map((item) => sanitizeForLogs(item, depth + 1));
32: }
33: 
34: function sanitizeObject(input: Record<string, unknown>, depth: number): Record<string, unknown> {
35:     if (depth > MAX_RECURSION_DEPTH) {
36:         return { note: '[MAX_DEPTH_REACHED]' };
37:     }
38: 
39:     const output: Record<string, unknown> = {};
40:     for (const [key, value] of Object.entries(input)) {
41:         if (SENSITIVE_KEY_PATTERN.test(key)) {
42:             output[key] = REDACTED;
43:             continue;
44:         }
45:         output[key] = sanitizeForLogs(value, depth + 1);
46:     }
47:     return output;
48: }
49: 
50: export function sanitizeForLogs<T>(value: T, depth: number = 0): T {
51:     if (value === null || value === undefined) {
52:         return value;
53:     }
54: 
55:     if (typeof value === 'string') {
56:         return sanitizeString(value) as T;
57:     }
58: 
59:     if (typeof value === 'number' || typeof value === 'boolean') {
60:         return value;
61:     }
62: 
63:     if (Array.isArray(value)) {
64:         return sanitizeArray(value, depth) as T;
65:     }
66: 
67:     if (typeof value === 'object') {
68:         return sanitizeObject(value as Record<string, unknown>, depth) as T;
69:     }
70: 
71:     return String(value) as T;
72: }
````

## File: src/sync/supabase.full.schema.sql
````sql
  1: -- ============================================================
  2: -- LinkedIn Bot Enterprise - Supabase PostgreSQL Schema
  3: -- ============================================================
  4: -- Istruzioni: esegui questo script nell'SQL Editor di Supabase
  5: -- (progetto > SQL Editor > New Query > Esegui)
  6: -- ============================================================
  7: 
  8: -- ============================================================
  9: -- TABELLE DI TELEMETRIA (gi√† esistenti ‚Äì non alterare se presenti)
 10: -- ============================================================
 11: 
 12: create table if not exists public.cp_events (
 13:     id bigserial primary key,
 14:     topic text not null,
 15:     payload jsonb not null default '{}',
 16:     idempotency_key text not null unique,
 17:     created_at timestamptz not null default now()
 18: );
 19: create index if not exists idx_cp_events_created_at on public.cp_events(created_at desc);
 20: 
 21: create table if not exists public.cp_daily_kpis (
 22:     id bigserial primary key,
 23:     local_date date not null,
 24:     metric_name text not null,
 25:     metric_value numeric not null,
 26:     created_at timestamptz not null default now(),
 27:     unique (local_date, metric_name)
 28: );
 29: 
 30: create table if not exists public.cp_incidents (
 31:     id bigserial primary key,
 32:     incident_type text not null,
 33:     severity text not null,
 34:     details jsonb not null default '{}',
 35:     opened_at timestamptz not null default now()
 36: );
 37: 
 38: create table if not exists public.cp_worker_runs (
 39:     id bigserial primary key,
 40:     worker_name text not null,
 41:     status text not null,
 42:     details jsonb not null default '{}',
 43:     created_at timestamptz not null default now()
 44: );
 45: 
 46: -- ============================================================
 47: -- TABELLE OPERATIVE (nuove ‚Äì core del sistema Enterprise)
 48: -- ============================================================
 49: 
 50: -- 1. ACCOUNTS ‚Äì ogni profilo LinkedIn gestito dal bot
 51: --    tier: WARM_UP | ACTIVE | QUARANTINE | BANNED
 52: --    health: GREEN | YELLOW | RED
 53: create table if not exists public.accounts (
 54:     id text primary key,                                  -- corrisponde a config account_id (es. 'acc1')
 55:     email text,
 56:     display_name text,
 57:     session_dir text,
 58:     proxy_url text,
 59:     tier text not null default 'WARM_UP',                 -- WARM_UP | ACTIVE | QUARANTINE | BANNED
 60:     health text not null default 'GREEN',                 -- GREEN | YELLOW | RED
 61:     daily_invite_cap integer not null default 15,
 62:     daily_message_cap integer not null default 20,
 63:     daily_invites_sent integer not null default 0,
 64:     daily_messages_sent integer not null default 0,
 65:     farming_started_at timestamptz,
 66:     farming_ends_at timestamptz,
 67:     last_active_at timestamptz,
 68:     quarantine_reason text,
 69:     quarantine_until timestamptz,
 70:     metadata jsonb not null default '{}',
 71:     created_at timestamptz not null default now(),
 72:     updated_at timestamptz not null default now()
 73: );
 74: 
 75: -- 2. CAMPAIGNS ‚Äì una campagna raggruppa lead simili con set di istruzioni AI
 76: create table if not exists public.campaigns (
 77:     id bigserial primary key,
 78:     name text not null unique,
 79:     account_id text references public.accounts(id) on delete set null,
 80:     is_active boolean not null default true,
 81:     priority integer not null default 100,
 82:     daily_invite_cap integer,
 83:     daily_message_cap integer,
 84:     -- System prompt e user prompt per la generazione della nota AI
 85:     prompt_system text not null default '',
 86:     prompt_user text not null default '',
 87:     -- Stile: FORMAL | CASUAL | IRONIC
 88:     prompt_style text not null default 'CASUAL',
 89:     -- Statistiche aggregate (aggiornate da trigger o cron)
 90:     total_leads integer not null default 0,
 91:     leads_invited integer not null default 0,
 92:     leads_connected integer not null default 0,
 93:     leads_messaged integer not null default 0,
 94:     leads_replied integer not null default 0,
 95:     acceptance_rate numeric(5,2),
 96:     reply_rate numeric(5,2),
 97:     created_at timestamptz not null default now(),
 98:     updated_at timestamptz not null default now()
 99: );
100: 
101: -- 3. LEADS ‚Äì il CRM centrale. Replica dei lead locali + dati cloud-only.
102: --    status: NEW | READY_INVITE | INVITED | CONNECTED | READY_MESSAGE | MESSAGED | REPLIED | DEAD | BLOCKED
103: create table if not exists public.leads (
104:     id bigserial primary key,
105:     local_id integer,                                     -- id dal DB SQLite locale (per reconciliazione)
106:     campaign_id bigint references public.campaigns(id) on delete set null,
107:     account_id text references public.accounts(id) on delete set null,
108:     linkedin_url text not null unique,
109:     first_name text not null default '',
110:     last_name text not null default '',
111:     job_title text not null default '',
112:     account_name text not null default '',
113:     website text not null default '',
114:     list_name text not null default 'default',
115:     status text not null default 'NEW',
116:     -- Timestamps chiave del lifecycle
117:     invited_at timestamptz,
118:     accepted_at timestamptz,
119:     messaged_at timestamptz,
120:     replied_at timestamptz,
121:     last_site_check_at timestamptz,
122:     last_error text,
123:     blocked_reason text,
124:     about text,
125:     experience text,
126:     invite_prompt_variant text,
127:     invite_note_sent text,
128:     -- NLP intent dell'ultima risposta in inbox
129:     last_reply_intent text,                               -- POSITIVE | NEGATIVE | POSTPONED | NEUTRAL
130:     last_reply_snippet text,
131:     metadata jsonb not null default '{}',
132:     created_at timestamptz not null default now(),
133:     updated_at timestamptz not null default now()
134: );
135: create index if not exists idx_leads_status on public.leads(status);
136: create index if not exists idx_leads_campaign_id on public.leads(campaign_id);
137: create index if not exists idx_leads_account_id on public.leads(account_id);
138: create index if not exists idx_leads_list_name on public.leads(list_name);
139: create index if not exists idx_leads_invited_at on public.leads(invited_at desc) where invited_at is not null;
140: create index if not exists idx_leads_accepted_at on public.leads(accepted_at desc) where accepted_at is not null;
141: 
142: -- 4. PROMPT_AB_TEST_VARIANTS ‚Äì le varianti di prompt da testare
143: create table if not exists public.prompt_variants (
144:     id bigserial primary key,
145:     campaign_id bigint references public.campaigns(id) on delete cascade,
146:     variant_name text not null,
147:     prompt_system text not null,
148:     prompt_user text not null,
149:     -- Statistiche accumulate
150:     invites_sent integer not null default 0,
151:     acceptances integer not null default 0,
152:     acceptance_rate numeric(5,2),
153:     is_active boolean not null default true,
154:     created_at timestamptz not null default now(),
155:     updated_at timestamptz not null default now(),
156:     unique (campaign_id, variant_name)
157: );
158: 
159: -- 5. JOBS_CLOUD ‚Äì coda job distribuita cloud-side (mirror della SQLite locale)
160: --    type: SCRAPE | INVITE | CHECK_ACCEPTS | MESSAGE | FARM_ACTIVITY
161: --    status: QUEUED | RUNNING | SUCCESS | FAILED | DEAD_LETTER | BLOCKED
162: create table if not exists public.jobs_cloud (
163:     id bigserial primary key,
164:     local_job_id integer,                                 -- id dal DB SQLite locale
165:     account_id text references public.accounts(id) on delete cascade,
166:     lead_id bigint references public.leads(id) on delete set null,
167:     type text not null,
168:     status text not null default 'QUEUED',
169:     priority integer not null default 100,
170:     payload jsonb not null default '{}',
171:     idempotency_key text unique,
172:     attempts integer not null default 0,
173:     max_attempts integer not null default 3,
174:     next_run_at timestamptz not null default now(),
175:     locked_at timestamptz,
176:     completed_at timestamptz,
177:     error_message text,
178:     proof_screenshot_url text,
179:     created_at timestamptz not null default now(),
180:     updated_at timestamptz not null default now()
181: );
182: create index if not exists idx_jobs_cloud_status_next on public.jobs_cloud(status, next_run_at asc);
183: create index if not exists idx_jobs_cloud_account_status on public.jobs_cloud(account_id, status);
184: create index if not exists idx_jobs_cloud_type on public.jobs_cloud(type);
185: 
186: -- 6. DAILY_STATS_CLOUD ‚Äì statistiche giornaliere aggregate per account
187: create table if not exists public.daily_stats_cloud (
188:     id bigserial primary key,
189:     local_date date not null,
190:     account_id text references public.accounts(id) on delete cascade,
191:     invites_sent integer not null default 0,
192:     messages_sent integer not null default 0,
193:     acceptances integer not null default 0,
194:     replies integer not null default 0,
195:     challenges_count integer not null default 0,
196:     selector_failures integer not null default 0,
197:     run_errors integer not null default 0,
198:     created_at timestamptz not null default now(),
199:     updated_at timestamptz not null default now(),
200:     unique (local_date, account_id)
201: );
202: create index if not exists idx_daily_stats_cloud_date on public.daily_stats_cloud(local_date desc);
203: 
204: -- 7. PROXY_HEALTH ‚Äì storico della salute dei proxy (Punto 11 del Master Plan)
205: create table if not exists public.proxy_ips (
206:     id bigserial primary key,
207:     proxy_url text not null unique,
208:     provider text,                                        -- es. 'brightdata', 'iproyal', 'custom'
209:     ip_address text,
210:     country_code text,
211:     asn text,
212:     is_residential boolean not null default false,
213:     status text not null default 'ACTIVE',                -- ACTIVE | DEAD | COOLING_DOWN
214:     failure_count integer not null default 0,
215:     last_tested_at timestamptz,
216:     blacklisted_until timestamptz,
217:     created_at timestamptz not null default now(),
218:     updated_at timestamptz not null default now()
219: );
220: 
221: -- 8. TELEGRAM_COMMANDS ‚Äì comandi ricevuti via bot Telegram (Punto 4 Master Plan)
222: create table if not exists public.telegram_commands (
223:     id bigserial primary key,
224:     account_id text references public.accounts(id) on delete set null,
225:     command text not null,                                -- es. 'solve', 'pin', 'restart', 'pause'
226:     args text,                                            -- es. '742911' (il pin) o '3' (riquadro captcha)
227:     status text not null default 'PENDING',               -- PENDING | PROCESSED | EXPIRED
228:     processed_at timestamptz,
229:     created_at timestamptz not null default now()
230: );
231: create index if not exists idx_telegram_commands_pending on public.telegram_commands(status, created_at asc) where status = 'PENDING';
232: 
233: -- ============================================================
234: -- FUNZIONI HELPER
235: -- ============================================================
236: 
237: -- Auto-aggiorna updated_at su ogni UPDATE
238: create or replace function public.set_updated_at()
239: returns trigger language plpgsql as $$
240: begin
241:     new.updated_at = now();
242:     return new;
243: end;
244: $$;
245: 
246: -- Applica il trigger a tutte le tabelle con updated_at
247: do $$
248: declare
249:     tbl text;
250: begin
251:     foreach tbl in array array['accounts','campaigns','leads','prompt_variants','jobs_cloud','daily_stats_cloud','proxy_ips','telegram_commands']
252:     loop
253:         execute format(
254:             'drop trigger if exists trg_%I_updated_at on public.%I;
255:              create trigger trg_%I_updated_at
256:              before update on public.%I
257:              for each row execute function public.set_updated_at();',
258:             tbl, tbl, tbl, tbl
259:         );
260:     end loop;
261: end;
262: $$;
263: 
264: -- ============================================================
265: -- ROW LEVEL SECURITY (RLS) ‚Äì sicurezza base
266: -- ============================================================
267: -- Il service role key bypassa RLS, la anon key no.
268: -- Per ora disabilitiamo RLS sulle tabelle operative (accesso
269: -- solo via service role key dal bot, non da browser).
270: alter table public.accounts disable row level security;
271: alter table public.campaigns disable row level security;
272: alter table public.leads disable row level security;
273: alter table public.prompt_variants disable row level security;
274: alter table public.jobs_cloud disable row level security;
275: alter table public.daily_stats_cloud disable row level security;
276: alter table public.proxy_ips disable row level security;
277: alter table public.telegram_commands disable row level security;
````

## File: src/sync/supabaseSyncWorker.ts
````typescript
  1: import { createClient, SupabaseClient } from '@supabase/supabase-js';
  2: import { config } from '../config';
  3: import { sendTelegramAlert } from '../telemetry/alerts';
  4: import { logInfo, logWarn } from '../telemetry/logger';
  5: import {
  6:     countPendingOutboxEvents,
  7:     getPendingOutboxEvents,
  8:     markOutboxDelivered,
  9:     markOutboxPermanentFailure,
 10:     markOutboxRetry,
 11: } from '../core/repositories';
 12: 
 13: let client: SupabaseClient | null = null;
 14: 
 15: function getClient(): SupabaseClient | null {
 16:     if (!config.supabaseSyncEnabled) return null;
 17:     if (!config.supabaseUrl || !config.supabaseServiceRoleKey) return null;
 18:     if (!client) {
 19:         client = createClient(config.supabaseUrl, config.supabaseServiceRoleKey, {
 20:             auth: {
 21:                 persistSession: false,
 22:                 autoRefreshToken: false,
 23:             },
 24:         });
 25:     }
 26:     return client;
 27: }
 28: 
 29: function retryDelayMs(attempt: number): number {
 30:     const base = config.supabaseSyncIntervalMs;
 31:     const jitter = Math.floor(Math.random() * 500);
 32:     return base * Math.pow(2, Math.max(0, attempt - 1)) + jitter;
 33: }
 34: 
 35: function parseOutboxPayload(raw: string): Record<string, unknown> {
 36:     try {
 37:         const parsed = JSON.parse(raw) as unknown;
 38:         if (parsed && typeof parsed === 'object') {
 39:             return parsed as Record<string, unknown>;
 40:         }
 41:     } catch {
 42:         // fallback sotto
 43:     }
 44:     return { raw };
 45: }
 46: 
 47: export interface SyncStatus {
 48:     enabled: boolean;
 49:     configured: boolean;
 50:     pendingOutbox: number;
 51: }
 52: 
 53: export async function getSyncStatus(): Promise<SyncStatus> {
 54:     const pendingOutbox = await countPendingOutboxEvents();
 55:     return {
 56:         enabled: config.supabaseSyncEnabled,
 57:         configured: !!(config.supabaseUrl && config.supabaseServiceRoleKey),
 58:         pendingOutbox,
 59:     };
 60: }
 61: 
 62: export async function runSupabaseSyncOnce(): Promise<void> {
 63:     const supabase = getClient();
 64:     if (!supabase) {
 65:         return;
 66:     }
 67: 
 68:     const events = await getPendingOutboxEvents(config.supabaseSyncBatchSize);
 69:     if (events.length === 0) {
 70:         return;
 71:     }
 72: 
 73:     let sent = 0;
 74:     let failed = 0;
 75:     let permanentFailures = 0;
 76:     for (const event of events) {
 77:         const payload = {
 78:             topic: event.topic,
 79:             payload: parseOutboxPayload(event.payload_json),
 80:             idempotency_key: event.idempotency_key,
 81:             created_at: event.created_at,
 82:         };
 83: 
 84:         const { error } = await supabase.from('cp_events').upsert(payload, {
 85:             onConflict: 'idempotency_key',
 86:             ignoreDuplicates: false,
 87:         });
 88: 
 89:         if (error) {
 90:             failed += 1;
 91:             const attempts = event.attempts + 1;
 92:             if (attempts >= config.supabaseSyncMaxRetries) {
 93:                 permanentFailures += 1;
 94:                 await markOutboxPermanentFailure(event.id, attempts, error.message);
 95:                 await logWarn('supabase.sync.event.permanent_failure', {
 96:                     eventId: event.id,
 97:                     idempotencyKey: event.idempotency_key,
 98:                     attempts,
 99:                     maxRetries: config.supabaseSyncMaxRetries,
100:                     error: error.message,
101:                 });
102:             } else {
103:                 const delay = retryDelayMs(attempts);
104:                 await markOutboxRetry(event.id, attempts, delay, error.message);
105:             }
106:         } else {
107:             sent += 1;
108:             await markOutboxDelivered(event.id);
109:         }
110:     }
111: 
112:     await logInfo('supabase.sync.batch', {
113:         sent,
114:         failed,
115:         permanentFailures,
116:         batchSize: events.length,
117:         maxRetries: config.supabaseSyncMaxRetries,
118:     });
119: 
120:     const pending = await countPendingOutboxEvents();
121:     if (pending > config.outboxAlertBacklog) {
122:         await logWarn('supabase.sync.backlog_high', { pending, threshold: config.outboxAlertBacklog });
123:         await sendTelegramAlert(`${pending} eventi pendenti non sincronizzati col cloud Supabase.`, 'Outbox Backlog Alto', 'warn');
124:     }
125: }
````

## File: src/sync/webhookSyncWorker.ts
````typescript
  1: import { createHmac } from 'crypto';
  2: import { config } from '../config';
  3: import { sendTelegramAlert } from '../telemetry/alerts';
  4: import { logInfo, logWarn } from '../telemetry/logger';
  5: import {
  6:     countPendingOutboxEvents,
  7:     getPendingOutboxEvents,
  8:     markOutboxDelivered,
  9:     markOutboxPermanentFailure,
 10:     markOutboxRetry,
 11: } from '../core/repositories';
 12: 
 13: function retryDelayMs(attempt: number): number {
 14:     const base = config.supabaseSyncIntervalMs;
 15:     const jitter = Math.floor(Math.random() * 500);
 16:     return base * Math.pow(2, Math.max(0, attempt - 1)) + jitter;
 17: }
 18: 
 19: function parseOutboxPayload(raw: string): Record<string, unknown> {
 20:     try {
 21:         const parsed = JSON.parse(raw) as unknown;
 22:         if (parsed && typeof parsed === 'object') {
 23:             return parsed as Record<string, unknown>;
 24:         }
 25:     } catch {
 26:         // fallback sotto
 27:     }
 28:     return { raw };
 29: }
 30: 
 31: function buildWebhookSignature(payload: string): string | null {
 32:     const secret = config.webhookSyncSecret;
 33:     if (!secret) {
 34:         return null;
 35:     }
 36:     const signature = createHmac('sha256', secret).update(payload, 'utf8').digest('hex');
 37:     return `sha256=${signature}`;
 38: }
 39: 
 40: function endpointHost(rawUrl: string): string | null {
 41:     try {
 42:         return new URL(rawUrl).host;
 43:     } catch {
 44:         return null;
 45:     }
 46: }
 47: 
 48: export interface WebhookSyncStatus {
 49:     enabled: boolean;
 50:     configured: boolean;
 51:     pendingOutbox: number;
 52:     endpointHost: string | null;
 53: }
 54: 
 55: export async function getWebhookSyncStatus(): Promise<WebhookSyncStatus> {
 56:     const pendingOutbox = await countPendingOutboxEvents();
 57:     const configured = !!config.webhookSyncUrl;
 58:     return {
 59:         enabled: config.webhookSyncEnabled,
 60:         configured,
 61:         pendingOutbox,
 62:         endpointHost: configured ? endpointHost(config.webhookSyncUrl) : null,
 63:     };
 64: }
 65: 
 66: export async function runWebhookSyncOnce(): Promise<void> {
 67:     if (!config.webhookSyncEnabled || !config.webhookSyncUrl) {
 68:         return;
 69:     }
 70: 
 71:     const events = await getPendingOutboxEvents(config.webhookSyncBatchSize);
 72:     if (events.length === 0) {
 73:         return;
 74:     }
 75: 
 76:     let sent = 0;
 77:     let failed = 0;
 78:     let permanentFailures = 0;
 79: 
 80:     for (const event of events) {
 81:         const payload = {
 82:             topic: event.topic,
 83:             payload: parseOutboxPayload(event.payload_json),
 84:             idempotencyKey: event.idempotency_key,
 85:             createdAt: event.created_at,
 86:         };
 87: 
 88:         const body = JSON.stringify(payload);
 89:         const signature = buildWebhookSignature(body);
 90:         const headers: Record<string, string> = {
 91:             'content-type': 'application/json',
 92:             'x-idempotency-key': event.idempotency_key,
 93:             'x-event-topic': event.topic,
 94:         };
 95:         if (signature) {
 96:             headers['x-signature-sha256'] = signature;
 97:         }
 98: 
 99:         try {
100:             const response = await fetch(config.webhookSyncUrl, {
101:                 method: 'POST',
102:                 headers,
103:                 body,
104:                 signal: AbortSignal.timeout(config.webhookSyncTimeoutMs),
105:             });
106: 
107:             if (!response.ok) {
108:                 failed += 1;
109:                 const responseText = (await response.text().catch(() => '')).slice(0, 500);
110:                 const errorMessage = `HTTP_${response.status}:${response.statusText}${responseText ? `:${responseText}` : ''}`;
111:                 const attempts = event.attempts + 1;
112:                 if (attempts >= config.webhookSyncMaxRetries) {
113:                     permanentFailures += 1;
114:                     await markOutboxPermanentFailure(event.id, attempts, errorMessage);
115:                     await logWarn('webhook.sync.event.permanent_failure', {
116:                         eventId: event.id,
117:                         idempotencyKey: event.idempotency_key,
118:                         attempts,
119:                         maxRetries: config.webhookSyncMaxRetries,
120:                         error: errorMessage,
121:                     });
122:                 } else {
123:                     const delay = retryDelayMs(attempts);
124:                     await markOutboxRetry(event.id, attempts, delay, errorMessage);
125:                 }
126:                 continue;
127:             }
128: 
129:             sent += 1;
130:             await markOutboxDelivered(event.id);
131:         } catch (error) {
132:             failed += 1;
133:             const attempts = event.attempts + 1;
134:             const message = error instanceof Error ? error.message : String(error);
135:             if (attempts >= config.webhookSyncMaxRetries) {
136:                 permanentFailures += 1;
137:                 await markOutboxPermanentFailure(event.id, attempts, message);
138:                 await logWarn('webhook.sync.event.permanent_failure', {
139:                     eventId: event.id,
140:                     idempotencyKey: event.idempotency_key,
141:                     attempts,
142:                     maxRetries: config.webhookSyncMaxRetries,
143:                     error: message,
144:                 });
145:             } else {
146:                 const delay = retryDelayMs(attempts);
147:                 await markOutboxRetry(event.id, attempts, delay, message);
148:             }
149:         }
150:     }
151: 
152:     await logInfo('webhook.sync.batch', {
153:         sent,
154:         failed,
155:         permanentFailures,
156:         batchSize: events.length,
157:         maxRetries: config.webhookSyncMaxRetries,
158:         endpointHost: endpointHost(config.webhookSyncUrl),
159:     });
160: 
161:     const pending = await countPendingOutboxEvents();
162:     if (pending > config.outboxAlertBacklog) {
163:         await logWarn('webhook.sync.backlog_high', { pending, threshold: config.outboxAlertBacklog });
164:         await sendTelegramAlert(`${pending} eventi pendenti non inviati al Webhook.`, 'Outbox Backlog Alto', 'warn');
165:     }
166: }
````

## File: src/telemetry/alerts.ts
````typescript
 1: import { config } from '../config';
 2: 
 3: export type AlertSeverity = 'info' | 'warn' | 'critical';
 4: 
 5: export async function sendTelegramAlert(message: string, title?: string, severity: AlertSeverity = 'info'): Promise<void> {
 6:     if (!config.telegramBotToken || !config.telegramChatId) {
 7:         return;
 8:     }
 9: 
10:     const icons: Record<AlertSeverity, string> = {
11:         info: '‚ÑπÔ∏è',
12:         warn: '‚ö†Ô∏è',
13:         critical: 'üö®'
14:     };
15: 
16:     const header = title ? `${icons[severity]} *${title}*\n\n` : `${icons[severity]} `;
17:     const text = `${header}${message}`;
18: 
19:     const endpoint = `https://api.telegram.org/bot${config.telegramBotToken}/sendMessage`;
20:     try {
21:         await fetch(endpoint, {
22:             method: 'POST',
23:             headers: { 'Content-Type': 'application/json' },
24:             body: JSON.stringify({
25:                 chat_id: config.telegramChatId,
26:                 text: text,
27:                 parse_mode: 'Markdown',
28:                 disable_web_page_preview: true,
29:             }),
30:         });
31:     } catch (error) {
32:         console.error('[WARN] Invio alert Telegram fallito', error);
33:     }
34: }
````

## File: src/tests/e2eDry.ts
````typescript
 1: import assert from 'assert';
 2: import fs from 'fs';
 3: import path from 'path';
 4: 
 5: async function run(): Promise<void> {
 6:     const testDbPath = path.resolve(process.cwd(), 'data', 'test_e2e_dry.sqlite');
 7:     if (fs.existsSync(testDbPath)) {
 8:         fs.unlinkSync(testDbPath);
 9:     }
10: 
11:     process.env.DB_PATH = testDbPath;
12:     process.env.SUPABASE_SYNC_ENABLED = 'false';
13:     process.env.SELECTOR_CANARY_ENABLED = 'false';
14:     process.env.HOUR_START = '0';
15:     process.env.HOUR_END = '24';
16: 
17:     const dbModule = await import('../db');
18:     const repositories = await import('../core/repositories');
19:     const orchestrator = await import('../core/orchestrator');
20: 
21:     await dbModule.initDatabase();
22: 
23:     await repositories.addLead({
24:         accountName: 'Dry Run Srl',
25:         firstName: 'Dry',
26:         lastName: 'Run',
27:         jobTitle: 'Test Lead',
28:         website: 'https://example.org',
29:         linkedinUrl: 'https://www.linkedin.com/in/dry-run-lead-test/',
30:         listName: 'dry-list',
31:     });
32:     await repositories.promoteNewLeadsToReadyInvite(10);
33: 
34:     // Esegue runWorkflow completo invece del solo scheduler.
35:     // In modalit√† dryRun, questo verifica l'intero path logico (budget, lead scoring, cooldown)
36:     // ritornando void senza inserire record fisici. Asseriamo che completi senza eccezioni.
37:     await orchestrator.runWorkflow({ workflow: 'invite', dryRun: true });
38:     assert.ok(true, 'runWorkflow in dryRun completato senza eccezioni');
39: 
40:     await dbModule.closeDatabase();
41:     if (fs.existsSync(testDbPath)) {
42:         fs.unlinkSync(testDbPath);
43:     }
44: }
45: 
46: run()
47:     .then(() => {
48:         console.log('Dry-run scenario passed.');
49:     })
50:     .catch((error) => {
51:         console.error(error);
52:         process.exit(1);
53:     });
````

## File: src/workers/context.ts
````typescript
1: import { BrowserSession } from '../browser';
2: 
3: export interface WorkerContext {
4:     session: BrowserSession;
5:     dryRun: boolean;
6:     localDate: string;
7:     accountId: string;
8: }
````

## File: src/ai/inviteNotePersonalizer.ts
````typescript
  1: import { config } from '../config';
  2: import { generateInviteNote } from '../noteGenerator';
  3: import { LeadRecord } from '../types/domain';
  4: import { logWarn } from '../telemetry/logger';
  5: import { requestOpenAIText } from './openaiClient';
  6: import { SemanticChecker } from './semanticChecker';
  7: 
  8: export interface PersonalizedInviteNoteResult {
  9:     note: string;
 10:     source: 'template' | 'ai';
 11:     model: string | null;
 12:     variant: string | null;
 13: }
 14: 
 15: const INVITE_NOTE_MAX_CHARS = 300;
 16: 
 17: function trimToMaxChars(input: string, maxChars: number = INVITE_NOTE_MAX_CHARS): string {
 18:     const normalized = input.replace(/\s+/g, ' ').trim();
 19:     if (!normalized) return '';
 20:     if (normalized.length <= maxChars) return normalized;
 21:     return normalized.slice(0, maxChars).trim();
 22: }
 23: 
 24: function safeFirstName(lead: LeadRecord): string {
 25:     const value = (lead.first_name ?? '').trim();
 26:     if (value) return value;
 27:     return 'collega';
 28: }
 29: 
 30: export async function buildPersonalizedInviteNote(lead: LeadRecord): Promise<PersonalizedInviteNoteResult> {
 31:     const tplResult = generateInviteNote(lead.first_name ?? '');
 32:     const templateText = trimToMaxChars(tplResult.note, INVITE_NOTE_MAX_CHARS);
 33: 
 34:     if (config.inviteNoteMode !== 'ai' || !config.openaiApiKey) {
 35:         return {
 36:             note: templateText,
 37:             source: 'template',
 38:             model: null,
 39:             variant: tplResult.variant,
 40:         };
 41:     }
 42: 
 43:     // Varianti Prompt A/B Testing
 44:     const isVariantB = Math.random() > 0.5;
 45:     const variantId = isVariantB ? 'AI_VAR_B_VALUE' : 'AI_VAR_A_DIRECT';
 46: 
 47:     let systemPrompt = '';
 48: 
 49:     if (isVariantB) {
 50:         systemPrompt = [
 51:             'Sei un top performer del social selling B2B su LinkedIn.',
 52:             'Crea una brevissima nota di connessione (max 2 frasi) estraendo valore dal profilo dell\'utente.',
 53:             'Fai una leva specifica su qualcosa del suo About o Experience per dimostrare che hai letto il profilo.',
 54:             `Massimo ${INVITE_NOTE_MAX_CHARS} caratteri.`,
 55:             'Non vendere nulla, cerca solo di avviare una conversazione interessante.',
 56:             'Niente emoji, niente ciao generici.'
 57:         ].join(' ');
 58:     } else {
 59:         systemPrompt = [
 60:             'Sei un assistant B2B per inviti LinkedIn in italiano.',
 61:             'Genera una singola nota breve, sincera e genuina (1-2 frasi).',
 62:             `Massimo ${INVITE_NOTE_MAX_CHARS} caratteri.`,
 63:             'Tono professionale ma colloquiale (non troppo formale). Niente link, niente emoji.',
 64:         ].join(' ');
 65:     }
 66: 
 67:     const userData: Record<string, string> = {
 68:         firstName: safeFirstName(lead),
 69:         company: lead.account_name,
 70:         role: lead.job_title,
 71:     };
 72: 
 73:     if (lead.about) userData.aboutProfile = lead.about;
 74:     if (lead.experience) userData.experienceProfile = lead.experience;
 75: 
 76:     const userPrompt = JSON.stringify(userData);
 77: 
 78:     let finalNote = '';
 79:     let attempt = 0;
 80:     const baseTemp = isVariantB ? 0.8 : 0.6;
 81: 
 82:     while (attempt < 3) {
 83:         attempt++;
 84:         try {
 85:             const generated = await requestOpenAIText({
 86:                 system: systemPrompt,
 87:                 user: `Dati lead: ${userPrompt}`,
 88:                 maxOutputTokens: 120,
 89:                 temperature: baseTemp + (attempt * 0.15),
 90:             });
 91:             const candidate = trimToMaxChars(generated, INVITE_NOTE_MAX_CHARS);
 92: 
 93:             if (!candidate) continue;
 94: 
 95:             if (await SemanticChecker.isTooSimilar(candidate, 0.85)) {
 96:                 await logWarn('ai.invite_note.too_similar_retry', { leadId: lead.id, attempt });
 97:                 continue;
 98:             }
 99: 
100:             finalNote = candidate;
101:             break;
102:         } catch (error) {
103:             await logWarn('ai.invite_note.error', {
104:                 leadId: lead.id,
105:                 error: error instanceof Error ? error.message : String(error),
106:             });
107:             break;
108:         }
109:     }
110: 
111:     if (!finalNote) {
112:         await logWarn('ai.invite_note.fallback_template', { leadId: lead.id, reason: 'Exhausted attempts or API error' });
113:         return {
114:             note: templateText,
115:             source: 'template',
116:             model: null,
117:             variant: tplResult.variant,
118:         };
119:     }
120: 
121:     await SemanticChecker.remember(finalNote);
122:     return {
123:         note: finalNote,
124:         source: 'ai',
125:         model: config.aiModel,
126:         variant: variantId,
127:     };
128: }
````

## File: src/ai/openaiClient.ts
````typescript
  1: import { config } from '../config';
  2: 
  3: interface OpenAITextRequest {
  4:     system: string;
  5:     user: string;
  6:     maxOutputTokens: number;
  7:     temperature: number;
  8:     responseFormat?: 'json_object' | 'text';
  9: }
 10: 
 11: function isLocalAiEndpoint(baseUrl: string): boolean {
 12:     try {
 13:         const url = new URL(baseUrl);
 14:         const host = url.hostname.toLowerCase();
 15:         if (host === 'localhost' || host === '127.0.0.1' || host === '::1') {
 16:             return true;
 17:         }
 18:         return host.endsWith('.local');
 19:     } catch {
 20:         return false;
 21:     }
 22: }
 23: 
 24: function safeJoinUrl(baseUrl: string, suffix: string): string {
 25:     return `${baseUrl.replace(/\/+$/, '')}${suffix}`;
 26: }
 27: 
 28: function extractOutputText(payload: unknown): string {
 29:     if (!payload || typeof payload !== 'object') {
 30:         return '';
 31:     }
 32: 
 33:     // Standard OpenAI format: payload.choices[0].message.content
 34:     const payloadObj = payload as { choices?: Array<{ message?: { content?: unknown } }> };
 35:     if (Array.isArray(payloadObj.choices) && payloadObj.choices.length > 0) {
 36:         const firstChoice = payloadObj.choices[0];
 37:         if (firstChoice?.message?.content && typeof firstChoice.message.content === 'string') {
 38:             return firstChoice.message.content.trim();
 39:         }
 40:     }
 41: 
 42:     return '';
 43: }
 44: 
 45: export function isOpenAIConfigured(): boolean {
 46:     return isLocalAiEndpoint(config.openaiBaseUrl) || !!config.openaiApiKey;
 47: }
 48: 
 49: export async function requestOpenAIText(input: OpenAITextRequest): Promise<string> {
 50:     const localEndpoint = isLocalAiEndpoint(config.openaiBaseUrl);
 51:     if (!config.aiAllowRemoteEndpoint && !localEndpoint) {
 52:         throw new Error(
 53:             'Endpoint AI remoto bloccato: imposta OPENAI_BASE_URL su localhost oppure AI_ALLOW_REMOTE_ENDPOINT=true.'
 54:         );
 55:     }
 56:     if (!config.openaiApiKey && !localEndpoint) {
 57:         throw new Error('OPENAI_API_KEY mancante.');
 58:     }
 59: 
 60:     const headers: Record<string, string> = {
 61:         'content-type': 'application/json',
 62:     };
 63:     if (config.openaiApiKey) {
 64:         headers.authorization = `Bearer ${config.openaiApiKey}`;
 65:     }
 66: 
 67:     const response = await fetch(safeJoinUrl(config.openaiBaseUrl, '/chat/completions'), {
 68:         method: 'POST',
 69:         headers,
 70:         body: JSON.stringify({
 71:             model: config.aiModel,
 72:             messages: [
 73:                 { role: 'system', content: input.system },
 74:                 { role: 'user', content: input.user },
 75:             ],
 76:             temperature: input.temperature,
 77:             max_tokens: input.maxOutputTokens, // OpenAI uses max_tokens natively, non max_output_tokens
 78:             ...(input.responseFormat ? { response_format: { type: input.responseFormat } } : {})
 79:         }),
 80:         signal: AbortSignal.timeout(config.aiRequestTimeoutMs),
 81:     });
 82: 
 83:     if (!response.ok) {
 84:         const text = (await response.text().catch(() => '')).slice(0, 500);
 85:         throw new Error(`OpenAI HTTP ${response.status}: ${response.statusText}${text ? ` ${text}` : ''}`);
 86:     }
 87: 
 88:     const payload = await response.json().catch(() => null);
 89:     const outputText = extractOutputText(payload);
 90:     if (!outputText) {
 91:         throw new Error('Risposta AI vuota o non parseabile.');
 92:     }
 93:     return outputText;
 94: }
 95: 
 96: export async function requestOpenAIEmbeddings(input: string): Promise<number[]> {
 97:     const localEndpoint = isLocalAiEndpoint(config.openaiBaseUrl);
 98:     if (!config.aiAllowRemoteEndpoint && !localEndpoint) {
 99:         throw new Error('Endpoint AI remoto bloccato.');
100:     }
101:     if (!config.openaiApiKey && !localEndpoint) {
102:         throw new Error('OPENAI_API_KEY mancante.');
103:     }
104: 
105:     const headers: Record<string, string> = {
106:         'content-type': 'application/json',
107:     };
108:     if (config.openaiApiKey) {
109:         headers.authorization = `Bearer ${config.openaiApiKey}`;
110:     }
111: 
112:     const response = await fetch(safeJoinUrl(config.openaiBaseUrl, '/embeddings'), {
113:         method: 'POST',
114:         headers,
115:         body: JSON.stringify({
116:             model: config.aiModel,
117:             input: input,
118:         }),
119:         signal: AbortSignal.timeout(config.aiRequestTimeoutMs),
120:     });
121: 
122:     if (!response.ok) {
123:         const text = (await response.text().catch(() => '')).slice(0, 500);
124:         throw new Error(`OpenAI Embeddings HTTP ${response.status}: ${response.statusText}${text ? ` ${text}` : ''}`);
125:     }
126: 
127:     const payload = await response.json().catch(() => null);
128:     if (payload?.data?.[0]?.embedding) {
129:         return payload.data[0].embedding as number[];
130:     }
131: 
132:     // Compatibilit√† diretta con Ollama native API se non viene esposto formato OpenAI
133:     if (payload?.embedding && Array.isArray(payload.embedding)) {
134:         return payload.embedding as number[];
135:     }
136: 
137:     throw new Error('Risposta API Embeddings malformata.');
138: }
````

## File: src/cloud/supabaseDataClient.ts
````typescript
  1: /**
  2:  * supabaseDataClient.ts
  3:  *
  4:  * Client Supabase per operazioni sui dati operativi cloud.
  5:  * Tutte le operazioni sono non-bloccanti: in assenza di config
  6:  * o in caso di errore di rete, falliscono silenziosamente
  7:  * senza interrompere il flusso principale del bot.
  8:  *
  9:  * Architettura: Dual-Write (SQLite locale √® la source of truth,
 10:  * Supabase √® il mirror cloud per monitoring, analytics e Control Plane).
 11:  */
 12: 
 13: import { createClient, SupabaseClient } from '@supabase/supabase-js';
 14: import { config } from '../config';
 15: import { logWarn } from '../telemetry/logger';
 16: 
 17: // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 18: // Client singleton
 19: // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 20: 
 21: let _client: SupabaseClient | null = null;
 22: 
 23: function getClient(): SupabaseClient | null {
 24:     if (!config.supabaseSyncEnabled) return null;
 25:     if (!config.supabaseUrl || !config.supabaseServiceRoleKey) return null;
 26:     if (!_client) {
 27:         _client = createClient(config.supabaseUrl, config.supabaseServiceRoleKey, {
 28:             auth: { persistSession: false, autoRefreshToken: false },
 29:         });
 30:     }
 31:     return _client;
 32: }
 33: 
 34: function isConfigured(): boolean {
 35:     return !!(config.supabaseSyncEnabled && config.supabaseUrl && config.supabaseServiceRoleKey);
 36: }
 37: 
 38: // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 39: // Tipi cloud
 40: // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 41: 
 42: export interface CloudAccount {
 43:     id: string;
 44:     display_name?: string | null;
 45:     session_dir?: string | null;
 46:     proxy_url?: string | null;
 47:     tier: 'WARM_UP' | 'ACTIVE' | 'QUARANTINE' | 'BANNED';
 48:     health: 'GREEN' | 'YELLOW' | 'RED';
 49:     daily_invite_cap: number;
 50:     daily_message_cap: number;
 51:     daily_invites_sent: number;
 52:     daily_messages_sent: number;
 53:     farming_ends_at?: string | null;
 54:     last_active_at?: string | null;
 55:     quarantine_reason?: string | null;
 56:     quarantine_until?: string | null;
 57:     updated_at?: string | null;
 58: }
 59: 
 60: export interface CloudLeadUpsert {
 61:     local_id?: number | null;
 62:     linkedin_url: string;
 63:     first_name: string;
 64:     last_name: string;
 65:     job_title: string;
 66:     account_name: string;
 67:     website: string;
 68:     list_name: string;
 69:     status: string;
 70:     invited_at?: string | null;
 71:     accepted_at?: string | null;
 72:     messaged_at?: string | null;
 73:     last_error?: string | null;
 74:     blocked_reason?: string | null;
 75:     about?: string | null;
 76:     experience?: string | null;
 77:     invite_note_sent?: string | null;
 78:     lead_score?: number | null;
 79:     confidence_score?: number | null;
 80:     updated_at?: string | null;
 81: }
 82: 
 83: export interface CloudJobUpsert {
 84:     local_job_id?: number | null;
 85:     account_id: string;
 86:     type: string;
 87:     status: string;
 88:     priority: number;
 89:     payload: Record<string, unknown>;
 90:     idempotency_key: string;
 91:     attempts: number;
 92:     max_attempts: number;
 93:     next_run_at: string;
 94:     error_message?: string | null;
 95:     proof_screenshot_url?: string | null;
 96: }
 97: 
 98: export interface CloudDailyStatIncrement {
 99:     local_date: string;
100:     account_id: string;
101:     field: 'invites_sent' | 'messages_sent' | 'acceptances' | 'replies' | 'challenges_count' | 'selector_failures' | 'run_errors';
102:     amount?: number;
103: }
104: 
105: export interface PendingTelegramCommand {
106:     id: number;
107:     account_id: string | null;
108:     command: string;
109:     args: string | null;
110: }
111: 
112: export interface CloudCampaignConfig {
113:     name: string;
114:     is_active: boolean;
115:     priority: number;
116:     daily_invite_cap: number | null;
117:     daily_message_cap: number | null;
118:     updated_at?: string | null;
119: }
120: 
121: // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
122: // Account sync
123: // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
124: 
125: /**
126:  * Upserta un account nel cloud. Usare al boot del worker
127:  * per sincronizzare lo stato dell'account verso Supabase.
128:  */
129: export async function upsertCloudAccount(account: CloudAccount): Promise<void> {
130:     const sb = getClient();
131:     if (!sb) return;
132: 
133:     const { error } = await sb.from('accounts').upsert(
134:         { ...account, updated_at: new Date().toISOString() },
135:         { onConflict: 'id' }
136:     );
137:     if (error) {
138:         await logWarn('cloud.accounts.upsert.error', { accountId: account.id, error: error.message });
139:     }
140: }
141: 
142: /**
143:  * Aggiorna health e tier di un account cloud.
144:  * Chiamare quando l'AI Guardian o l'Incident Manager cambia stato.
145:  */
146: export async function updateCloudAccountHealth(
147:     accountId: string,
148:     health: CloudAccount['health'],
149:     quarantineReason?: string | null,
150:     quarantineUntil?: string | null
151: ): Promise<void> {
152:     const sb = getClient();
153:     if (!sb) return;
154: 
155:     const patch: Record<string, unknown> = { health, updated_at: new Date().toISOString() };
156:     if (quarantineReason !== undefined) patch['quarantine_reason'] = quarantineReason;
157:     if (quarantineUntil !== undefined) patch['quarantine_until'] = quarantineUntil;
158: 
159:     const { error } = await sb.from('accounts').update(patch).eq('id', accountId);
160:     if (error) {
161:         await logWarn('cloud.accounts.health.update.error', { accountId, error: error.message });
162:     }
163: }
164: 
165: /**
166:  * Aggiorna il contatore giornaliero inviti/messaggi su un account cloud.
167:  */
168: export async function incrementCloudAccountCounter(
169:     accountId: string,
170:     field: 'daily_invites_sent' | 'daily_messages_sent',
171:     amount: number = 1
172: ): Promise<void> {
173:     const sb = getClient();
174:     if (!sb) return;
175: 
176:     // PostgreSQL: usiamo rpc per fare incremento atomico
177:     const { error } = await sb.rpc('increment_account_counter', {
178:         p_account_id: accountId,
179:         p_field: field,
180:         p_amount: amount,
181:     });
182:     if (error) {
183:         // Fallback: leggi il valore corrente e fai update manuale
184:         const { data } = await sb.from('accounts').select(field).eq('id', accountId).single();
185:         const current = (data as Record<string, number> | null)?.[field] ?? 0;
186:         await sb.from('accounts').update({
187:             [field]: current + amount,
188:             updated_at: new Date().toISOString(),
189:         }).eq('id', accountId);
190:     }
191: }
192: 
193: // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
194: // Lead sync
195: // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
196: 
197: /**
198:  * Upserta un lead nel cloud. linkedin_url √® la chiave di conflitto.
199:  * Non-bloccante: errori sono loggati ma non propagati.
200:  */
201: export async function upsertCloudLead(lead: CloudLeadUpsert): Promise<void> {
202:     const sb = getClient();
203:     if (!sb) return;
204: 
205:     const { error } = await sb.from('leads').upsert(
206:         { ...lead, updated_at: new Date().toISOString() },
207:         { onConflict: 'linkedin_url' }
208:     );
209:     if (error) {
210:         await logWarn('cloud.leads.upsert.error', { linkedinUrl: lead.linkedin_url, error: error.message });
211:     }
212: }
213: 
214: /**
215:  * Aggiorna lo status di un lead cloud (es. da INVITED a CONNECTED).
216:  * Chiamare dopo ogni setLeadStatus locale riuscito.
217:  */
218: export async function updateCloudLeadStatus(
219:     linkedinUrl: string,
220:     status: string,
221:     patch?: Partial<CloudLeadUpsert>
222: ): Promise<void> {
223:     const sb = getClient();
224:     if (!sb) return;
225: 
226:     const record: Record<string, unknown> = {
227:         ...patch,
228:         status,
229:         updated_at: new Date().toISOString(),
230:     };
231: 
232:     const { error } = await sb.from('leads').update(record).eq('linkedin_url', linkedinUrl);
233:     if (error) {
234:         await logWarn('cloud.leads.status.update.error', { linkedinUrl, status, error: error.message });
235:     }
236: }
237: 
238: /**
239:  * Batch upsert di un array di lead. Usare nella prima sync
240:  * o durante l'importazione CSV massiva.
241:  */
242: export async function batchUpsertCloudLeads(leads: CloudLeadUpsert[]): Promise<void> {
243:     if (leads.length === 0) return;
244:     const sb = getClient();
245:     if (!sb) return;
246: 
247:     const records = leads.map((l) => ({ ...l, updated_at: new Date().toISOString() }));
248:     const CHUNK_SIZE = 200;
249: 
250:     for (let i = 0; i < records.length; i += CHUNK_SIZE) {
251:         const chunk = records.slice(i, i + CHUNK_SIZE);
252:         const { error } = await sb.from('leads').upsert(chunk, { onConflict: 'linkedin_url' });
253:         if (error) {
254:             await logWarn('cloud.leads.batch_upsert.error', {
255:                 chunk: i / CHUNK_SIZE,
256:                 count: chunk.length,
257:                 error: error.message,
258:             });
259:         }
260:     }
261: }
262: 
263: // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
264: // Job sync
265: // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
266: 
267: /**
268:  * Upserta un job nel cloud. Usare al momento della creazione
269:  * e aggiornamento dello stato del job.
270:  */
271: export async function upsertCloudJob(job: CloudJobUpsert): Promise<void> {
272:     const sb = getClient();
273:     if (!sb) return;
274: 
275:     const { error } = await sb.from('jobs_cloud').upsert(
276:         { ...job, updated_at: new Date().toISOString() },
277:         { onConflict: 'idempotency_key' }
278:     );
279:     if (error) {
280:         await logWarn('cloud.jobs.upsert.error', { idempotencyKey: job.idempotency_key, error: error.message });
281:     }
282: }
283: 
284: // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
285: // Daily stats cloud sync
286: // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
287: 
288: /**
289:  * Incrementa una statistica giornaliera nel cloud.
290:  * Replica di incrementDailyStat locale in formato cloud.
291:  */
292: export async function incrementCloudDailyStat(opts: CloudDailyStatIncrement): Promise<void> {
293:     const sb = getClient();
294:     if (!sb) return;
295: 
296:     const amount = opts.amount ?? 1;
297:     const { error } = await sb.rpc('increment_daily_stat_cloud', {
298:         p_local_date: opts.local_date,
299:         p_account_id: opts.account_id,
300:         p_field: opts.field,
301:         p_amount: amount,
302:     });
303:     if (error) {
304:         // Fallback: upsert manuale
305:         const { data } = await sb
306:             .from('daily_stats_cloud')
307:             .select(opts.field)
308:             .eq('local_date', opts.local_date)
309:             .eq('account_id', opts.account_id)
310:             .single();
311:         const current = (data as Record<string, number> | null)?.[opts.field] ?? 0;
312:         await sb.from('daily_stats_cloud').upsert(
313:             {
314:                 local_date: opts.local_date,
315:                 account_id: opts.account_id,
316:                 [opts.field]: current + amount,
317:                 updated_at: new Date().toISOString(),
318:             },
319:             { onConflict: 'local_date,account_id' }
320:         );
321:     }
322: }
323: 
324: // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
325: // Telegram Command polling (Control Plane)
326: // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
327: 
328: /**
329:  * Preleva il primo comando Telegram pendente per un determinato account.
330:  * Usare nel loop principale per intercettare interventi umani (es. pin 2FA).
331:  */
332: export async function pollPendingTelegramCommand(accountId: string): Promise<PendingTelegramCommand | null> {
333:     const sb = getClient();
334:     if (!sb) return null;
335: 
336:     const { data, error } = await sb
337:         .from('telegram_commands')
338:         .select('id, account_id, command, args')
339:         .eq('status', 'PENDING')
340:         .eq('account_id', accountId)
341:         .order('created_at', { ascending: true })
342:         .limit(1)
343:         .single();
344: 
345:     if (error || !data) return null;
346:     return data as PendingTelegramCommand;
347: }
348: 
349: /**
350:  * Segna un comando Telegram come processato.
351:  */
352: export async function markTelegramCommandProcessed(commandId: number): Promise<void> {
353:     const sb = getClient();
354:     if (!sb) return;
355: 
356:     await sb.from('telegram_commands').update({
357:         status: 'PROCESSED',
358:         processed_at: new Date().toISOString(),
359:     }).eq('id', commandId);
360: }
361: 
362: // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
363: // Health check
364: // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
365: 
366: /**
367:  * Verifica la connettivit√† con Supabase.
368:  * Ritorna true se il cloud √® raggiungibile e configurato.
369:  */
370: export async function checkCloudConnectivity(): Promise<boolean> {
371:     if (!isConfigured()) return false;
372:     const sb = getClient();
373:     if (!sb) return false;
374: 
375:     try {
376:         const { error } = await sb.from('accounts').select('id').limit(1);
377:         return !error;
378:     } catch {
379:         return false;
380:     }
381: }
382: 
383: /**
384:  * Legge le configurazioni campagne dal Control Plane Supabase.
385:  * La tabella attesa e `campaigns`.
386:  */
387: export async function fetchCloudCampaignConfigs(limit: number): Promise<CloudCampaignConfig[]> {
388:     const sb = getClient();
389:     if (!sb) return [];
390: 
391:     const safeLimit = Math.max(1, limit);
392:     try {
393:         const { data, error } = await sb
394:             .from('campaigns')
395:             .select('name, is_active, priority, daily_invite_cap, daily_message_cap, updated_at')
396:             .order('priority', { ascending: true })
397:             .order('name', { ascending: true })
398:             .limit(safeLimit);
399: 
400:         if (error || !data) {
401:             await logWarn('cloud.campaigns.fetch.error', { error: error?.message ?? 'unknown' });
402:             return [];
403:         }
404: 
405:         const normalized: CloudCampaignConfig[] = [];
406:         for (const row of data as Array<Record<string, unknown>>) {
407:             const rawName = typeof row.name === 'string' ? row.name.trim() : '';
408:             if (!rawName) continue;
409: 
410:             const rawPriority = typeof row.priority === 'number' ? row.priority : Number(row.priority ?? 100);
411:             const priority = Number.isFinite(rawPriority) ? Math.max(1, Math.floor(rawPriority)) : 100;
412: 
413:             const inviteCap = row.daily_invite_cap === null || row.daily_invite_cap === undefined
414:                 ? null
415:                 : Math.max(0, Number(row.daily_invite_cap));
416:             const messageCap = row.daily_message_cap === null || row.daily_message_cap === undefined
417:                 ? null
418:                 : Math.max(0, Number(row.daily_message_cap));
419: 
420:             normalized.push({
421:                 name: rawName,
422:                 is_active: row.is_active === false ? false : true,
423:                 priority,
424:                 daily_invite_cap: inviteCap !== null && Number.isFinite(inviteCap) ? Math.floor(inviteCap) : null,
425:                 daily_message_cap: messageCap !== null && Number.isFinite(messageCap) ? Math.floor(messageCap) : null,
426:                 updated_at: typeof row.updated_at === 'string' ? row.updated_at : null,
427:             });
428:         }
429:         return normalized;
430:     } catch (error: unknown) {
431:         const message = error instanceof Error ? error.message : String(error);
432:         await logWarn('cloud.campaigns.fetch.exception', { error: message });
433:         return [];
434:     }
435: }
436: 
437: // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
438: // Downsync (Bidirectional Sync)
439: // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
440: 
441: /**
442:  * Legge gli accounts modificati sul cloud dopo lastSyncAt.
443:  */
444: export async function fetchCloudAccountsUpdates(lastSyncAt: string | null, limit: number = 100): Promise<CloudAccount[]> {
445:     const sb = getClient();
446:     if (!sb) return [];
447: 
448:     const safeLimit = Math.max(1, limit);
449:     try {
450:         let query = sb.from('accounts').select('*').order('updated_at', { ascending: true }).limit(safeLimit);
451: 
452:         if (lastSyncAt) {
453:             query = query.gt('updated_at', lastSyncAt);
454:         }
455: 
456:         const { data, error } = await query;
457: 
458:         if (error || !data) {
459:             await logWarn('cloud.accounts.fetch_updates.error', { error: error?.message ?? 'unknown' });
460:             return [];
461:         }
462: 
463:         // Cast safely
464:         return data as CloudAccount[];
465:     } catch (error: unknown) {
466:         const message = error instanceof Error ? error.message : String(error);
467:         await logWarn('cloud.accounts.fetch_updates.exception', { error: message });
468:         return [];
469:     }
470: }
471: 
472: /**
473:  * Legge i leads modificati sul cloud dopo lastSyncAt.
474:  */
475: export async function fetchCloudLeadsUpdates(lastSyncAt: string | null, limit: number = 500): Promise<CloudLeadUpsert[]> {
476:     const sb = getClient();
477:     if (!sb) return [];
478: 
479:     const safeLimit = Math.max(1, limit);
480:     try {
481:         let query = sb.from('leads').select('*').order('updated_at', { ascending: true }).limit(safeLimit);
482: 
483:         if (lastSyncAt) {
484:             query = query.gt('updated_at', lastSyncAt);
485:         }
486: 
487:         const { data, error } = await query;
488: 
489:         if (error || !data) {
490:             await logWarn('cloud.leads.fetch_updates.error', { error: error?.message ?? 'unknown' });
491:             return [];
492:         }
493: 
494:         // Cast safely
495:         return data as CloudLeadUpsert[];
496:     } catch (error: unknown) {
497:         const message = error instanceof Error ? error.message : String(error);
498:         await logWarn('cloud.leads.fetch_updates.exception', { error: message });
499:         return [];
500:     }
501: }
````

## File: src/core/audit.ts
````typescript
  1: import { checkLogin, closeBrowser, detectChallenge, humanDelay, launchBrowser } from '../browser';
  2: import { getAccountProfileById, pickAccountIdForLead } from '../accountManager';
  3: import { config } from '../config';
  4: import { quarantineAccount } from '../risk/incidentManager';
  5: import { SELECTORS } from '../selectors';
  6: import { LeadRecord } from '../types/domain';
  7: import { reconcileLeadStatus, transitionLead } from './leadStateService';
  8: import {
  9:     countCompanyTargets,
 10:     countCompanyTargetsByStatuses,
 11:     countLeadsByStatuses,
 12:     countPendingOutboxEvents,
 13:     getJobStatusCounts,
 14:     getLeadsByStatusForSiteCheck,
 15:     JobStatusCounts,
 16:     touchLeadSiteCheckAt,
 17: } from './repositories';
 18: import { Page } from 'playwright';
 19: 
 20: export interface FunnelReport {
 21:     totals: {
 22:         leads: number;
 23:         companyTargets: number;
 24:         queuedJobs: number;
 25:         pendingOutbox: number;
 26:     };
 27:     connections: {
 28:         toSend: number;
 29:         invitedPendingAcceptance: number;
 30:         acceptedReadyMessage: number;
 31:         completed: number;
 32:     };
 33:     messages: {
 34:         toSend: number;
 35:         sent: number;
 36:         blockedOrSkipped: number;
 37:     };
 38:     companyTargetStatuses: {
 39:         NEW: number;
 40:         ENRICHED: number;
 41:         NO_MATCH: number;
 42:         ERROR: number;
 43:     };
 44:     leadStatuses: Record<string, number>;
 45:     jobs: JobStatusCounts;
 46: }
 47: 
 48: export interface SiteCheckItem {
 49:     leadId: number;
 50:     status: string;
 51:     linkedinUrl: string;
 52:     siteSignals: SiteSignals;
 53:     mismatch: SiteMismatch;
 54:     fixed: boolean;
 55:     reviewRequired: boolean;
 56: }
 57: 
 58: export interface SiteCheckReport {
 59:     scanned: number;
 60:     mismatches: number;
 61:     fixed: number;
 62:     reviewRequired: number;
 63:     items: SiteCheckItem[];
 64: }
 65: 
 66: export interface SiteCheckOptions {
 67:     limitPerStatus: number;
 68:     autoFix: boolean;
 69:     staleDays?: number;
 70: }
 71: 
 72: export interface SiteSignals {
 73:     pendingInvite: boolean;
 74:     connected: boolean;
 75:     messageButton: boolean;
 76:     canConnect: boolean;
 77: }
 78: 
 79: export type SiteMismatch =
 80:     | 'invited_but_connected'
 81:     | 'invited_but_connect_available'
 82:     | 'ready_invite_but_pending'
 83:     | 'ready_invite_but_connected'
 84:     | 'ready_message_but_pending_invite'
 85:     | 'ready_message_but_not_connected'
 86:     | 'messaged_but_pending_invite'
 87:     | 'messaged_but_not_connected';
 88: 
 89: const ambiguousMismatchSet = new Set<SiteMismatch>([
 90:     'ready_message_but_not_connected',
 91:     'messaged_but_not_connected',
 92: ]);
 93: 
 94: function isFirstDegreeBadge(text: string | null): boolean {
 95:     if (!text) return true;
 96:     return /1st|1¬∞|1\b/i.test(text);
 97: }
 98: 
 99: async function inspectLeadOnSite(lead: LeadRecord, sessionPage: Page): Promise<SiteSignals> {
100:     await sessionPage.goto(lead.linkedin_url, { waitUntil: 'domcontentloaded' });
101:     await humanDelay(sessionPage, 1200, 2200);
102: 
103:     const messageButton = (await sessionPage.locator(SELECTORS.messageButton).count()) > 0;
104:     const badgeText = await sessionPage.locator(SELECTORS.distanceBadge).first().textContent().catch(() => '');
105:     const connected = messageButton && isFirstDegreeBadge(badgeText);
106:     const pendingInvite = (await sessionPage.locator(SELECTORS.invitePendingIndicators).count()) > 0;
107:     const canConnect = (await sessionPage.locator(SELECTORS.connectButtonPrimary).count()) > 0;
108: 
109:     return {
110:         pendingInvite,
111:         connected,
112:         messageButton,
113:         canConnect,
114:     };
115: }
116: 
117: async function tryAutoFix(lead: LeadRecord, mismatch: SiteMismatch): Promise<boolean> {
118:     if (mismatch === 'invited_but_connected') {
119:         await transitionLead(lead.id, 'ACCEPTED', 'site_check_autofix_connected');
120:         await transitionLead(lead.id, 'READY_MESSAGE', 'site_check_autofix_ready_message');
121:         return true;
122:     }
123: 
124:     if (mismatch === 'ready_invite_but_pending') {
125:         await transitionLead(lead.id, 'INVITED', 'site_check_autofix_pending');
126:         return true;
127:     }
128: 
129:     if (mismatch === 'ready_invite_but_connected') {
130:         await transitionLead(lead.id, 'INVITED', 'site_check_autofix_connected_promote_invited');
131:         await transitionLead(lead.id, 'ACCEPTED', 'site_check_autofix_connected_promote_accepted');
132:         await transitionLead(lead.id, 'READY_MESSAGE', 'site_check_autofix_connected_promote_ready_message');
133:         return true;
134:     }
135: 
136:     if (mismatch === 'ready_message_but_pending_invite') {
137:         await reconcileLeadStatus(lead.id, 'INVITED', 'site_check_reconcile_ready_message_to_invited_pending');
138:         return true;
139:     }
140: 
141:     if (mismatch === 'messaged_but_pending_invite') {
142:         await reconcileLeadStatus(lead.id, 'INVITED', 'site_check_reconcile_messaged_to_invited_pending');
143:         return true;
144:     }
145: 
146:     if (mismatch === 'invited_but_connect_available') {
147:         await reconcileLeadStatus(lead.id, 'READY_INVITE', 'site_check_reconcile_invited_to_ready_invite_connect_available');
148:         return true;
149:     }
150: 
151:     return false;
152: }
153: 
154: export function classifySiteMismatch(status: LeadRecord['status'], signals: SiteSignals): SiteMismatch | null {
155:     if (status === 'INVITED' && signals.connected) {
156:         return 'invited_but_connected';
157:     }
158:     if (status === 'INVITED' && !signals.pendingInvite && signals.canConnect) {
159:         return 'invited_but_connect_available';
160:     }
161:     if (status === 'READY_INVITE' && signals.pendingInvite) {
162:         return 'ready_invite_but_pending';
163:     }
164:     if (status === 'READY_INVITE' && signals.connected) {
165:         return 'ready_invite_but_connected';
166:     }
167:     if (status === 'READY_MESSAGE' && signals.pendingInvite) {
168:         return 'ready_message_but_pending_invite';
169:     }
170:     if (status === 'READY_MESSAGE' && !signals.connected) {
171:         return 'ready_message_but_not_connected';
172:     }
173:     if (status === 'MESSAGED' && signals.pendingInvite) {
174:         return 'messaged_but_pending_invite';
175:     }
176:     if (status === 'MESSAGED' && !signals.connected) {
177:         return 'messaged_but_not_connected';
178:     }
179:     return null;
180: }
181: 
182: export function isMismatchAmbiguous(mismatch: SiteMismatch): boolean {
183:     return ambiguousMismatchSet.has(mismatch);
184: }
185: 
186: export async function buildFunnelReport(): Promise<FunnelReport> {
187:     const [
188:         newCount,
189:         readyInviteCount,
190:         invitedCount,
191:         acceptedCount,
192:         readyMessageCount,
193:         messagedCount,
194:         blockedCount,
195:         skippedCount,
196:         reviewRequiredCount,
197:         pendingOutbox,
198:         companyTargets,
199:         companyTargetsNew,
200:         companyTargetsEnriched,
201:         companyTargetsNoMatch,
202:         companyTargetsError,
203:         jobs,
204:     ] = await Promise.all([
205:         countLeadsByStatuses(['NEW']),
206:         countLeadsByStatuses(['READY_INVITE', 'PENDING']),
207:         countLeadsByStatuses(['INVITED']),
208:         countLeadsByStatuses(['ACCEPTED']),
209:         countLeadsByStatuses(['READY_MESSAGE']),
210:         countLeadsByStatuses(['MESSAGED']),
211:         countLeadsByStatuses(['BLOCKED']),
212:         countLeadsByStatuses(['SKIPPED']),
213:         countLeadsByStatuses(['REVIEW_REQUIRED']),
214:         countPendingOutboxEvents(),
215:         countCompanyTargets(),
216:         countCompanyTargetsByStatuses(['NEW']),
217:         countCompanyTargetsByStatuses(['ENRICHED']),
218:         countCompanyTargetsByStatuses(['NO_MATCH']),
219:         countCompanyTargetsByStatuses(['ERROR']),
220:         getJobStatusCounts(),
221:     ]);
222: 
223:     const totalLeads =
224:         newCount
225:         + readyInviteCount
226:         + invitedCount
227:         + acceptedCount
228:         + readyMessageCount
229:         + messagedCount
230:         + blockedCount
231:         + skippedCount
232:         + reviewRequiredCount;
233:     const queuedJobs = Object.values(jobs).reduce((acc, value) => acc + value, 0);
234: 
235:     return {
236:         totals: {
237:             leads: totalLeads,
238:             companyTargets,
239:             queuedJobs,
240:             pendingOutbox,
241:         },
242:         connections: {
243:             toSend: newCount + readyInviteCount,
244:             invitedPendingAcceptance: invitedCount,
245:             acceptedReadyMessage: acceptedCount + readyMessageCount,
246:             completed: messagedCount,
247:         },
248:         messages: {
249:             toSend: readyMessageCount,
250:             sent: messagedCount,
251:             blockedOrSkipped: blockedCount + skippedCount,
252:         },
253:         companyTargetStatuses: {
254:             NEW: companyTargetsNew,
255:             ENRICHED: companyTargetsEnriched,
256:             NO_MATCH: companyTargetsNoMatch,
257:             ERROR: companyTargetsError,
258:         },
259:         leadStatuses: {
260:             NEW: newCount,
261:             READY_INVITE: readyInviteCount,
262:             INVITED: invitedCount,
263:             ACCEPTED: acceptedCount,
264:             READY_MESSAGE: readyMessageCount,
265:             MESSAGED: messagedCount,
266:             BLOCKED: blockedCount,
267:             SKIPPED: skippedCount,
268:             REVIEW_REQUIRED: reviewRequiredCount,
269:         },
270:         jobs,
271:     };
272: }
273: 
274: export async function runSiteCheck(options: SiteCheckOptions): Promise<SiteCheckReport> {
275:     const limit = Math.max(1, options.limitPerStatus);
276:     const staleDays = Math.max(0, options.staleDays ?? config.siteCheckStaleDays);
277:     const [readyInviteLeads, invitedLeads, readyMessageLeads, messagedLeads] = await Promise.all([
278:         getLeadsByStatusForSiteCheck('READY_INVITE', limit, staleDays),
279:         getLeadsByStatusForSiteCheck('INVITED', limit, staleDays),
280:         getLeadsByStatusForSiteCheck('READY_MESSAGE', limit, staleDays),
281:         getLeadsByStatusForSiteCheck('MESSAGED', Math.max(5, Math.floor(limit / 2)), staleDays),
282:     ]);
283: 
284:     const candidates = [...readyInviteLeads, ...invitedLeads, ...readyMessageLeads, ...messagedLeads];
285:     if (candidates.length === 0) {
286:         return {
287:             scanned: 0,
288:             mismatches: 0,
289:             fixed: 0,
290:             reviewRequired: 0,
291:             items: [],
292:         };
293:     }
294: 
295:     const report: SiteCheckReport = {
296:         scanned: 0,
297:         mismatches: 0,
298:         fixed: 0,
299:         reviewRequired: 0,
300:         items: [],
301:     };
302: 
303:     const leadsByAccount = new Map<string, LeadRecord[]>();
304:     for (const lead of candidates) {
305:         const accountId = pickAccountIdForLead(lead.id);
306:         if (!leadsByAccount.has(accountId)) {
307:             leadsByAccount.set(accountId, []);
308:         }
309:         leadsByAccount.get(accountId)?.push(lead);
310:     }
311: 
312:     let challengeDetected = false;
313:     for (const [accountId, accountLeads] of leadsByAccount) {
314:         const account = getAccountProfileById(accountId);
315:         const session = await launchBrowser({
316:             sessionDir: account.sessionDir,
317:             proxy: account.proxy,
318:         });
319:         try {
320:             const loggedIn = await checkLogin(session.page);
321:             if (!loggedIn) {
322:                 await quarantineAccount('SITE_CHECK_LOGIN_MISSING', {
323:                     reason: 'Sessione non autenticata durante site-check',
324:                     accountId,
325:                 });
326:                 return report;
327:             }
328: 
329:             for (const lead of accountLeads) {
330:                 report.scanned += 1;
331:                 const signals = await inspectLeadOnSite(lead, session.page);
332:                 await touchLeadSiteCheckAt(lead.id);
333: 
334:                 if (await detectChallenge(session.page)) {
335:                     await quarantineAccount('SITE_CHECK_CHALLENGE_DETECTED', {
336:                         leadId: lead.id,
337:                         status: lead.status,
338:                         linkedinUrl: lead.linkedin_url,
339:                         accountId,
340:                     });
341:                     challengeDetected = true;
342:                     break;
343:                 }
344: 
345:                 const mismatch = classifySiteMismatch(lead.status, signals);
346: 
347:                 if (!mismatch) {
348:                     continue;
349:                 }
350: 
351:                 report.mismatches += 1;
352:                 let fixed = false;
353:                 let reviewRequired = false;
354:                 if (options.autoFix) {
355:                     fixed = await tryAutoFix(lead, mismatch);
356:                     if (fixed) {
357:                         report.fixed += 1;
358:                     } else if (isMismatchAmbiguous(mismatch)) {
359:                         await transitionLead(
360:                             lead.id,
361:                             'REVIEW_REQUIRED',
362:                             `site_check_ambiguous_${mismatch}`,
363:                             {
364:                                 mismatch,
365:                                 previousStatus: lead.status,
366:                                 siteSignals: signals,
367:                             }
368:                         );
369:                         report.reviewRequired += 1;
370:                         reviewRequired = true;
371:                     }
372:                 }
373: 
374:                 report.items.push({
375:                     leadId: lead.id,
376:                     status: lead.status,
377:                     linkedinUrl: lead.linkedin_url,
378:                     siteSignals: signals,
379:                     mismatch,
380:                     fixed,
381:                     reviewRequired,
382:                 });
383:             }
384:         } finally {
385:             await closeBrowser(session);
386:         }
387: 
388:         if (challengeDetected) {
389:             break;
390:         }
391:     }
392: 
393:     return report;
394: }
````

## File: src/core/orchestrator.ts
````typescript
  1: import { checkLogin, closeBrowser, launchBrowser, runSelectorCanary } from '../browser';
  2: import { getRuntimeAccountProfiles } from '../accountManager';
  3: import { config, getLocalDateString, isWorkingHour } from '../config';
  4: import { pauseAutomation, quarantineAccount } from '../risk/incidentManager';
  5: import { evaluateCooldownDecision } from '../risk/riskEngine';
  6: import { logInfo, logWarn } from '../telemetry/logger';
  7: import { runEventSyncOnce } from '../sync/eventSync';
  8: import { workflowToJobTypes, scheduleJobs, WorkflowSelection } from './scheduler';
  9: import { runSiteCheck } from './audit';
 10: 
 11: import { runQueuedJobs } from './jobRunner';
 12: import { getAutomationPauseState, getDailyStat, getRuntimeFlag, pushOutboxEvent } from './repositories';
 13: import { evaluateAiGuardian } from '../ai/guardian';
 14: import { runRandomLinkedinActivity } from '../workers/randomActivityWorker';
 15: 
 16: export interface RunWorkflowOptions {
 17:     workflow: WorkflowSelection;
 18:     dryRun: boolean;
 19: }
 20: 
 21: async function runCanaryIfNeeded(workflow: WorkflowSelection): Promise<boolean> {
 22:     const touchesUi = workflow === 'all' || workflow === 'invite' || workflow === 'message' || workflow === 'check';
 23:     if (!config.selectorCanaryEnabled || !touchesUi) {
 24:         return true;
 25:     }
 26: 
 27:     const accounts = getRuntimeAccountProfiles();
 28:     for (const account of accounts) {
 29:         const session = await launchBrowser({
 30:             sessionDir: account.sessionDir,
 31:             proxy: account.proxy,
 32:         });
 33:         try {
 34:             const loggedIn = await checkLogin(session.page);
 35:             if (!loggedIn) {
 36:                 return false;
 37:             }
 38:             const canaryOk = await runSelectorCanary(session.page);
 39:             if (!canaryOk) {
 40:                 return false;
 41:             }
 42:         } finally {
 43:             await closeBrowser(session);
 44:         }
 45:     }
 46: 
 47:     return true;
 48: }
 49: 
 50: export async function runWorkflow(options: RunWorkflowOptions): Promise<void> {
 51:     if (!options.dryRun) {
 52:         const quarantine = (await getRuntimeFlag('account_quarantine')) === 'true';
 53:         if (quarantine) {
 54:             await logWarn('workflow.skipped.quarantine', { workflow: options.workflow });
 55:             return;
 56:         }
 57: 
 58:         const pauseState = await getAutomationPauseState();
 59:         if (pauseState.paused) {
 60:             await logWarn('workflow.skipped.paused', {
 61:                 workflow: options.workflow,
 62:                 reason: pauseState.reason,
 63:                 pausedUntil: pauseState.pausedUntil,
 64:                 remainingSeconds: pauseState.remainingSeconds,
 65:             });
 66:             return;
 67:         }
 68:     }
 69: 
 70:     if (!options.dryRun && !isWorkingHour()) {
 71:         await logInfo('workflow.skipped.out_of_hours', {
 72:             startHour: config.workingHoursStart,
 73:             endHour: config.workingHoursEnd,
 74:         });
 75:         return;
 76:     }
 77: 
 78:     if (!options.dryRun) {
 79:         const localDate = getLocalDateString();
 80:         const selectorFailures = await getDailyStat(localDate, 'selector_failures');
 81:         if (selectorFailures >= config.maxSelectorFailuresPerDay) {
 82:             await quarantineAccount('SELECTOR_FAILURE_BURST', {
 83:                 workflow: options.workflow,
 84:                 localDate,
 85:                 selectorFailures,
 86:                 threshold: config.maxSelectorFailuresPerDay,
 87:             });
 88:             return;
 89:         }
 90: 
 91:         const runErrors = await getDailyStat(localDate, 'run_errors');
 92:         if (runErrors >= config.maxRunErrorsPerDay) {
 93:             await pauseAutomation(
 94:                 'RUN_ERRORS_BURST',
 95:                 {
 96:                     workflow: options.workflow,
 97:                     localDate,
 98:                     runErrors,
 99:                     threshold: config.maxRunErrorsPerDay,
100:                 },
101:                 config.autoPauseMinutesOnFailureBurst
102:             );
103:             await logWarn('workflow.skipped.run_error_burst', {
104:                 workflow: options.workflow,
105:                 localDate,
106:                 runErrors,
107:                 threshold: config.maxRunErrorsPerDay,
108:                 pauseMinutes: config.autoPauseMinutesOnFailureBurst,
109:             });
110:             return;
111:         }
112: 
113:         const canaryOk = await runCanaryIfNeeded(options.workflow);
114:         if (!canaryOk) {
115:             await quarantineAccount('SELECTOR_CANARY_FAILED', { workflow: options.workflow });
116:             return;
117:         }
118:     }
119: 
120:     const schedule = await scheduleJobs(options.workflow, { dryRun: options.dryRun });
121: 
122:     if (options.dryRun) {
123:         console.log('[DRY_RUN] workflow.preview', {
124:             workflow: options.workflow,
125:             localDate: schedule.localDate,
126:             risk: schedule.riskSnapshot,
127:             queuedInviteJobs: schedule.queuedInviteJobs,
128:             queuedCheckJobs: schedule.queuedCheckJobs,
129:             queuedMessageJobs: schedule.queuedMessageJobs,
130:             inviteBudget: schedule.inviteBudget,
131:             messageBudget: schedule.messageBudget,
132:             listBreakdown: schedule.listBreakdown,
133:         });
134:         return;
135:     }
136: 
137:     await pushOutboxEvent(
138:         'scheduler.snapshot',
139:         {
140:             workflow: options.workflow,
141:             localDate: schedule.localDate,
142:             risk: schedule.riskSnapshot,
143:             queuedInviteJobs: schedule.queuedInviteJobs,
144:             queuedCheckJobs: schedule.queuedCheckJobs,
145:             queuedMessageJobs: schedule.queuedMessageJobs,
146:             inviteBudget: schedule.inviteBudget,
147:             messageBudget: schedule.messageBudget,
148:             listBreakdown: schedule.listBreakdown,
149:         },
150:         `scheduler.snapshot:${schedule.localDate}:${options.workflow}`
151:     );
152: 
153:     if (schedule.riskSnapshot.action === 'STOP') {
154:         await quarantineAccount('RISK_STOP_THRESHOLD', {
155:             workflow: options.workflow,
156:             riskSnapshot: schedule.riskSnapshot,
157:         });
158:         return;
159:     }
160: 
161:     const guardian = await evaluateAiGuardian(options.workflow, schedule);
162:     if (guardian.decision) {
163:         await pushOutboxEvent(
164:             'ai.guardian.decision',
165:             {
166:                 workflow: options.workflow,
167:                 localDate: schedule.localDate,
168:                 executed: guardian.executed,
169:                 reason: guardian.reason,
170:                 decision: guardian.decision,
171:             },
172:             `ai.guardian.decision:${schedule.localDate}:${options.workflow}:${Date.now()}`
173:         );
174:         if (guardian.decision.severity === 'critical' && guardian.decision.pauseMinutes > 0) {
175:             await pauseAutomation(
176:                 'AI_GUARDIAN_PREEMPTIVE',
177:                 {
178:                     workflow: options.workflow,
179:                     localDate: schedule.localDate,
180:                     reason: guardian.reason,
181:                     decision: guardian.decision,
182:                 },
183:                 guardian.decision.pauseMinutes
184:             );
185:             await logWarn('ai.guardian.preemptive_pause', {
186:                 workflow: options.workflow,
187:                 localDate: schedule.localDate,
188:                 reason: guardian.reason,
189:                 pauseMinutes: guardian.decision.pauseMinutes,
190:                 summary: guardian.decision.summary,
191:             });
192:             return;
193:         }
194:         if (guardian.decision.severity === 'watch') {
195:             await logWarn('ai.guardian.watch', {
196:                 workflow: options.workflow,
197:                 localDate: schedule.localDate,
198:                 reason: guardian.reason,
199:                 summary: guardian.decision.summary,
200:                 recommendations: guardian.decision.recommendations,
201:             });
202:         } else {
203:             await logInfo('ai.guardian.normal', {
204:                 workflow: options.workflow,
205:                 localDate: schedule.localDate,
206:                 reason: guardian.reason,
207:                 summary: guardian.decision.summary,
208:             });
209:         }
210:     }
211: 
212:     const cooldown = evaluateCooldownDecision(schedule.riskSnapshot);
213:     if (cooldown.activate) {
214:         await pauseAutomation(
215:             'RISK_COOLDOWN',
216:             {
217:                 workflow: options.workflow,
218:                 localDate: schedule.localDate,
219:                 riskSnapshot: schedule.riskSnapshot,
220:                 tier: cooldown.tier,
221:                 reason: cooldown.reason,
222:                 listBreakdown: schedule.listBreakdown,
223:             },
224:             cooldown.minutes
225:         );
226:         await logWarn('risk.cooldown.activated', {
227:             workflow: options.workflow,
228:             localDate: schedule.localDate,
229:             tier: cooldown.tier,
230:             reason: cooldown.reason,
231:             pauseMinutes: cooldown.minutes,
232:             score: schedule.riskSnapshot.score,
233:             pendingRatio: schedule.riskSnapshot.pendingRatio,
234:         });
235:         return;
236:     }
237: 
238:     if (schedule.riskSnapshot.action === 'WARN') {
239:         await logWarn('risk.warn', {
240:             workflow: options.workflow,
241:             score: schedule.riskSnapshot.score,
242:             pendingRatio: schedule.riskSnapshot.pendingRatio,
243:         });
244:     }
245: 
246:     await runQueuedJobs({
247:         localDate: schedule.localDate,
248:         allowedTypes: workflowToJobTypes(options.workflow),
249:         dryRun: options.dryRun,
250:     });
251: 
252:     if (config.postRunStateSyncEnabled) {
253:         const stateSyncReport = await runSiteCheck({
254:             limitPerStatus: config.postRunStateSyncLimit,
255:             autoFix: config.postRunStateSyncFix,
256:         });
257:         await logInfo('state.sync.post_run', {
258:             workflow: options.workflow,
259:             localDate: schedule.localDate,
260:             limitPerStatus: config.postRunStateSyncLimit,
261:             autoFix: config.postRunStateSyncFix,
262:             report: stateSyncReport,
263:         });
264:         await pushOutboxEvent(
265:             'state.sync.post_run',
266:             {
267:                 workflow: options.workflow,
268:                 localDate: schedule.localDate,
269:                 limitPerStatus: config.postRunStateSyncLimit,
270:                 autoFix: config.postRunStateSyncFix,
271:                 report: stateSyncReport,
272:             },
273:             `state.sync.post_run:${schedule.localDate}:${options.workflow}:${Date.now()}`
274:         );
275:     }
276: 
277:     // Modalit√† Farming WARM_UP: Esegui generazione history organica
278:     if (!options.dryRun && options.workflow === 'warmup') {
279:         await logInfo('workflow.warmup.start', { localDate: schedule.localDate });
280:         // Utilizziamo account attivi o fallback al primo per lanciare la sessione
281:         const accounts = getRuntimeAccountProfiles();
282:         if (accounts.length > 0) {
283:             // Scegliamo casualmente uno o pi√π accounts
284:             for (const acc of accounts) {
285:                 await runRandomLinkedinActivity({
286:                     accountId: acc.id,
287:                     maxActions: Math.floor(Math.random() * 4) + 3, // 3 to 6 actions
288:                     dryRun: false
289:                 });
290:             }
291:         }
292:         await logInfo('workflow.warmup.end', { localDate: schedule.localDate });
293:     }
294: 
295:     await runEventSyncOnce();
296: }
````

## File: src/db.ts
````typescript
  1: import sqlite3 from 'sqlite3';
  2: import { open, Database } from 'sqlite';
  3: import path from 'path';
  4: import fs from 'fs';
  5: import { config } from './config';
  6: import { ensureFilePrivate, ensureParentDirectoryPrivate } from './security/filesystem';
  7: 
  8: let db: Database | null = null;
  9: 
 10: function resolveMigrationDirectory(): string {
 11:     const cwdMigrations = path.resolve(process.cwd(), 'src', 'db', 'migrations');
 12:     if (fs.existsSync(cwdMigrations)) {
 13:         return cwdMigrations;
 14:     }
 15:     const compiledMigrations = path.resolve(__dirname, 'db', 'migrations');
 16:     if (fs.existsSync(compiledMigrations)) {
 17:         return compiledMigrations;
 18:     }
 19:     throw new Error('Cartella migrazioni non trovata.');
 20: }
 21: 
 22: async function ensureColumn(database: Database, tableName: string, columnName: string, definition: string): Promise<void> {
 23:     const columns = await database.all<{ name: string }[]>(`PRAGMA table_info(${tableName})`);
 24:     const exists = columns.some((column) => column.name === columnName);
 25:     if (!exists) {
 26:         await database.exec(`ALTER TABLE ${tableName} ADD COLUMN ${columnName} ${definition}`);
 27:     }
 28: }
 29: 
 30: async function applyMigrations(database: Database): Promise<void> {
 31:     await database.exec(`
 32:         CREATE TABLE IF NOT EXISTS _migrations (
 33:             id INTEGER PRIMARY KEY AUTOINCREMENT,
 34:             name TEXT NOT NULL UNIQUE,
 35:             applied_at DATETIME DEFAULT CURRENT_TIMESTAMP
 36:         );
 37:     `);
 38: 
 39:     const migrationDir = resolveMigrationDirectory();
 40:     const files = fs
 41:         .readdirSync(migrationDir)
 42:         .filter((file) => file.endsWith('.sql'))
 43:         .sort((a, b) => a.localeCompare(b));
 44: 
 45:     for (const fileName of files) {
 46:         const alreadyApplied = await database.get<{ count: number }>(
 47:             `SELECT COUNT(*) as count FROM _migrations WHERE name = ?`,
 48:             [fileName]
 49:         );
 50:         if ((alreadyApplied?.count ?? 0) > 0) {
 51:             continue;
 52:         }
 53: 
 54:         const sql = fs.readFileSync(path.join(migrationDir, fileName), 'utf8');
 55:         await database.exec('BEGIN');
 56:         try {
 57:             await database.exec(sql);
 58:             await database.run(`INSERT INTO _migrations (name) VALUES (?)`, [fileName]);
 59:             await database.exec('COMMIT');
 60:         } catch (error) {
 61:             await database.exec('ROLLBACK');
 62:             throw error;
 63:         }
 64:     }
 65: 
 66:     // Hardening per DB gi√† esistenti creati prima del sistema migrazioni.
 67:     await ensureColumn(database, 'leads', 'list_name', `TEXT NOT NULL DEFAULT 'default'`);
 68:     await ensureColumn(database, 'leads', 'last_site_check_at', 'DATETIME');
 69:     await ensureColumn(database, 'leads', 'last_error', 'TEXT');
 70:     await ensureColumn(database, 'leads', 'blocked_reason', 'TEXT');
 71:     await ensureColumn(database, 'leads', 'updated_at', 'DATETIME DEFAULT CURRENT_TIMESTAMP');
 72:     await ensureColumn(database, 'lead_lists', 'is_active', 'INTEGER NOT NULL DEFAULT 1');
 73:     await ensureColumn(database, 'lead_lists', 'priority', 'INTEGER NOT NULL DEFAULT 100');
 74:     await ensureColumn(database, 'lead_lists', 'daily_invite_cap', 'INTEGER');
 75:     await ensureColumn(database, 'lead_lists', 'daily_message_cap', 'INTEGER');
 76:     await ensureColumn(database, 'daily_stats', 'messages_sent', 'INTEGER NOT NULL DEFAULT 0');
 77:     await ensureColumn(database, 'daily_stats', 'challenges_count', 'INTEGER NOT NULL DEFAULT 0');
 78:     await ensureColumn(database, 'daily_stats', 'selector_failures', 'INTEGER NOT NULL DEFAULT 0');
 79:     await ensureColumn(database, 'daily_stats', 'run_errors', 'INTEGER NOT NULL DEFAULT 0');
 80:     await ensureColumn(database, 'jobs', 'account_id', `TEXT NOT NULL DEFAULT 'default'`);
 81:     await database.exec(`
 82:         CREATE TABLE IF NOT EXISTS list_daily_stats (
 83:             date TEXT NOT NULL,
 84:             list_name TEXT NOT NULL,
 85:             invites_sent INTEGER NOT NULL DEFAULT 0,
 86:             messages_sent INTEGER NOT NULL DEFAULT 0,
 87:             PRIMARY KEY (date, list_name)
 88:         );
 89:     `);
 90:     await database.exec(`CREATE INDEX IF NOT EXISTS idx_list_daily_stats_list_date ON list_daily_stats(list_name, date);`);
 91:     await database.exec(`CREATE INDEX IF NOT EXISTS idx_leads_status_list_created ON leads(status, list_name, created_at);`);
 92:     await database.exec(`CREATE INDEX IF NOT EXISTS idx_leads_status_last_site_check ON leads(status, last_site_check_at, created_at);`);
 93:     await database.exec(`CREATE INDEX IF NOT EXISTS idx_jobs_type_status_next_run ON jobs(type, status, next_run_at, priority, created_at);`);
 94:     await database.exec(`CREATE INDEX IF NOT EXISTS idx_jobs_account_status_next_run ON jobs(account_id, status, next_run_at, priority, created_at);`);
 95:     await database.exec(`
 96:         CREATE TABLE IF NOT EXISTS company_targets (
 97:             id INTEGER PRIMARY KEY AUTOINCREMENT,
 98:             list_name TEXT NOT NULL,
 99:             account_name TEXT NOT NULL DEFAULT '',
100:             website TEXT NOT NULL DEFAULT '',
101:             source_file TEXT,
102:             status TEXT NOT NULL DEFAULT 'NEW',
103:             created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
104:             updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
105:         );
106:     `);
107:     await ensureColumn(database, 'company_targets', 'attempts', 'INTEGER NOT NULL DEFAULT 0');
108:     await ensureColumn(database, 'company_targets', 'last_error', 'TEXT');
109:     await ensureColumn(database, 'company_targets', 'processed_at', 'DATETIME');
110:     await database.exec(`
111:         CREATE UNIQUE INDEX IF NOT EXISTS uq_company_targets_list_account_website
112:             ON company_targets(list_name, account_name, website);
113:     `);
114:     await database.exec(`
115:         CREATE INDEX IF NOT EXISTS idx_company_targets_list_status
116:             ON company_targets(list_name, status, created_at);
117:     `);
118:     await database.exec(`
119:         CREATE TABLE IF NOT EXISTS runtime_locks (
120:             lock_key TEXT PRIMARY KEY,
121:             owner_id TEXT NOT NULL,
122:             acquired_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
123:             heartbeat_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
124:             expires_at DATETIME NOT NULL,
125:             metadata_json TEXT NOT NULL DEFAULT '{}',
126:             updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
127:         );
128:     `);
129:     await database.exec(`CREATE INDEX IF NOT EXISTS idx_runtime_locks_expires_at ON runtime_locks(expires_at);`);
130: }
131: 
132: export async function getDatabase(): Promise<Database> {
133:     if (db) return db;
134:     if (process.env.NODE_ENV === 'production' && !config.allowSqliteInProduction) {
135:         throw new Error(
136:             'SQLite in produzione bloccato. Migra a PostgreSQL encrypted oppure imposta ALLOW_SQLITE_IN_PRODUCTION=true esplicitamente.'
137:         );
138:     }
139: 
140:     ensureParentDirectoryPrivate(config.dbPath);
141: 
142:     db = await open({
143:         filename: config.dbPath,
144:         driver: sqlite3.Database,
145:     });
146: 
147:     await db.exec(`PRAGMA journal_mode = WAL;`);
148:     await db.exec(`PRAGMA busy_timeout = 5000;`);
149:     await db.exec(`PRAGMA synchronous = NORMAL;`);
150:     ensureFilePrivate(config.dbPath);
151: 
152:     return db;
153: }
154: 
155: export async function initDatabase(): Promise<void> {
156:     const database = await getDatabase();
157:     await applyMigrations(database);
158: }
159: 
160: export async function closeDatabase(): Promise<void> {
161:     if (db) {
162:         await db.close();
163:         db = null;
164:     }
165: }
166: 
167: export async function backupDatabase(): Promise<string> {
168:     const database = await getDatabase();
169:     const parsedPath = path.parse(config.dbPath);
170:     const dateStr = new Date().toISOString().split('T')[0]; // YYYY-MM-DD
171:     const backupPath = path.join(parsedPath.dir, `${parsedPath.name}_backup_${dateStr}${parsedPath.ext}`);
172: 
173:     // VACUUM INTO will fail if the file already exists
174:     if (fs.existsSync(backupPath)) {
175:         fs.unlinkSync(backupPath);
176:     }
177: 
178:     ensureParentDirectoryPrivate(backupPath);
179:     const safePath = backupPath.replace(/'/g, "''");
180: 
181:     await database.exec(`VACUUM INTO '${safePath}';`);
182:     ensureFilePrivate(backupPath);
183: 
184:     return backupPath;
185: }
````

## File: src/risk/incidentManager.ts
````typescript
 1: import { clearAutomationPause, createIncident, pushOutboxEvent, setAutomationPause, setRuntimeFlag } from '../core/repositories';
 2: import { sendTelegramAlert } from '../telemetry/alerts';
 3: import { bridgeAccountHealth } from '../cloud/cloudBridge';
 4: 
 5: export async function quarantineAccount(type: string, details: Record<string, unknown>): Promise<number> {
 6:     const incidentId = await createIncident(type, 'CRITICAL', details);
 7:     await setRuntimeFlag('account_quarantine', 'true');
 8:     await pushOutboxEvent(
 9:         'incident.opened',
10:         {
11:             incidentId,
12:             type,
13:             severity: 'CRITICAL',
14:             details,
15:         },
16:         `incident.opened:${incidentId}`
17:     );
18:     await sendTelegramAlert(`Dettagli:\n\`\`\`json\n${JSON.stringify(details, null, 2)}\n\`\`\``, `CRITICAL incident #${incidentId}: ${type}`, 'critical');
19:     // Replica cloud: aggiorna health account a RED (non-bloccante)
20:     bridgeAccountHealth('default', 'RED', type);
21:     return incidentId;
22: }
23: 
24: export async function setQuarantine(enabled: boolean): Promise<void> {
25:     await setRuntimeFlag('account_quarantine', enabled ? 'true' : 'false');
26: }
27: 
28: export async function pauseAutomation(type: string, details: Record<string, unknown>, minutes: number): Promise<number> {
29:     const incidentId = await createIncident(type, 'WARN', details);
30:     const pausedUntil = await setAutomationPause(minutes, type);
31:     await pushOutboxEvent(
32:         'automation.paused',
33:         {
34:             incidentId,
35:             type,
36:             severity: 'WARN',
37:             pausedUntil,
38:             details,
39:         },
40:         `automation.paused:${incidentId}`
41:     );
42:     await sendTelegramAlert(`Automazione in pausa fino a ${pausedUntil ?? 'manual resume'}\n\nDettagli:\n\`\`\`json\n${JSON.stringify(details, null, 2)}\n\`\`\``, `WARN incident #${incidentId}: ${type}`, 'warn');
43:     // Replica cloud: aggiorna health account a YELLOW (non-bloccante)
44:     bridgeAccountHealth('default', 'YELLOW', type, pausedUntil ?? null);
45:     return incidentId;
46: }
47: 
48: export async function resumeAutomation(): Promise<void> {
49:     await clearAutomationPause();
50: }
````

## File: src/workers/acceptanceWorker.ts
````typescript
 1: import { detectChallenge, humanDelay } from '../browser';
 2: import { transitionLead } from '../core/leadStateService';
 3: import { getLeadById, incrementDailyStat } from '../core/repositories';
 4: import { SELECTORS } from '../selectors';
 5: import { AcceptanceJobPayload } from '../types/domain';
 6: import { WorkerContext } from './context';
 7: import { ChallengeDetectedError } from './errors';
 8: import { isSalesNavigatorUrl, normalizeLinkedInUrl } from '../linkedinUrl';
 9: import { bridgeDailyStat, bridgeLeadStatus } from '../cloud/cloudBridge';
10: import { Page } from 'playwright';
11: 
12: function isFirstDegreeBadge(text: string | null): boolean {
13:     if (!text) return true;
14:     return /1st|1¬∞|1\b/i.test(text);
15: }
16: 
17: async function checkSentInvitations(page: Page, leadUrl: string): Promise<boolean> {
18:     await page.goto('https://www.linkedin.com/mynetwork/invitation-manager/sent/', { waitUntil: 'domcontentloaded' });
19:     await humanDelay(page, 2000, 3000);
20: 
21:     // Scroll multi-page to load recent sent invites
22:     for (let i = 0; i < 3; i++) {
23:         await page.evaluate(() => window.scrollTo(0, document.body.scrollHeight));
24:         await humanDelay(page, 1000, 2000);
25: 
26:         const showMoreBtn = page.locator(SELECTORS.showMoreButton).first();
27:         if (await showMoreBtn.isVisible().catch(() => false)) {
28:             await showMoreBtn.click().catch(() => null);
29:             await humanDelay(page, 1000, 2000);
30:         }
31:     }
32: 
33:     const sentLinks = await page.evaluate(() => {
34:         const links = Array.from(document.querySelectorAll('a[href*="/in/"]'));
35:         return links.map(a => a.getAttribute('href') || '');
36:     });
37: 
38:     const normalizedLeadUrl = normalizeLinkedInUrl(leadUrl);
39:     return sentLinks.some(href => normalizeLinkedInUrl(href) === normalizedLeadUrl);
40: }
41: 
42: export async function processAcceptanceJob(payload: AcceptanceJobPayload, context: WorkerContext): Promise<void> {
43:     const lead = await getLeadById(payload.leadId);
44:     if (!lead || lead.status !== 'INVITED') {
45:         return;
46:     }
47: 
48:     if (isSalesNavigatorUrl(lead.linkedin_url)) {
49:         await transitionLead(lead.id, 'BLOCKED', 'salesnav_url_requires_profile_check');
50:         return;
51:     }
52: 
53:     await context.session.page.goto(lead.linkedin_url, { waitUntil: 'domcontentloaded' });
54:     await humanDelay(context.session.page, 2000, 4000);
55: 
56:     if (await detectChallenge(context.session.page)) {
57:         throw new ChallengeDetectedError();
58:     }
59: 
60:     const pendingInvite = (await context.session.page.locator(SELECTORS.invitePendingIndicators).count()) > 0;
61:     const canConnect = (await context.session.page.locator(SELECTORS.connectButtonPrimary).count()) > 0;
62:     const badgeText = await context.session.page.locator(SELECTORS.distanceBadge).first().textContent().catch(() => '');
63:     const hasMessageButton = (await context.session.page.locator(SELECTORS.messageButton).count()) > 0;
64:     const connectedWithoutBadge = !pendingInvite && !canConnect && hasMessageButton;
65: 
66:     let accepted = false;
67: 
68:     if (isFirstDegreeBadge(badgeText)) {
69:         accepted = true;
70:     } else if (pendingInvite) {
71:         accepted = false;
72:     } else if (canConnect) {
73:         // Invite withdrawn or rejected
74:         accepted = false;
75:     } else if (connectedWithoutBadge) {
76:         // Lagged UI: Has Message button but no 1st badge, and no Pending/Connect.
77:         // Check Sent Invitations as the absolute Source of Truth
78:         const isStillPendingInManager = await checkSentInvitations(context.session.page, lead.linkedin_url);
79:         if (!isStillPendingInManager) {
80:             accepted = true;
81:         }
82:     }
83: 
84:     if (!accepted) {
85:         return;
86:     }
87: 
88:     await transitionLead(lead.id, 'ACCEPTED', 'acceptance_detected');
89:     await transitionLead(lead.id, 'READY_MESSAGE', 'message_queue_ready');
90:     await incrementDailyStat(context.localDate, 'acceptances');
91:     // Cloud sync non-bloccante
92:     bridgeLeadStatus(lead.linkedin_url, 'ACCEPTED', { accepted_at: new Date().toISOString() });
93:     bridgeDailyStat(context.localDate, context.accountId, 'acceptances');
94: }
````

## File: src/workers/messageWorker.ts
````typescript
 1: import { detectChallenge, humanDelay, humanMouseMove, humanType, simulateHumanReading } from '../browser';
 2: import { transitionLead } from '../core/leadStateService';
 3: import { countRecentMessageHash, getLeadById, incrementDailyStat, incrementListDailyStat, storeMessageHash } from '../core/repositories';
 4: import { SELECTORS } from '../selectors';
 5: import { MessageJobPayload } from '../types/domain';
 6: import { hashMessage, validateMessageContent } from '../validation/messageValidator';
 7: import { WorkerContext } from './context';
 8: import { ChallengeDetectedError, RetryableWorkerError } from './errors';
 9: import { isSalesNavigatorUrl } from '../linkedinUrl';
10: import { buildPersonalizedFollowUpMessage } from '../ai/messagePersonalizer';
11: import { logInfo } from '../telemetry/logger';
12: import { bridgeDailyStat, bridgeLeadStatus } from '../cloud/cloudBridge';
13: 
14: export async function processMessageJob(payload: MessageJobPayload, context: WorkerContext): Promise<void> {
15:     const lead = await getLeadById(payload.leadId);
16:     if (!lead || lead.status !== 'READY_MESSAGE') {
17:         return;
18:     }
19: 
20:     if (isSalesNavigatorUrl(lead.linkedin_url)) {
21:         await transitionLead(lead.id, 'BLOCKED', 'salesnav_url_requires_profile_message');
22:         return;
23:     }
24: 
25:     const personalized = await buildPersonalizedFollowUpMessage(lead);
26:     const message = personalized.message;
27:     const messageHash = hashMessage(message);
28:     const duplicateCount = await countRecentMessageHash(messageHash, 24);
29:     const validation = validateMessageContent(message, { duplicateCountLast24h: duplicateCount });
30:     if (!validation.valid) {
31:         await transitionLead(lead.id, 'BLOCKED', 'message_validation_failed', {
32:             reasons: validation.reasons,
33:         });
34:         return;
35:     }
36: 
37:     await context.session.page.goto(lead.linkedin_url, { waitUntil: 'domcontentloaded' });
38:     await humanDelay(context.session.page, 2500, 5000);
39:     await simulateHumanReading(context.session.page);
40: 
41:     if (await detectChallenge(context.session.page)) {
42:         throw new ChallengeDetectedError();
43:     }
44: 
45:     const msgBtn = context.session.page.locator(SELECTORS.messageButton).first();
46:     if (await msgBtn.count() === 0) {
47:         throw new RetryableWorkerError('Bottone messaggio non trovato', 'MESSAGE_BUTTON_NOT_FOUND');
48:     }
49: 
50:     await humanMouseMove(context.session.page, SELECTORS.messageButton);
51:     await humanDelay(context.session.page, 120, 320);
52:     await msgBtn.click();
53:     await humanDelay(context.session.page, 1200, 2200);
54: 
55:     const textbox = context.session.page.locator(SELECTORS.messageTextbox).first();
56:     if (await textbox.count() === 0) {
57:         await incrementDailyStat(context.localDate, 'selector_failures');
58:         throw new RetryableWorkerError('Textbox messaggio non trovata', 'TEXTBOX_NOT_FOUND');
59:     }
60:     await humanType(context.session.page, SELECTORS.messageTextbox, message);
61:     await humanDelay(context.session.page, 800, 1600);
62: 
63:     if (!context.dryRun) {
64:         const sendBtn = context.session.page.locator(SELECTORS.messageSendButton).first();
65:         if (await sendBtn.count() === 0 || (await sendBtn.isDisabled())) {
66:             await incrementDailyStat(context.localDate, 'selector_failures');
67:             throw new RetryableWorkerError('Bottone invio non disponibile', 'SEND_NOT_AVAILABLE');
68:         }
69:         await humanMouseMove(context.session.page, SELECTORS.messageSendButton);
70:         await humanDelay(context.session.page, 100, 300);
71:         await sendBtn.click();
72:     }
73: 
74:     await transitionLead(lead.id, 'MESSAGED', context.dryRun ? 'message_dry_run' : 'message_sent');
75:     await logInfo('message.generated', {
76:         leadId: lead.id,
77:         source: personalized.source,
78:         model: personalized.model,
79:         messageLength: message.length,
80:     });
81:     await storeMessageHash(lead.id, messageHash);
82:     await incrementDailyStat(context.localDate, 'messages_sent');
83:     await incrementListDailyStat(context.localDate, lead.list_name, 'messages_sent');
84:     // Cloud sync non-bloccante
85:     bridgeLeadStatus(lead.linkedin_url, 'MESSAGED', { messaged_at: new Date().toISOString() });
86:     bridgeDailyStat(context.localDate, context.accountId, 'messages_sent');
87: }
````

## File: package.json
````json
 1: {
 2:   "name": "linkedin",
 3:   "version": "1.0.0",
 4:   "description": "",
 5:   "main": "index.js",
 6:   "scripts": {
 7:     "build": "tsc",
 8:     "lint": "eslint src/**/*.ts",
 9:     "typecheck": "tsc --noEmit",
10:     "conta-problemi": "npm run typecheck && npm run lint",
11:     "pre-modifiche": "npm run conta-problemi",
12:     "post-modifiche": "npm run conta-problemi",
13:     "helper-manuali": "echo 'Esegui le correzioni manuali come da policy'",
14:     "start": "ts-node src/index.ts",
15:     "daemon:start": "pm2 start ecosystem.config.cjs --interpreter ./node_modules/.bin/ts-node",
16:     "daemon:stop": "pm2 stop linkedin-bot-daemon",
17:     "daemon:logs": "pm2 logs linkedin-bot-daemon",
18:     "daemon:status": "pm2 status",
19:     "dashboard": "ts-node src/index.ts dashboard",
20:     "kpi": "ts-node src/index.ts kpi",
21:     "ramp-up": "ts-node src/scripts/rampUp.ts",
22:     "db:backup": "ts-node src/index.ts db-backup",
23:     "test:unit": "ts-node src/tests/unit.ts",
24:     "test:integration": "ts-node src/tests/integration.ts",
25:     "test:e2e:dry": "ts-node src/tests/e2eDry.ts",
26:     "test": "npm run test:unit && npm run test:integration && npm run test:e2e:dry"
27:   },
28:   "keywords": [],
29:   "author": "",
30:   "license": "ISC",
31:   "type": "commonjs",
32:   "dependencies": {
33:     "@supabase/supabase-js": "^2.97.0",
34:     "cors": "^2.8.6",
35:     "csv-parser": "^3.2.0",
36:     "dotenv": "^17.3.1",
37:     "express": "^5.2.1",
38:     "playwright": "^1.58.2",
39:     "sqlite": "^5.1.1",
40:     "sqlite3": "^5.1.7"
41:   },
42:   "devDependencies": {
43:     "@types/cors": "^2.8.19",
44:     "@types/express": "^5.0.6",
45:     "@types/node": "^25.3.0",
46:     "@types/sqlite3": "^3.1.11",
47:     "@typescript-eslint/eslint-plugin": "^8.56.1",
48:     "@typescript-eslint/parser": "^8.56.1",
49:     "eslint": "^10.0.2",
50:     "pm2": "^6.0.14",
51:     "ts-node": "^10.9.2",
52:     "typescript": "^5.9.3"
53:   }
54: }
````

## File: ROADMAP.md
````markdown
 1: # LinkedIn Bot Roadmap
 2: 
 3: ## Objective
 4: 
 5: Build a safer, more reliable, and measurable end-to-end automation flow, continuously enhancing capabilities and operational independence.
 6: 
 7: ## Status Legend
 8: 
 9: - `todo`: not started
10: - `in_progress`: currently being implemented
11: - `done`: completed and verified
12: - `blocked`: waiting on external input/decision
13: 
14: ## Owners
15: 
16: - `YOU`: business decisions, account operation, approvals
17: - `AI`: implementation in codebase
18: - `JOINT`: requires both
19: 
20: ## Phase 4: Long-Term Enhancements (Active)
21: 
22: | ID | Priority | Area | Task | Owner | Status | Dependencies |
23: |---|---|---|---|---|---|---|
24: | P4-01 | P1 | Runtime | **Daemon Mode**: Implement background service mode (PM2) | AI | done | Nessuna |
25: | P4-02 | P1 | Messaging | **A/B Testing Engine**: Aggiungere metriche e routing dinamico (A/B) sui messaggi e note | AI | done | Nessuna |
26: | P4-03 | P2 | UI/UX | **Dashboard Phase 2**: Visualizzazione risultati A/B Test su PM2 proxy | AI | done | P4-01, P4-02 |
27: | P2-09 | P2 | Intelligence | Monthly review of official + community signals | JOINT | todo | Nessuna |
28: 
29: ---
30: 
31: ## Completati / Archivio
32: 
33: <details>
34: <summary>Vedi i task storici completati (P0, P1, P2, P3)</summary>
35: 
36: ### P0: Security & Runtime Safety
37: 
38: - `P0-01` Rotate SUPABASE_SERVICE_ROLE_KEY (done)
39: - `P0-02` Verify no secrets in logs (done)
40: - `P0-03` Confirm private permissions on DB/session (done)
41: - `P0-04` Add global single-runner lock (done)
42: - `P0-05` Add lock heartbeat and recovery (done)
43: - `P0-06` Run doctor before cycle (done)
44: - `P0-07` Implement adaptive caps (done)
45: - `P0-08` Implement auto cooldown engine (done)
46: - `P0-09` Enforce no-burst pacing (done)
47: - `P0-10` Add session/IP/device consistency guard (done)
48: - `P0-11` Add Dashboard/API auth guard (done)
49: - `P0-12` Add doctor compliance gate for conservative limits (done)
50: - `P0-13` Disable profile context scraping by default via config flag (done)
51: - `P0-14` Extend privacy retention cleanup and default 90 days (done)
52: - `P0-15` Apply Supabase MCP hardening migration (RLS + FK indexes + function search_path fix) (done)
53: 
54: ### P1: Workflow, Control Plane & AI
55: 
56: - `P1-01` Schedule daily site-check from autopilot (done)
57: - `P1-02` Improve reconciliation rules (done)
58: - `P1-03` Add REVIEW_REQUIRED lead state (done)
59: - `P1-04` Add pending invite hygiene policy (done)
60: - `P1-05` Upgrade Supabase to control-plane (done)
61: - `P1-06` Implement bidirectional sync (done)
62: - `P1-07` Add dashboard KPIs (done)
63: - `P1-08` Add lead scoring (done)
64: - `P1-09` Add confidence score + review queue (done)
65: - `P1-10` Add semantic similarity checks (done)
66: - `P1-11` Add selectable event-sync sink (done)
67: - `P1-12` Add automatic post-run state sync (done)
68: - `P1-13` Add AI message personalization (done)
69: - `P1-14` Add optional AI guardian (done)
70: 
71: ### P2 e P3: Testing, Rollout & Web UI
72: 
73: - `P2-01` Add campaign_runs table (done)
74: - `P2-02` Expand alerting (done)
75: - `P2-03` Create incident runbook (done)
76: - `P2-04` Add automated daily summary report (done)
77: - `P2-05` Add tests for lock/cooldown (done)
78: - `P2-06` Run realistic e2e scenarios (done)
79: - `P2-07` Canary rollout on one list (done)
80: - `P2-08` Controlled ramp-up policy script (done)
81: - `P3-01` API Server (done)
82: - `P3-02` Web UI / Local Dashboard (done)
83: - `P3-03` Web Kill-Switch (done)
84: 
85: </details>
````

## File: src/proxyManager.ts
````typescript
  1: import fs from 'fs';
  2: import path from 'path';
  3: import * as net from 'net';
  4: import { config } from './config';
  5: import { logInfo, logWarn } from './telemetry/logger';
  6: 
  7: export interface ProxyConfig {
  8:     server: string;
  9:     username?: string;
 10:     password?: string;
 11: }
 12: 
 13: interface ProxyPoolCache {
 14:     proxies: ProxyConfig[];
 15:     signature: string;
 16: }
 17: 
 18: export interface ProxyPoolStatus {
 19:     configured: boolean;
 20:     total: number;
 21:     ready: number;
 22:     cooling: number;
 23:     rotationCursor: number;
 24: }
 25: 
 26: const proxyFailureUntil = new Map<string, number>();
 27: const stickyProxySessions = new Map<string, ProxyConfig>();
 28: let rotationCursor = 0;
 29: let cachedPool: ProxyPoolCache = { proxies: [], signature: '' };
 30: 
 31: function normalizeProxyServer(value: string): string {
 32:     const trimmed = value.trim();
 33:     if (!trimmed) return '';
 34:     if (/^[a-zA-Z][a-zA-Z\d+.-]*:\/\//.test(trimmed)) {
 35:         return trimmed;
 36:     }
 37:     return `http://${trimmed}`;
 38: }
 39: 
 40: function isLikelyHostPortUserPass(value: string): boolean {
 41:     if (value.includes('://')) return false;
 42:     const parts = value.split(':');
 43:     return parts.length === 4 && !parts[0].includes('/') && !parts[1].includes('/');
 44: }
 45: 
 46: // Funzione Helper esportabile per parsare ProxyConfig raw
 47: export function parseProxyEntry(rawValue: string): ProxyConfig | null {
 48:     const raw = rawValue.trim();
 49:     if (!raw || raw.startsWith('#')) return null;
 50: 
 51:     if (isLikelyHostPortUserPass(raw)) {
 52:         const [host, port, username, password] = raw.split(':');
 53:         return {
 54:             server: `http://${host}:${port}`,
 55:             username: username || undefined,
 56:             password: password || undefined,
 57:         };
 58:     }
 59: 
 60:     const normalized = normalizeProxyServer(raw);
 61:     try {
 62:         const parsed = new URL(normalized);
 63:         const username = parsed.username ? decodeURIComponent(parsed.username) : undefined;
 64:         const password = parsed.password ? decodeURIComponent(parsed.password) : undefined;
 65:         return {
 66:             server: `${parsed.protocol}//${parsed.host}`,
 67:             username,
 68:             password,
 69:         };
 70:     } catch {
 71:         return null;
 72:     }
 73: }
 74: 
 75: function applyGlobalCredentials(proxy: ProxyConfig): ProxyConfig {
 76:     const username = proxy.username ?? config.proxyUsername;
 77:     const password = proxy.password ?? config.proxyPassword;
 78:     return {
 79:         server: proxy.server,
 80:         username: username || undefined,
 81:         password: password || undefined,
 82:     };
 83: }
 84: 
 85: function proxyKey(proxy: ProxyConfig): string {
 86:     return [proxy.server, proxy.username ?? '', proxy.password ?? ''].join('|');
 87: }
 88: 
 89: function signatureForPool(proxyListPath: string | null, proxyUrl: string): string {
 90:     if (proxyListPath) {
 91:         try {
 92:             const stats = fs.statSync(proxyListPath);
 93:             return `${proxyListPath}:${stats.mtimeMs}:${stats.size}`;
 94:         } catch {
 95:             return `${proxyListPath}:missing`;
 96:         }
 97:     }
 98:     return `single:${proxyUrl}:${config.proxyUsername}:${config.proxyPassword}`;
 99: }
100: 
101: function loadProxiesFromList(proxyListPath: string): ProxyConfig[] {
102:     let content = '';
103:     try {
104:         content = fs.readFileSync(proxyListPath, 'utf8');
105:     } catch {
106:         return [];
107:     }
108: 
109:     const lines = content.split(/\r?\n/);
110:     const proxies: ProxyConfig[] = [];
111:     const seen = new Set<string>();
112:     for (const line of lines) {
113:         const parsed = parseProxyEntry(line);
114:         if (!parsed) continue;
115:         const normalized = applyGlobalCredentials(parsed);
116:         const key = proxyKey(normalized);
117:         if (seen.has(key)) continue;
118:         seen.add(key);
119:         proxies.push(normalized);
120:     }
121:     return proxies;
122: }
123: 
124: function resolveProxyListPath(): string | null {
125:     if (!config.proxyListPath) return null;
126:     const raw = config.proxyListPath.trim();
127:     if (!raw) return null;
128:     return path.isAbsolute(raw) ? raw : path.resolve(process.cwd(), raw);
129: }
130: 
131: function loadProxyPool(): ProxyConfig[] {
132:     const proxyListPath = resolveProxyListPath();
133:     const signature = signatureForPool(proxyListPath, config.proxyUrl);
134:     if (cachedPool.signature === signature) {
135:         return cachedPool.proxies;
136:     }
137: 
138:     let proxies: ProxyConfig[] = [];
139:     if (proxyListPath) {
140:         proxies = loadProxiesFromList(proxyListPath);
141:     } else if (config.proxyUrl) {
142:         const parsed = parseProxyEntry(config.proxyUrl);
143:         if (parsed) {
144:             proxies = [applyGlobalCredentials(parsed)];
145:         }
146:     }
147: 
148:     cachedPool = {
149:         proxies,
150:         signature,
151:     };
152:     if (rotationCursor >= proxies.length) {
153:         rotationCursor = 0;
154:     }
155:     return proxies;
156: }
157: 
158: function orderByRotation(pool: ProxyConfig[]): ProxyConfig[] {
159:     if (pool.length <= 1) {
160:         return pool.slice();
161:     }
162: 
163:     const start = rotationCursor % pool.length;
164:     rotationCursor = (start + 1) % pool.length;
165: 
166:     const ordered: ProxyConfig[] = [];
167:     for (let i = 0; i < pool.length; i++) {
168:         ordered.push(pool[(start + i) % pool.length]);
169:     }
170:     return ordered;
171: }
172: 
173: function splitByCooldown(orderedPool: ProxyConfig[]): { ready: ProxyConfig[]; cooling: ProxyConfig[] } {
174:     const now = Date.now();
175:     const ready: ProxyConfig[] = [];
176:     const cooling: ProxyConfig[] = [];
177: 
178:     for (const proxy of orderedPool) {
179:         const cooldownUntil = proxyFailureUntil.get(proxyKey(proxy)) ?? 0;
180:         if (cooldownUntil > now) {
181:             cooling.push(proxy);
182:         } else {
183:             ready.push(proxy);
184:         }
185:     }
186: 
187:     return { ready, cooling };
188: }
189: 
190: /**
191:  * Contatta API Esterna Provider (BrightData, Oxylabs, JSON-Server) per
192:  * richiedere urgentemente un nuovo indirizzo Proxy IP rotazionale
193:  * quando il pool √® interamente bruciato o sotto 429.
194:  */
195: export async function fetchFallbackProxyFromProvider(): Promise<boolean> {
196:     if (!config.proxyProviderApiEndpoint) return false;
197: 
198:     console.log(`[PROXY] Fetching proxy d'emergenza da: ${config.proxyProviderApiEndpoint}`);
199:     try {
200:         const headers: Record<string, string> = { 'Accept': 'application/json' };
201:         if (config.proxyProviderApiKey) {
202:             headers['Authorization'] = `Bearer ${config.proxyProviderApiKey}`;
203:         }
204: 
205:         const response = await fetch(config.proxyProviderApiEndpoint, { headers, method: 'GET' });
206:         if (!response.ok) {
207:             throw new Error(`Proxy Provider HTTP ${response.status}`);
208:         }
209: 
210:         // Esempi previsti di output dal provider:
211:         // { "proxy": "http://user:pass@host:port" } 
212:         // { "ip": "1.2.3.4", "port": "8080" ... }
213:         const json = await response.json();
214: 
215:         let newProxyRaw = '';
216:         if (json.proxy && typeof json.proxy === 'string') {
217:             newProxyRaw = json.proxy;
218:         } else if (json.ip && json.port) {
219:             const auth = json.username ? `${json.username}:${json.password}@` : '';
220:             newProxyRaw = `http://${auth}${json.ip}:${json.port}`;
221:         } else {
222:             console.warn(`[PROXY] Payload API sconosciuto:`, json);
223:             return false;
224:         }
225: 
226:         const parsed = parseProxyEntry(newProxyRaw);
227:         if (parsed) {
228:             const finalProxy = applyGlobalCredentials(parsed);
229: 
230:             // Unshift nel Pool in Memoria
231:             cachedPool.proxies.unshift(finalProxy);
232:             // Forza invalidazione timestamp su signature esistente localmente per precludere ri-load dal file
233:             cachedPool.signature = `api-injected:${Date.now()}`;
234: 
235:             // Cancella eventuali penalty per questo preciso nuovo proxy
236:             markProxyHealthy(finalProxy);
237:             await logInfo('proxy.api.fallback_success', { newServer: finalProxy.server });
238:             return true;
239:         }
240:         return false;
241:     } catch (e) {
242:         await logWarn('proxy.api.fallback_failed', { error: e instanceof Error ? e.message : String(e) });
243:         return false;
244:     }
245: }
246: 
247: /**
248:  * Restituisce una chain di proxy ordinata:
249:  * - round-robin sul pool
250:  * - prima i proxy non in cooldown
251:  * - poi eventuali proxy in cooldown (fallback estremo)
252:  */
253: export async function getProxyFailoverChainAsync(): Promise<ProxyConfig[]> {
254:     const pool = loadProxyPool();
255:     if (pool.length === 0) return [];
256: 
257:     const rotated = orderByRotation(pool);
258:     const { ready, cooling } = splitByCooldown(rotated);
259:     if (ready.length > 0) {
260:         return ready.concat(cooling);
261:     }
262: 
263:     // Tutti in cooldown? Scalo il provider esterno se configurato.
264:     if (config.proxyProviderApiEndpoint) {
265:         const injected = await fetchFallbackProxyFromProvider();
266:         if (injected) {
267:             // Reinvochiamo noi stessi per prendere il top della catena che ora √® fresco
268:             const refreshedPool = loadProxyPool();
269:             const reSplit = splitByCooldown(refreshedPool);
270:             return reSplit.ready.concat(reSplit.cooling);
271:         }
272:     }
273: 
274:     return rotated;
275: }
276: 
277: /**
278:  * Retrocompatibilit√† sincrona. Senza API Provider.
279:  */
280: export function getProxyFailoverChain(): ProxyConfig[] {
281:     const pool = loadProxyPool();
282:     if (pool.length === 0) return [];
283: 
284:     const rotated = orderByRotation(pool);
285:     const { ready, cooling } = splitByCooldown(rotated);
286:     if (ready.length > 0) {
287:         return ready.concat(cooling);
288:     }
289:     return rotated;
290: }
291: 
292: /**
293:  * Retrocompatibilit√† sincrona: restituisce il primo proxy disponibile (non usa API Provider on-demand).
294:  */
295: export function getProxy(): ProxyConfig | undefined {
296:     const chain = getProxyFailoverChain();
297:     return chain[0];
298: }
299: 
300: /**
301:  * Esegue un ping TCP sulla porta del proxy per verificare se √® raggiungibile.
302:  */
303: export async function checkProxyHealth(proxy: ProxyConfig): Promise<boolean> {
304:     return new Promise((resolve) => {
305:         try {
306:             const url = new URL(proxy.server);
307:             const port = url.port ? parseInt(url.port, 10) : (url.protocol === 'https:' ? 443 : 80);
308: 
309:             const socket = new net.Socket();
310:             socket.setTimeout(config.proxyHealthCheckTimeoutMs ?? 5000);
311: 
312:             socket.on('connect', () => {
313:                 socket.end();
314:                 resolve(true);
315:             });
316: 
317:             socket.on('timeout', () => {
318:                 socket.destroy();
319:                 resolve(false);
320:             });
321: 
322:             socket.on('error', () => {
323:                 socket.destroy();
324:                 resolve(false);
325:             });
326: 
327:             socket.connect(port, url.hostname);
328:         } catch {
329:             resolve(false);
330:         }
331:     });
332: }
333: 
334: /**
335:  * Restituisce il primo proxy disponibile, interpellando l'API Provider se necessario, 
336:  * ed eseguendo anche un health check proattivo prima di restituirlo.
337:  */
338: export async function getProxyAsync(): Promise<ProxyConfig | undefined> {
339:     let chain = await getProxyFailoverChainAsync();
340: 
341:     for (const proxy of chain) {
342:         const isHealthy = await checkProxyHealth(proxy);
343:         if (isHealthy) {
344:             markProxyHealthy(proxy); // Resetta penalty su successo
345:             return proxy;
346:         } else {
347:             console.warn(`[PROXY] Health check fallito per proxy: ${proxy.server}`);
348:             markProxyFailed(proxy);
349:         }
350:     }
351: 
352:     // Se tutti i ping falliscono, ritentiamo caricando di nuovo la fallback logic,
353:     // oppure ritorniamo il primo (se non c'√® fallback)
354:     const refreshedChain = await getProxyFailoverChainAsync();
355:     return refreshedChain[0];
356: }
357: 
358: /**
359:  * Restituisce o alloca un proxy permanente per una specifica sessionId.
360:  * Assicura che la sessione usi costantemente lo stesso nodo per non allertare Linkedin con cambi IP anomali.
361:  */
362: export async function getStickyProxy(sessionId: string): Promise<ProxyConfig | undefined> {
363:     // 1. Check if we already have a sticky proxy for this session
364:     const existing = stickyProxySessions.get(sessionId);
365:     if (existing) {
366:         // Verifichiamo proattivamente anche il proxy sticky
367:         const isHealthy = await checkProxyHealth(existing);
368:         if (isHealthy) {
369:             return existing;
370:         } else {
371:             console.warn(`[PROXY] Sticky proxy ${existing.server} per sessione ${sessionId} fallito health check. Ne cerco uno nuovo.`);
372:             markProxyFailed(existing);
373:             stickyProxySessions.delete(sessionId);
374:         }
375:     }
376: 
377:     // 2. Otherwise allocate a new proxy from the best available chain
378:     const proxy = await getProxyAsync();
379:     if (proxy) {
380:         stickyProxySessions.set(sessionId, proxy);
381:     }
382:     return proxy;
383: }
384: 
385: export function releaseStickyProxy(sessionId: string): void {
386:     stickyProxySessions.delete(sessionId);
387: }
388: 
389: export function markProxyFailed(proxy: ProxyConfig): void {
390:     const cooldownMs = config.proxyFailureCooldownMinutes * 60_000;
391:     proxyFailureUntil.set(proxyKey(proxy), Date.now() + cooldownMs);
392: }
393: 
394: export function markProxyHealthy(proxy: ProxyConfig): void {
395:     proxyFailureUntil.delete(proxyKey(proxy));
396: }
397: 
398: export function getProxyPoolStatus(): ProxyPoolStatus {
399:     const pool = loadProxyPool();
400:     if (pool.length === 0) {
401:         return {
402:             configured: false,
403:             total: 0,
404:             ready: 0,
405:             cooling: 0,
406:             rotationCursor: 0,
407:         };
408:     }
409: 
410:     const now = Date.now();
411:     let ready = 0;
412:     let cooling = 0;
413:     for (const proxy of pool) {
414:         const cooldownUntil = proxyFailureUntil.get(proxyKey(proxy)) ?? 0;
415:         if (cooldownUntil > now) {
416:             cooling += 1;
417:         } else {
418:             ready += 1;
419:         }
420:     }
421: 
422:     return {
423:         configured: true,
424:         total: pool.length,
425:         ready,
426:         cooling,
427:         rotationCursor,
428:     };
429: }
````

## File: src/selectors.ts
````typescript
  1: /**
  2:  * Centralized selectors with progressive fallbacks.
  3:  */
  4: export const SELECTORS = {
  5:     globalNav: '.global-nav__me, [data-test-global-nav-me] button',
  6: 
  7:     connectButtonPrimary: [
  8:         'button.artdeco-button--primary:has-text("Connect")',
  9:         'button.artdeco-button--primary:has-text("Collegati")',
 10:     ].join(', '),
 11: 
 12:     moreActionsButton: [
 13:         'button[aria-label="More actions"]',
 14:         'button[aria-label="Altre azioni"]',
 15:         'button.artdeco-dropdown__trigger:has-text("More")',
 16:         'button.artdeco-dropdown__trigger:has-text("Altro")',
 17:     ].join(', '),
 18: 
 19:     connectInMoreMenu: [
 20:         'div.artdeco-dropdown__content-inner li button:has-text("Connect")',
 21:         'div.artdeco-dropdown__content-inner li button:has-text("Collegati")',
 22:     ].join(', '),
 23: 
 24:     sendWithoutNote: [
 25:         'button[aria-label="Send without a note"]',
 26:         'button[aria-label="Invia senza nota"]',
 27:     ].join(', '),
 28: 
 29:     sendFallback: [
 30:         'button.artdeco-button--primary:has-text("Send")',
 31:         'button.artdeco-button--primary:has-text("Invia")',
 32:     ].join(', '),
 33: 
 34:     invitePendingIndicators: [
 35:         'button:has-text("Pending")',
 36:         'button:has-text("In attesa")',
 37:         'button[aria-label*="Pending"]',
 38:     ].join(', '),
 39: 
 40:     messageButton: [
 41:         'button[aria-label^="Message"]',
 42:         'button[aria-label^="Invia messaggio"]',
 43:         'a.message-anywhere-button',
 44:     ].join(', '),
 45: 
 46:     distanceBadge: [
 47:         'span.dist-value',
 48:         'span[aria-hidden="true"]:has-text("1st")',
 49:         'span[aria-hidden="true"]:has-text("1¬∞")',
 50:     ].join(', '),
 51: 
 52:     messageTextbox: [
 53:         'div.msg-form__contenteditable[role="textbox"]',
 54:         'div[contenteditable="true"][role="textbox"]',
 55:     ].join(', '),
 56: 
 57:     messageSendButton: [
 58:         'button.msg-form__send-button',
 59:         'button:has-text("Send")',
 60:         'button:has-text("Invia")',
 61:     ].join(', '),
 62: 
 63:     challengeSignals: [
 64:         'input[name="captcha"]',
 65:         'iframe[src*="captcha"]',
 66:         'form[action*="checkpoint"]',
 67:         'h1:has-text("Security verification")',
 68:         'h1:has-text("Verifica")',
 69:         'div:has-text("temporarily blocked")',
 70:         'div:has-text("temporaneamente bloccato")',
 71:     ].join(', '),
 72: 
 73:     addNoteButton: [
 74:         'button[aria-label="Add a note"]',
 75:         'button[aria-label="Aggiungi una nota"]',
 76:         'button:has-text("Add a note")',
 77:         'button:has-text("Aggiungi una nota")',
 78:     ].join(', '),
 79: 
 80:     noteTextarea: [
 81:         'div[role="dialog"] textarea',
 82:         'div[role="dialog"] input[type="text"]',
 83:     ].join(', '),
 84: 
 85:     sendWithNote: [
 86:         'div[role="dialog"] button[aria-label="Send invitation"]',
 87:         'div[role="dialog"] button[aria-label="Invia invito"]',
 88:         'div[role="dialog"] button.artdeco-button--primary:has-text("Send")',
 89:         'div[role="dialog"] button.artdeco-button--primary:has-text("Invia")',
 90:     ].join(', '),
 91: 
 92:     inviteWeeklyLimitSignals: [
 93:         'div:has-text("weekly invitation limit")',
 94:         'span:has-text("weekly invitation limit")',
 95:         'div:has-text("limite settimanale")',
 96:         'span:has-text("limite settimanale")',
 97:     ].join(', '),
 98: 
 99:     aboutSection: [
100:         'section:has(#about) .display-flex',
101:         'div#about ~ div .display-flex',
102:         '.pv-shared-text-with-see-more'
103:     ].join(', '),
104: 
105:     experienceSection: [
106:         'section:has(#experience) ul.pvs-list',
107:         'div#experience ~ div ul.pvs-list'
108:     ].join(', '),
109: 
110:     showMoreButton: [
111:         'button:has-text("Show more")',
112:         'button:has-text("Mostra altro")',
113:         'button.scaffold-finite-scroll__load-button'
114:     ].join(', '),
115: };
````

## File: src/tests/integration.ts
````typescript
  1: import assert from 'assert';
  2: import fs from 'fs';
  3: import path from 'path';
  4: 
  5: async function run(): Promise<void> {
  6:     const testDbPath = path.resolve(process.cwd(), 'data', 'test_integration.sqlite');
  7:     if (fs.existsSync(testDbPath)) {
  8:         fs.unlinkSync(testDbPath);
  9:     }
 10: 
 11:     process.env.DB_PATH = testDbPath;
 12:     process.env.SUPABASE_SYNC_ENABLED = 'false';
 13:     process.env.SELECTOR_CANARY_ENABLED = 'false';
 14: 
 15:     const dbModule = await import('../db');
 16:     const repositories = await import('../core/repositories');
 17:     const stateService = await import('../core/leadStateService');
 18: 
 19:     await dbModule.initDatabase();
 20: 
 21:     const inserted = await repositories.addLead({
 22:         accountName: 'Rossi Srl',
 23:         firstName: 'Mario',
 24:         lastName: 'Rossi',
 25:         jobTitle: 'CEO',
 26:         website: 'https://example.com',
 27:         linkedinUrl: 'https://www.linkedin.com/in/mario-rossi-test/',
 28:         listName: 'test-list',
 29:     });
 30:     assert.equal(inserted, true);
 31: 
 32:     const syncedLeadInsert = await repositories.upsertSalesNavigatorLead({
 33:         accountName: 'Sales Co',
 34:         firstName: 'Luca',
 35:         lastName: 'Verdi',
 36:         jobTitle: 'Head of Sales',
 37:         website: '',
 38:         linkedinUrl: 'https://www.linkedin.com/in/luca-verdi-sync-test/',
 39:         listName: 'sales-list',
 40:     });
 41:     assert.equal(syncedLeadInsert.action, 'inserted');
 42: 
 43:     const syncedLeadUpdate = await repositories.upsertSalesNavigatorLead({
 44:         accountName: 'Sales Company Spa',
 45:         firstName: 'Luca',
 46:         lastName: 'Verdi',
 47:         jobTitle: 'VP Sales',
 48:         website: '',
 49:         linkedinUrl: 'https://www.linkedin.com/in/luca-verdi-sync-test/',
 50:         listName: 'sales-list-updated',
 51:     });
 52:     assert.equal(syncedLeadUpdate.action === 'updated' || syncedLeadUpdate.action === 'unchanged', true);
 53: 
 54:     const syncedLead = await repositories.getLeadByLinkedinUrl('https://www.linkedin.com/in/luca-verdi-sync-test/');
 55:     assert.ok(syncedLead);
 56:     if (!syncedLead) {
 57:         throw new Error('Lead sincronizzato non trovato');
 58:     }
 59:     assert.equal(syncedLead.list_name, 'sales-list-updated');
 60: 
 61:     const salesNavList = await repositories.upsertSalesNavList(
 62:         'sales-list-updated',
 63:         'https://www.linkedin.com/sales/lists/people/123456789/'
 64:     );
 65:     await repositories.linkLeadToSalesNavList(salesNavList.id, syncedLead.id);
 66:     const salesNavLists = await repositories.listSalesNavLists(10);
 67:     const linkedSalesList = salesNavLists.find((item) => item.id === salesNavList.id);
 68:     assert.ok(linkedSalesList);
 69:     assert.equal((linkedSalesList?.leads_count ?? 0) >= 1, true);
 70: 
 71:     const cpApplyCreate = await repositories.applyControlPlaneCampaignConfigs([
 72:         {
 73:             name: 'cp-alpha',
 74:             isActive: true,
 75:             priority: 5,
 76:             dailyInviteCap: 12,
 77:             dailyMessageCap: 18,
 78:         },
 79:         {
 80:             name: 'cp-paused',
 81:             isActive: false,
 82:             priority: 80,
 83:             dailyInviteCap: null,
 84:             dailyMessageCap: null,
 85:         },
 86:     ]);
 87:     assert.equal(cpApplyCreate.fetched, 2);
 88:     assert.equal(cpApplyCreate.created, 2);
 89:     assert.equal(cpApplyCreate.updated, 0);
 90: 
 91:     const cpApplyUpdate = await repositories.applyControlPlaneCampaignConfigs([
 92:         {
 93:             name: 'cp-alpha',
 94:             isActive: true,
 95:             priority: 2,
 96:             dailyInviteCap: 10,
 97:             dailyMessageCap: 14,
 98:         },
 99:         {
100:             name: 'cp-paused',
101:             isActive: false,
102:             priority: 80,
103:             dailyInviteCap: null,
104:             dailyMessageCap: null,
105:         },
106:     ]);
107:     assert.equal(cpApplyUpdate.fetched, 2);
108:     assert.equal(cpApplyUpdate.updated, 1);
109:     assert.equal(cpApplyUpdate.unchanged, 1);
110: 
111:     const listsAfterControlPlane = await repositories.listLeadCampaignConfigs(false);
112:     const cpAlpha = listsAfterControlPlane.find((item) => item.name === 'cp-alpha');
113:     const cpPaused = listsAfterControlPlane.find((item) => item.name === 'cp-paused');
114:     assert.ok(cpAlpha);
115:     assert.ok(cpPaused);
116:     assert.equal(cpAlpha?.source, 'control_plane');
117:     assert.equal(cpAlpha?.priority, 2);
118:     assert.equal(cpAlpha?.dailyInviteCap, 10);
119:     assert.equal(cpAlpha?.dailyMessageCap, 14);
120:     assert.equal(cpPaused?.source, 'control_plane');
121:     assert.equal(cpPaused?.isActive, false);
122: 
123:     await repositories.promoteNewLeadsToReadyInvite(10);
124:     const ready = await repositories.getLeadsByStatus('READY_INVITE', 10);
125:     assert.equal(ready.length >= 1, true);
126: 
127:     const lead = ready.find((row) => row.linkedin_url.includes('/in/mario-rossi-test/')) ?? ready[0];
128:     await stateService.transitionLead(lead.id, 'INVITED', 'integration_invite');
129:     const invited = await repositories.getLeadsByStatus('INVITED', 10);
130:     assert.equal(invited.length, 1);
131: 
132:     await stateService.reconcileLeadStatus(lead.id, 'READY_INVITE', 'integration_reconcile_back');
133:     const readyAgain = await repositories.getLeadsByStatus('READY_INVITE', 10);
134:     assert.equal(readyAgain.some((row) => row.id === lead.id), true);
135:     await stateService.transitionLead(lead.id, 'INVITED', 'integration_invite_again');
136: 
137:     const queued = await repositories.enqueueJob(
138:         'INVITE',
139:         { leadId: lead.id, localDate: '2026-02-24' },
140:         `invite:${lead.id}:2026-02-24`,
141:         10,
142:         3
143:     );
144:     assert.equal(queued, true);
145: 
146:     const locked = await repositories.lockNextQueuedJob(['INVITE']);
147:     assert.ok(locked);
148:     if (!locked) {
149:         throw new Error('Lock job fallito');
150:     }
151:     await repositories.markJobSucceeded(locked.id);
152: 
153:     const dailyInvites = await repositories.getDailyStat('2026-02-24', 'invites_sent');
154:     assert.equal(dailyInvites, 0);
155: 
156:     const lockA = await repositories.acquireRuntimeLock('integration.runner.lock', 'owner-a', 5, { source: 'integration' });
157:     assert.equal(lockA.acquired, true);
158: 
159:     const lockBBlocked = await repositories.acquireRuntimeLock('integration.runner.lock', 'owner-b', 5, { source: 'integration' });
160:     assert.equal(lockBBlocked.acquired, false);
161:     assert.equal(lockBBlocked.lock?.owner_id, 'owner-a');
162: 
163:     const heartbeatOk = await repositories.heartbeatRuntimeLock('integration.runner.lock', 'owner-a', 5);
164:     assert.equal(heartbeatOk, true);
165: 
166:     const releasedByWrongOwner = await repositories.releaseRuntimeLock('integration.runner.lock', 'owner-b');
167:     assert.equal(releasedByWrongOwner, false);
168: 
169:     const releasedByOwner = await repositories.releaseRuntimeLock('integration.runner.lock', 'owner-a');
170:     assert.equal(releasedByOwner, true);
171: 
172:     const staleLock = await repositories.acquireRuntimeLock('integration.stale.lock', 'owner-a', 1, { source: 'integration' });
173:     assert.equal(staleLock.acquired, true);
174:     await new Promise((resolve) => setTimeout(resolve, 2100));
175: 
176:     const staleTakeover = await repositories.acquireRuntimeLock('integration.stale.lock', 'owner-b', 5, { source: 'integration' });
177:     assert.equal(staleTakeover.acquired, true);
178:     assert.equal(staleTakeover.lock?.owner_id, 'owner-b');
179: 
180:     const delayedQueued = await repositories.enqueueJob(
181:         'INVITE',
182:         { leadId: lead.id, localDate: '2026-02-24' },
183:         `invite:${lead.id}:delayed`,
184:         10,
185:         3,
186:         60
187:     );
188:     assert.equal(delayedQueued, true);
189:     const delayedLocked = await repositories.lockNextQueuedJob(['INVITE']);
190:     assert.equal(delayedLocked, null);
191: 
192:     const accountQueuedA = await repositories.enqueueJob(
193:         'INVITE',
194:         { leadId: lead.id, localDate: '2026-02-25' },
195:         `invite:${lead.id}:account-a`,
196:         10,
197:         3,
198:         0,
199:         'acc-a'
200:     );
201:     assert.equal(accountQueuedA, true);
202: 
203:     const accountQueuedB = await repositories.enqueueJob(
204:         'MESSAGE',
205:         { leadId: lead.id, acceptedAtDate: '2026-02-25' },
206:         `message:${lead.id}:account-b`,
207:         10,
208:         3,
209:         0,
210:         'acc-b'
211:     );
212:     assert.equal(accountQueuedB, true);
213: 
214:     const lockedAccA = await repositories.lockNextQueuedJob(['INVITE', 'MESSAGE'], 'acc-a');
215:     assert.ok(lockedAccA);
216:     if (!lockedAccA) {
217:         throw new Error('Lock job acc-a fallito');
218:     }
219:     assert.equal(lockedAccA.account_id, 'acc-a');
220:     await repositories.markJobSucceeded(lockedAccA.id);
221: 
222:     const lockedAccB = await repositories.lockNextQueuedJob(['INVITE', 'MESSAGE'], 'acc-b');
223:     assert.ok(lockedAccB);
224:     if (!lockedAccB) {
225:         throw new Error('Lock job acc-b fallito');
226:     }
227:     assert.equal(lockedAccB.account_id, 'acc-b');
228:     await repositories.markJobSucceeded(lockedAccB.id);
229: 
230:     await dbModule.closeDatabase();
231:     if (fs.existsSync(testDbPath)) {
232:         fs.unlinkSync(testDbPath);
233:     }
234: }
235: 
236: run()
237:     .then(() => {
238:         console.log('Integration tests passed.');
239:     })
240:     .catch((error) => {
241:         console.error(error);
242:         process.exit(1);
243:     });
````

## File: src/types/domain.ts
````typescript
  1: export type LeadStatus =
  2:     | 'NEW'
  3:     | 'READY_INVITE'
  4:     | 'INVITED'
  5:     | 'ACCEPTED'
  6:     | 'READY_MESSAGE'
  7:     | 'MESSAGED'
  8:     | 'SKIPPED'
  9:     | 'BLOCKED'
 10:     | 'DEAD'
 11:     | 'REPLIED'
 12:     | 'CONNECTED'
 13:     | 'REVIEW_REQUIRED'
 14:     | 'WITHDRAWN'
 15:     | 'PENDING'; // compat legacy
 16: 
 17: export type JobType = 'INVITE' | 'ACCEPTANCE_CHECK' | 'MESSAGE' | 'HYGIENE';
 18: 
 19: export type JobStatus = 'QUEUED' | 'RUNNING' | 'SUCCEEDED' | 'FAILED' | 'DEAD_LETTER' | 'PAUSED';
 20: 
 21: export interface LeadRecord {
 22:     id: number;
 23:     account_name: string;
 24:     first_name: string;
 25:     last_name: string;
 26:     job_title: string;
 27:     website: string;
 28:     linkedin_url: string;
 29:     status: LeadStatus;
 30:     list_name: string;
 31:     invited_at: string | null;
 32:     accepted_at: string | null;
 33:     messaged_at: string | null;
 34:     last_site_check_at?: string | null;
 35:     last_error: string | null;
 36:     blocked_reason: string | null;
 37:     about: string | null;
 38:     experience: string | null;
 39:     invite_prompt_variant: string | null;
 40:     lead_score: number | null;
 41:     confidence_score: number | null;
 42:     created_at: string;
 43:     updated_at: string | null;
 44: }
 45: 
 46: export interface JobRecord {
 47:     id: number;
 48:     type: JobType;
 49:     status: JobStatus;
 50:     account_id: string;
 51:     payload_json: string;
 52:     idempotency_key: string;
 53:     priority: number;
 54:     attempts: number;
 55:     max_attempts: number;
 56:     next_run_at: string;
 57:     locked_at: string | null;
 58:     last_error: string | null;
 59:     created_at: string;
 60:     updated_at: string | null;
 61: }
 62: 
 63: export type RunStatus = 'RUNNING' | 'SUCCESS' | 'FAILED' | 'PAUSED';
 64: 
 65: export interface CampaignRunRecord {
 66:     id: number;
 67:     start_time: string;
 68:     end_time: string | null;
 69:     status: RunStatus;
 70:     profiles_discovered: number;
 71:     invites_sent: number;
 72:     messages_sent: number;
 73:     errors_count: number;
 74:     created_at: string;
 75: }
 76: 
 77: export interface InviteJobPayload {
 78:     leadId: number;
 79:     localDate: string;
 80: }
 81: 
 82: export interface AcceptanceJobPayload {
 83:     leadId: number;
 84: }
 85: 
 86: export interface MessageJobPayload {
 87:     leadId: number;
 88:     acceptedAtDate: string;
 89: }
 90: 
 91: export type JobPayload = InviteJobPayload | AcceptanceJobPayload | MessageJobPayload;
 92: 
 93: export interface RiskInputs {
 94:     pendingRatio: number;
 95:     errorRate: number;
 96:     selectorFailureRate: number;
 97:     challengeCount: number;
 98:     inviteVelocityRatio: number;
 99: }
100: 
101: export interface RiskSnapshot {
102:     score: number;
103:     pendingRatio: number;
104:     errorRate: number;
105:     selectorFailureRate: number;
106:     challengeCount: number;
107:     inviteVelocityRatio: number;
108:     action: 'NORMAL' | 'WARN' | 'STOP';
109: }
110: 
111: export interface IncidentRecord {
112:     id: number;
113:     type: string;
114:     severity: 'INFO' | 'WARN' | 'CRITICAL';
115:     status: 'OPEN' | 'ACK' | 'RESOLVED';
116:     details_json: string;
117:     opened_at: string;
118:     acknowledged_at: string | null;
119:     resolved_at: string | null;
120: }
121: 
122: export interface OutboxEventRecord {
123:     id: number;
124:     topic: string;
125:     payload_json: string;
126:     idempotency_key: string;
127:     attempts: number;
128:     next_retry_at: string;
129:     delivered_at: string | null;
130:     last_error: string | null;
131:     created_at: string;
132: }
133: 
134: export interface MessageValidationResult {
135:     valid: boolean;
136:     reasons: string[];
137: }
138: 
139: export interface ABTestStats {
140:     variant: string;
141:     totalSent: number;
142:     totalAccepted: number;
143:     totalReplied: number;
144:     acceptanceRate: number;
145:     replyRate: number;
146: }
````

## File: src/browser.ts
````typescript
  1: import { chromium, BrowserContext, Page } from 'playwright';
  2: import { config } from './config';
  3: import { ensureDirectoryPrivate } from './security/filesystem';
  4: import { SELECTORS } from './selectors';
  5: import { pauseAutomation } from './risk/incidentManager';
  6: import {
  7:     ProxyConfig,
  8:     getStickyProxy,
  9:     markProxyFailed,
 10:     markProxyHealthy,
 11:     releaseStickyProxy
 12: } from './proxyManager';
 13: 
 14: // ‚îÄ‚îÄ‚îÄ User-Agent pool (Chrome reali su Windows/macOS/Linux) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 15: const USER_AGENTS = [
 16:     'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36',
 17:     'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36',
 18:     'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36',
 19:     'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
 20:     'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36',
 21:     'Mozilla/5.0 (Windows NT 11.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36',
 22: ];
 23: 
 24: // ‚îÄ‚îÄ‚îÄ Viewport pool (risoluzioni comuni reali) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 25: const VIEWPORTS = [
 26:     { width: 1366, height: 768 },
 27:     { width: 1920, height: 1080 },
 28:     { width: 1440, height: 900 },
 29:     { width: 1536, height: 864 },
 30:     { width: 1280, height: 720 },
 31: ];
 32: 
 33: function randomElement<T>(arr: ReadonlyArray<T>): T {
 34:     return arr[Math.floor(Math.random() * arr.length)];
 35: }
 36: 
 37: export interface CloudFingerprint {
 38:     userAgent: string;
 39:     viewport?: { width: number; height: number };
 40: }
 41: 
 42: let cachedCloudFingerprints: CloudFingerprint[] | null = null;
 43: let lastFingerprintFetchTime = 0;
 44: 
 45: async function fetchCloudFingerprints(): Promise<CloudFingerprint[]> {
 46:     if (!config.fingerprintApiEndpoint) return [];
 47: 
 48:     // Cache di 10 minuti per evitare DDoS al provider
 49:     if (cachedCloudFingerprints && Date.now() - lastFingerprintFetchTime < 10 * 60 * 1000) {
 50:         return cachedCloudFingerprints;
 51:     }
 52: 
 53:     try {
 54:         const response = await fetch(config.fingerprintApiEndpoint, {
 55:             headers: { 'Accept': 'application/json' },
 56:             signal: AbortSignal.timeout(5000)
 57:         });
 58: 
 59:         if (response.ok) {
 60:             const data = await response.json() as CloudFingerprint[];
 61:             if (Array.isArray(data) && data.length > 0 && data[0].userAgent) {
 62:                 cachedCloudFingerprints = data;
 63:                 lastFingerprintFetchTime = Date.now();
 64:                 return data;
 65:             }
 66:         }
 67:     } catch {
 68:         // Silenzioso, passa al fallback locale
 69:     }
 70:     return [];
 71: }
 72: 
 73: export interface BrowserSession {
 74:     browser: BrowserContext;
 75:     page: Page;
 76: }
 77: 
 78: export interface LaunchBrowserOptions {
 79:     headless?: boolean;
 80:     proxy?: ProxyConfig;
 81:     sessionDir?: string;
 82: }
 83: 
 84: const STEALTH_INIT_SCRIPT = `
 85:     // 1. Defeat navigator.webdriver
 86:     Object.defineProperty(navigator, 'webdriver', { get: () => undefined });
 87:     
 88:     // 2. Mock hardwareConcurrency and deviceMemory
 89:     Object.defineProperty(navigator, 'hardwareConcurrency', { get: () => 8 });
 90:     Object.defineProperty(navigator, 'deviceMemory', { get: () => 8 });
 91:     
 92:     // 3. Mock plugins & mimeTypes
 93:     if (navigator.plugins.length === 0) {
 94:         Object.defineProperty(navigator, 'plugins', {
 95:             get: () => [
 96:                 { name: 'Chrome PDF Plugin', filename: 'internal-pdf-viewer', description: 'Portable Document Format' },
 97:                 { name: 'Chrome PDF Viewer', filename: 'mhjimiaplmpugondwaidnpafkincn', description: '' },
 98:                 { name: 'Native Client', filename: 'internal-nacl-plugin', description: '' }
 99:             ]
100:         });
101:     }
102: 
103:     // 4. Spoof WebGL Vendor/Renderer
104:     const getParameter = WebGLRenderingContext.prototype.getParameter;
105:     WebGLRenderingContext.prototype.getParameter = function(parameter) {
106:         if (parameter === 37445) return 'Google Inc. (Apple)'; // VENDOR (UNMASKED_VENDOR_WEBGL)
107:         if (parameter === 37446) return 'ANGLE (Apple, Apple M1 Pro, OpenGL 4.1)'; // RENDERER (UNMASKED_RENDERER_WEBGL)
108:         return getParameter.apply(this, arguments);
109:     };
110: 
111:     // 5. Canvas Fingerprint Noise
112:     const originalToDataURL = HTMLCanvasElement.prototype.toDataURL;
113:     HTMLCanvasElement.prototype.toDataURL = function() {
114:         const context = this.getContext('2d');
115:         if (context) {
116:             const width = this.width;
117:             const height = this.height;
118:             context.fillStyle = 'rgba(255,255,255,0.01)';
119:             context.fillText('stealth', Math.random() * width, Math.random() * height);
120:         }
121:         return originalToDataURL.apply(this, arguments);
122:     };
123:     
124:     const originalGetImageData = CanvasRenderingContext2D.prototype.getImageData;
125:     CanvasRenderingContext2D.prototype.getImageData = function() {
126:         const imageData = originalGetImageData.apply(this, arguments);
127:         for (let i = 0; i < imageData.data.length; i += 4) {
128:             imageData.data[i] = Math.max(0, Math.min(255, imageData.data[i] + (Math.random() * 2 - 1)));
129:         }
130:         return imageData;
131:     };
132: 
133:     // 6. AudioContext Fingerprint Noise
134:     const audioContextFunc = window.OfflineAudioContext || window.webkitOfflineAudioContext;
135:     if (audioContextFunc) {
136:         const originalGetChannelData = AudioBuffer.prototype.getChannelData;
137:         AudioBuffer.prototype.getChannelData = function() {
138:             const results = originalGetChannelData.apply(this, arguments);
139:             for (let i = 0; i < results.length; i += 100) {
140:                 results[i] = results[i] + (Math.random() * 0.0000001 - 0.00000005);
141:             }
142:             return results;
143:         };
144:     }
145: 
146:     // 7. WebRTC IP Leak Prevention (Fake RTCPeerConnection)
147:     if (window.RTCPeerConnection) {
148:         const OriginalRTCPeerConnection = window.RTCPeerConnection;
149:         window.RTCPeerConnection = function(...args) {
150:             const pc = new OriginalRTCPeerConnection(...args);
151:             pc.createDataChannel = () => ({ close: () => {} });
152:             pc.createOffer = () => Promise.resolve({ type: 'offer', sdp: '' });
153:             return pc;
154:         };
155:         window.RTCPeerConnection.prototype = OriginalRTCPeerConnection.prototype;
156:     }
157: 
158:     // 8. Delete Playwright CDP Traces (cdc_*)
159:     for (const key of Object.keys(window)) {
160:         if (key.match(/^cdc_[a-zA-Z0-9]+_/)) {
161:             try { delete window[key]; } catch {}
162:         }
163:     }
164: 
165:     // 9. Hardware & Sensor Mocks
166:     if (navigator.permissions && navigator.permissions.query) {
167:         const originalQuery = navigator.permissions.query.bind(navigator.permissions);
168:         navigator.permissions.query = (parameters) => {
169:             if (parameters.name === 'notifications') return Promise.resolve({ state: 'denied', onchange: null });
170:             if (parameters.name === 'geolocation') return Promise.resolve({ state: 'prompt', onchange: null });
171:             return originalQuery(parameters);
172:         };
173:     }
174:     Object.defineProperty(navigator, 'getBattery', { get: () => undefined });
175: `;
176: 
177: export async function launchBrowser(options: LaunchBrowserOptions = {}): Promise<BrowserSession> {
178:     const sessionDir = options.sessionDir ?? config.sessionDir;
179:     ensureDirectoryPrivate(sessionDir);
180: 
181:     const headless = options.headless ?? config.headless;
182: 
183:     // Check cooldown / proxy rotation
184:     const autoScaleProxy = config.multiAccountEnabled; // In multiaccount leghiamo proxy a sessionDir
185: 
186:     // Ottieni un proxy sano (magari pescando da Cloud Provider API async)
187:     const selectedProxy: ProxyConfig | undefined = autoScaleProxy
188:         ? await getStickyProxy(sessionDir)
189:         : options.proxy;
190: 
191:     const launchPlan: Array<ProxyConfig | undefined> = [selectedProxy];
192:     let lastError: unknown = null;
193: 
194:     for (let attempt = 0; attempt < launchPlan.length; attempt++) {
195:         const currentProxy = launchPlan[attempt];
196: 
197:         // Fingerprint Rotation Logic
198:         let userAgent = randomElement(USER_AGENTS);
199:         let viewport = randomElement(VIEWPORTS);
200: 
201:         const cloudFingerprints = await fetchCloudFingerprints();
202:         if (cloudFingerprints.length > 0) {
203:             const fp = randomElement(cloudFingerprints);
204:             userAgent = fp.userAgent;
205:             if (fp.viewport) {
206:                 viewport = fp.viewport;
207:             }
208:         }
209: 
210:         const contextOptions: Parameters<typeof chromium.launchPersistentContext>[1] = {
211:             headless,
212:             viewport,
213:             userAgent,
214:             locale: 'it-IT',
215:             timezoneId: config.timezone,
216:         };
217: 
218:         if (currentProxy) {
219:             contextOptions.proxy = {
220:                 server: currentProxy.server,
221:                 username: currentProxy.username,
222:                 password: currentProxy.password,
223:             };
224:         }
225: 
226:         try {
227:             const browser = await chromium.launchPersistentContext(sessionDir, contextOptions);
228:             await browser.addInitScript(STEALTH_INIT_SCRIPT);
229: 
230:             const existingPage = browser.pages()[0];
231:             const page = existingPage ?? await browser.newPage();
232: 
233:             // Global Kill-Switch 429 - Circuit Breaker
234:             page.on('response', async (response) => {
235:                 if (response.status() === 429) {
236:                     const url = response.url();
237:                     if (url.includes('linkedin.com/voyager')) {
238:                         console.error('\nüö® [GLOBAL KILL-SWITCH] Ricevuto HTTP 429 (Too Many Requests) da LinkedIn APIs:', url);
239:                         if (currentProxy) {
240:                             console.error(`üí• Uccisione forzata del Proxy bruciato: ${currentProxy.server}`);
241:                             markProxyFailed(currentProxy);
242:                             releaseStickyProxy(sessionDir);
243:                         }
244:                         await pauseAutomation('HTTP_429_RATE_LIMIT', { url }, config.autoPauseMinutesOnFailureBurst ?? 60).catch(() => { });
245:                     }
246:                 }
247:             });
248: 
249:             if (currentProxy) {
250:                 markProxyHealthy(currentProxy);
251:             }
252:             return { browser, page };
253:         } catch (error) {
254:             lastError = error;
255:             if (currentProxy) {
256:                 markProxyFailed(currentProxy);
257:                 if (attempt < launchPlan.length - 1) {
258:                     console.warn(
259:                         `[PROXY] Launch fallito su ${currentProxy.server}, provo il prossimo (${attempt + 2}/${launchPlan.length}).`
260:                     );
261:                 }
262:             }
263:         }
264:     }
265: 
266:     if (lastError instanceof Error) {
267:         throw lastError;
268:     }
269:     throw new Error('Impossibile avviare il browser context.');
270: }
271: 
272: export async function closeBrowser(session: BrowserSession): Promise<void> {
273:     await session.browser.close();
274: }
275: 
276: async function hasLinkedinAuthCookie(page: Page): Promise<boolean> {
277:     try {
278:         const cookies = await page.context().cookies('https://www.linkedin.com');
279:         return cookies.some((cookie) => cookie.name === 'li_at' && cookie.value.trim().length > 0);
280:     } catch {
281:         return false;
282:     }
283: }
284: 
285: export async function isLoggedIn(page: Page): Promise<boolean> {
286:     if (await hasLinkedinAuthCookie(page)) {
287:         return true;
288:     }
289: 
290:     const count = await page.locator(SELECTORS.globalNav).count();
291:     if (count > 0) {
292:         return true;
293:     }
294: 
295:     const currentUrl = page.url().toLowerCase();
296:     if (currentUrl.includes('/login') || currentUrl.includes('/checkpoint') || currentUrl.includes('/challenge')) {
297:         return false;
298:     }
299: 
300:     const loginForm = await page.locator('form[action*="login"], input[name="session_key"]').count();
301:     return loginForm === 0;
302: }
303: 
304: export async function checkLogin(page: Page): Promise<boolean> {
305:     await page.goto('https://www.linkedin.com/', { waitUntil: 'load' });
306:     await humanDelay(page, 2000, 4000);
307:     return isLoggedIn(page);
308: }
309: 
310: export async function detectChallenge(page: Page): Promise<boolean> {
311:     const currentUrl = page.url().toLowerCase();
312:     const challengeInUrl = ['checkpoint', 'challenge', 'captcha', 'security-verification'].some((token) =>
313:         currentUrl.includes(token)
314:     );
315:     if (challengeInUrl) {
316:         return true;
317:     }
318: 
319:     const selectorMatches = await page.locator(SELECTORS.challengeSignals).count();
320:     if (selectorMatches > 0) {
321:         return true;
322:     }
323: 
324:     const pageText = (await page.textContent('body').catch(() => ''))?.toLowerCase() ?? '';
325:     if (!pageText) {
326:         return false;
327:     }
328:     return /temporarily blocked|temporaneamente bloccato|restricted your account|account limitato/.test(pageText);
329: }
330: 
331: // ‚îÄ‚îÄ‚îÄ Log-normale (Box-Muller) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
332: function randomLogNormal(mean: number, stdDev: number): number {
333:     let u = 0, v = 0;
334:     while (u === 0) u = Math.random();
335:     while (v === 0) v = Math.random();
336:     const z = Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
337:     const mu = Math.log(mean) - 0.5 * Math.log(1 + (stdDev / mean) ** 2);
338:     const sigma = Math.sqrt(Math.log(1 + (stdDev / mean) ** 2));
339:     return Math.exp(mu + sigma * z);
340: }
341: 
342: /**
343:  * Pausa con distribuzione log-normale asimmetrica (Cronometria Disfasica):
344:  * Modella il timing umano con picchi veloci e occasionali distrazioni (long-tail).
345:  */
346: export async function humanDelay(page: Page, min: number = 1500, max: number = 3500): Promise<void> {
347:     const mean = min + (max - min) * 0.35; // Asimmetria: centro spostato verso il basso
348:     const std = (max - min) / 3;
349:     const raw = randomLogNormal(mean, std);
350:     const asymmetricDelay = Math.random() < 0.15 ? raw * (1.5 + Math.random()) : raw; // 15% di probabilit√† di coda lunga 
351:     const delay = Math.round(Math.max(min, Math.min(max * 2.5, asymmetricDelay)));
352:     await page.waitForTimeout(delay);
353: }
354: 
355: /**
356:  * Simula movimenti del mouse con traiettoria curva in 3 tappe prima di
357:  * arrivare sull'elemento target. Riduce il pattern "click istantaneo".
358:  */
359: export async function humanMouseMove(page: Page, targetSelector: string): Promise<void> {
360:     try {
361:         const box = await page.locator(targetSelector).first().boundingBox();
362:         if (!box) return;
363: 
364:         const startX = 100 + Math.random() * 300;
365:         const startY = 100 + Math.random() * 200;
366:         await page.mouse.move(startX, startY, { steps: 10 });
367:         await page.waitForTimeout(40 + Math.random() * 80);
368: 
369:         // Tappa intermedia con offset casuale e inversione di curva naturale
370:         const curveFactor = Math.random() < 0.5 ? 1 : -1;
371:         const midX = startX + (box.x - startX) * 0.4 + (Math.random() * 40 * curveFactor);
372:         const midY = startY + (box.y - startY) * 0.6 + (Math.random() * 40 * -curveFactor);
373:         await page.mouse.move(midX, midY, { steps: Math.floor(6 + Math.random() * 5) });
374:         await page.waitForTimeout(20 + Math.random() * 40);
375: 
376:         // Target finale (centro dell'elemento con micro-offset)
377:         const finalX = box.x + box.width / 2 + (Math.random() * 8 - 4);
378:         const finalY = box.y + box.height / 2 + (Math.random() * 8 - 4);
379: 
380:         // Jitter Overshoot: supera il target in base al vettore dir e torna indietro
381:         if (Math.random() < 0.32) {
382:             const dirX = finalX - startX;
383:             const dirY = finalY - startY;
384:             const length = Math.sqrt(dirX * dirX + dirY * dirY) || 1;
385:             const overExt = 0.05 + Math.random() * 0.12; // 5-17% overshoot
386: 
387:             const overshootX = finalX + (dirX / length) * (length * overExt);
388:             const overshootY = finalY + (dirY / length) * (length * overExt);
389: 
390:             await page.mouse.move(overshootX, overshootY, { steps: Math.floor(4 + Math.random() * 4) });
391:             await page.waitForTimeout(30 + Math.random() * 60); // Realizzazione di aver superato il taget
392: 
393:             // Correzione micro verso il target effettivo
394:             await page.mouse.move(finalX, finalY, { steps: Math.floor(5 + Math.random() * 5) });
395:         } else {
396:             await page.mouse.move(finalX, finalY, { steps: Math.floor(8 + Math.random() * 6) });
397:         }
398:     } catch {
399:         // Se l'elemento non √® visibile, ignora silenziosamente
400:     }
401: }
402: 
403: /**
404:  * Movimento cursor casuale non legato a click, utile per spezzare pattern
405:  * durante pause lunghe tra job.
406:  */
407: export async function randomMouseMove(page: Page): Promise<void> {
408:     try {
409:         const viewport = page.viewportSize() ?? { width: 1280, height: 800 };
410:         const startX = Math.random() * viewport.width;
411:         const startY = Math.random() * viewport.height;
412:         const endX = Math.random() * viewport.width;
413:         const endY = Math.random() * viewport.height;
414: 
415:         await page.mouse.move(startX, startY, { steps: 6 });
416:         await page.waitForTimeout(30 + Math.random() * 80);
417: 
418:         const midX = startX + (endX - startX) * 0.5 + (Math.random() * 20 - 10);
419:         const midY = startY + (endY - startY) * 0.5 + (Math.random() * 20 - 10);
420:         await page.mouse.move(midX, midY, { steps: 5 });
421:         await page.waitForTimeout(20 + Math.random() * 60);
422:         if (Math.random() < 0.14) {
423:             const overshootX = endX + (Math.random() * 24 - 12);
424:             const overshootY = endY + (Math.random() * 18 - 9);
425:             await page.mouse.move(overshootX, overshootY, { steps: 6 });
426:             await page.waitForTimeout(20 + Math.random() * 60);
427:         }
428:         await page.mouse.move(endX, endY, { steps: 8 });
429:     } catch {
430:         // Non bloccante: se il mouse move fallisce, continua.
431:     }
432: }
433: 
434: /**
435:  * Digita il testo carattere per carattere con delay variabile.
436:  * Include il 3% di probabilit√† di errore di battitura + correzione (Backspace),
437:  * simulando il comportamento di un utente reale.
438:  */
439: export async function humanType(page: Page, selector: string, text: string): Promise<void> {
440:     const element = page.locator(selector).first();
441:     await element.click();
442:     await humanDelay(page, 200, 500);
443: 
444:     for (let i = 0; i < text.length; i++) {
445:         // 3% di probabilit√† di digita-sbaglio ‚Üí correzione
446:         if (Math.random() < 0.03 && text.length > 3) {
447:             const wrongChar = String.fromCharCode(97 + Math.floor(Math.random() * 26));
448:             await element.pressSequentially(wrongChar, { delay: Math.floor(Math.random() * 130) + 40 });
449:             await page.waitForTimeout(280 + Math.random() * 420);
450:             await element.press('Backspace');
451:             await page.waitForTimeout(180 + Math.random() * 250);
452:         }
453: 
454:         await element.pressSequentially(text[i], { delay: Math.floor(Math.random() * 150) + 40 });
455: 
456:         // Pausa pi√π lunga occasionale (come quando si pensa alla prossima parola)
457:         if (Math.random() < 0.04) {
458:             await humanDelay(page, 400, 1100);
459:         }
460:     }
461: }
462: 
463: /**
464:  * Scrolling variabile con 3-7 movimenti, velocit√† diversa e 30% di probabilit√†
465:  * di tornare in cima (comportamento dei lettori reali).
466:  */
467: export async function simulateHumanReading(page: Page): Promise<void> {
468:     const scrollCount = 3 + Math.floor(Math.random() * 5); // 3-7 scroll
469:     for (let i = 0; i < scrollCount; i++) {
470:         const deltaY = 150 + Math.random() * 380;
471:         await page.evaluate((dy: number) => window.scrollBy({ top: dy, behavior: 'smooth' }), deltaY);
472:         await humanDelay(page, 700, 2200);
473:     }
474:     // 30% di probabilit√† di tornare in cima
475:     if (Math.random() < 0.3) {
476:         await page.evaluate(() => window.scrollTo({ top: 0, behavior: 'smooth' }));
477:         await humanDelay(page, 500, 1400);
478:     }
479: }
480: 
481: /**
482:  * Pausa randomizzata tra un job e il successivo per evitare il pattern burst.
483:  * Range: 30‚Äì90 secondi di base, con picco occasionale ("pausa caff√®").
484:  */
485: export async function interJobDelay(page: Page): Promise<void> {
486:     const base = Math.floor(Math.random() * 60_000) + 30_000;
487:     const longBreak = Math.random() < 0.08 ? Math.floor(Math.random() * 240_000) + 180_000 : 0;
488:     const totalDelay = base + longBreak;
489: 
490:     if (Math.random() < 0.35) {
491:         await randomMouseMove(page);
492:     }
493: 
494:     const split = Math.floor(totalDelay * (0.4 + Math.random() * 0.2));
495:     await page.waitForTimeout(Math.max(0, split));
496: 
497:     if (Math.random() < 0.25) {
498:         await randomMouseMove(page);
499:     }
500: 
501:     await page.waitForTimeout(Math.max(0, totalDelay - split));
502: }
503: 
504: export async function runSelectorCanary(page: Page): Promise<boolean> {
505:     await page.goto('https://www.linkedin.com/feed/', { waitUntil: 'domcontentloaded' });
506:     await humanDelay(page, 1200, 2000);
507:     const navOk = await page.locator(SELECTORS.globalNav).count();
508:     return navOk > 0;
509: }
510: 
511: /**
512:  * Azioni Diversive Mute (Decoy):
513:  * Rompe i flow di automazione navigando in sezioni casuali di LinkedIn prima
514:  * di effettuare i veri task, per mascherare i pattern lineari da bot.
515:  */
516: export async function performDecoyAction(page: Page): Promise<void> {
517:     const actions = [
518:         async () => {
519:             await page.goto('https://www.linkedin.com/feed/', { waitUntil: 'domcontentloaded' });
520:             await simulateHumanReading(page);
521:         },
522:         async () => {
523:             await page.goto('https://www.linkedin.com/mynetwork/', { waitUntil: 'domcontentloaded' });
524:             await humanDelay(page, 2000, 5000);
525:             await simulateHumanReading(page);
526:         },
527:         async () => {
528:             const terms = ['marketing', 'developer', 'ceo', 'sales', 'hr', 'tech', 'design'];
529:             const search = randomElement(terms);
530:             await page.goto(`https://www.linkedin.com/search/results/people/?keywords=${search}`, { waitUntil: 'domcontentloaded' });
531:             await humanDelay(page, 1500, 4000);
532:             await simulateHumanReading(page);
533:         }
534:     ];
535: 
536:     try {
537:         const decoy = randomElement(actions);
538:         await decoy();
539:     } catch {
540:         // Ignora silenziosamente, √® solo un'azione noise decoy
541:     }
542: }
````

## File: src/core/jobRunner.ts
````typescript
  1: import { BrowserSession, closeBrowser, interJobDelay, launchBrowser, checkLogin, performDecoyAction } from '../browser';
  2: import { getRuntimeAccountProfiles, isMultiAccountRuntimeEnabled, RuntimeAccountProfile } from '../accountManager';
  3: import { config } from '../config';
  4: import { pauseAutomation, quarantineAccount } from '../risk/incidentManager';
  5: import { logError, logInfo, logWarn } from '../telemetry/logger';
  6: import { JobType } from '../types/domain';
  7: import { WorkerContext } from '../workers/context';
  8: import { processAcceptanceJob } from '../workers/acceptanceWorker';
  9: import { processInviteJob } from '../workers/inviteWorker';
 10: import { processMessageJob } from '../workers/messageWorker';
 11: import { processHygieneJob } from '../workers/hygieneWorker';
 12: import { ChallengeDetectedError } from '../workers/errors';
 13: import { transitionLead } from './leadStateService';
 14: import {
 15:     createJobAttempt,
 16:     getAutomationPauseState,
 17:     getRuntimeFlag,
 18:     incrementDailyStat,
 19:     lockNextQueuedJob,
 20:     markJobRetryOrDeadLetter,
 21:     markJobSucceeded,
 22:     parseJobPayload,
 23:     pushOutboxEvent,
 24: } from './repositories';
 25: 
 26: export interface RunJobsOptions {
 27:     localDate: string;
 28:     allowedTypes: JobType[];
 29:     dryRun: boolean;
 30: }
 31: 
 32: function retryDelayMs(attempt: number): number {
 33:     const jitter = Math.floor(Math.random() * 250);
 34:     return config.retryBaseMs * Math.pow(2, Math.max(0, attempt - 1)) + jitter;
 35: }
 36: 
 37: async function rotateSessionWithLoginCheck(
 38:     session: BrowserSession,
 39:     workerContext: WorkerContext,
 40:     reason: string,
 41:     account: RuntimeAccountProfile,
 42: ): Promise<BrowserSession | null> {
 43:     await logInfo('job_runner.session_rotate.start', { reason, accountId: account.id });
 44:     await closeBrowser(session);
 45: 
 46:     const rotated = await launchBrowser({
 47:         sessionDir: account.sessionDir,
 48:         proxy: account.proxy,
 49:     });
 50:     const loggedIn = await checkLogin(rotated.page);
 51:     if (!loggedIn) {
 52:         await closeBrowser(rotated);
 53:         await quarantineAccount('LOGIN_MISSING', {
 54:             message: 'Sessione non autenticata su LinkedIn dopo rotazione proxy/sessione',
 55:             reason,
 56:             accountId: account.id,
 57:         });
 58:         return null;
 59:     }
 60: 
 61:     workerContext.session = rotated;
 62:     await logInfo('job_runner.session_rotate.ok', { reason, accountId: account.id });
 63:     return rotated;
 64: }
 65: 
 66: async function runQueuedJobsForAccount(
 67:     options: RunJobsOptions,
 68:     account: RuntimeAccountProfile,
 69:     includeLegacyDefaultQueue: boolean
 70: ): Promise<void> {
 71:     let session = await launchBrowser({
 72:         sessionDir: account.sessionDir,
 73:         proxy: account.proxy,
 74:     });
 75:     let sessionClosed = false;
 76:     try {
 77:         const loggedIn = await checkLogin(session.page);
 78:         if (!loggedIn) {
 79:             await quarantineAccount('LOGIN_MISSING', {
 80:                 message: 'Sessione non autenticata su LinkedIn',
 81:                 accountId: account.id,
 82:             });
 83:             return;
 84:         }
 85: 
 86:         const workerContext: WorkerContext = {
 87:             session,
 88:             dryRun: options.dryRun,
 89:             localDate: options.localDate,
 90:             accountId: account.id,
 91:         };
 92:         let consecutiveFailures = 0;
 93:         let processedOnCurrentSession = 0;
 94:         const rotateEveryJobs = config.proxyRotateEveryJobs;
 95:         const rotateEveryMinutes = config.proxyRotateEveryMinutes;
 96:         const rotateEveryMs = rotateEveryMinutes > 0 ? rotateEveryMinutes * 60_000 : 0;
 97:         let sessionStartedAtMs = Date.now();
 98: 
 99:         while (true) {
100:             const pauseState = await getAutomationPauseState();
101:             if (pauseState.paused) {
102:                 await logWarn('job_runner.skipped_paused', {
103:                     accountId: account.id,
104:                     reason: pauseState.reason,
105:                     pausedUntil: pauseState.pausedUntil,
106:                     remainingSeconds: pauseState.remainingSeconds,
107:                 });
108:                 break;
109:             }
110: 
111:             const job = await lockNextQueuedJob(options.allowedTypes, account.id, includeLegacyDefaultQueue);
112:             if (!job) break;
113: 
114:             await logInfo('job.started', {
115:                 jobId: job.id,
116:                 type: job.type,
117:                 attempt: job.attempts + 1,
118:                 accountId: account.id,
119:                 jobAccountId: job.account_id,
120:             });
121: 
122:             try {
123:                 // Azioni diversive (Decoy) per mascherare pattern del bot (20% probabilit√†)
124:                 if (Math.random() < 0.20) {
125:                     await performDecoyAction(session.page);
126:                 }
127: 
128:                 if (job.type === 'INVITE') {
129:                     const parsed = parseJobPayload<{ leadId: number; localDate: string }>(job);
130:                     await processInviteJob(parsed.payload, workerContext);
131:                 } else if (job.type === 'ACCEPTANCE_CHECK') {
132:                     const parsed = parseJobPayload<{ leadId: number }>(job);
133:                     await processAcceptanceJob(parsed.payload, workerContext);
134:                 } else if (job.type === 'MESSAGE') {
135:                     const parsed = parseJobPayload<{ leadId: number; acceptedAtDate: string }>(job);
136:                     await processMessageJob(parsed.payload, workerContext);
137:                 } else if (job.type === 'HYGIENE') {
138:                     const parsed = parseJobPayload<{ accountId: string }>(job);
139:                     await processHygieneJob(parsed.payload, workerContext);
140:                 }
141: 
142:                 await markJobSucceeded(job.id);
143:                 await createJobAttempt(job.id, true, null, null, null);
144:                 await pushOutboxEvent(
145:                     'job.succeeded',
146:                     { jobId: job.id, type: job.type, dryRun: options.dryRun, accountId: account.id },
147:                     `job.succeeded:${job.id}:${job.type}`
148:                 );
149:                 consecutiveFailures = 0;
150: 
151:                 // Pausa umana tra un job e il successivo (anti-burst)
152:                 await interJobDelay(session.page);
153:                 processedOnCurrentSession += 1;
154:             } catch (error) {
155:                 const message = error instanceof Error ? error.message : String(error);
156:                 const attempts = job.attempts + 1;
157: 
158:                 await createJobAttempt(job.id, false, error instanceof Error ? error.name : 'UNKNOWN_ERROR', message, null);
159:                 await incrementDailyStat(options.localDate, 'run_errors');
160: 
161:                 if (error instanceof ChallengeDetectedError) {
162:                     await incrementDailyStat(options.localDate, 'challenges_count');
163:                     await quarantineAccount('CHALLENGE_DETECTED', {
164:                         jobId: job.id,
165:                         jobType: job.type,
166:                         message,
167:                         accountId: account.id,
168:                     });
169:                     await markJobRetryOrDeadLetter(job.id, attempts, attempts, 0, message);
170:                     await logError('job.challenge_detected', { jobId: job.id, type: job.type, message, accountId: account.id });
171:                     break;
172:                 }
173: 
174:                 processedOnCurrentSession += 1;
175: 
176:                 const nextDelay = retryDelayMs(attempts);
177:                 const status = await markJobRetryOrDeadLetter(job.id, attempts, job.max_attempts, nextDelay, message);
178:                 await pushOutboxEvent(
179:                     'job.failed',
180:                     {
181:                         jobId: job.id,
182:                         type: job.type,
183:                         attempts,
184:                         status,
185:                         error: message,
186:                         accountId: account.id,
187:                     },
188:                     `job.failed:${job.id}:${attempts}`
189:                 );
190: 
191:                 if (status === 'DEAD_LETTER' && (job.type === 'INVITE' || job.type === 'MESSAGE' || job.type === 'ACCEPTANCE_CHECK')) {
192:                     try {
193:                         const parsed = parseJobPayload<{ leadId?: number }>(job);
194:                         if (parsed.payload.leadId) {
195:                             await transitionLead(parsed.payload.leadId, 'REVIEW_REQUIRED', `job_dead_letter_${job.type.toLowerCase()}`);
196:                             await logWarn('job.dead_letter.lead_review_required', { jobId: job.id, leadId: parsed.payload.leadId, type: job.type });
197:                         }
198:                     } catch {
199:                         // ignore if payload cannot be parsed
200:                     }
201:                 }
202: 
203:                 await logWarn('job.failed', {
204:                     jobId: job.id,
205:                     type: job.type,
206:                     status,
207:                     attempts,
208:                     message,
209:                     accountId: account.id,
210:                 });
211: 
212:                 consecutiveFailures += 1;
213:                 if (consecutiveFailures >= config.maxConsecutiveJobFailures) {
214:                     await pauseAutomation(
215:                         'CONSECUTIVE_JOB_FAILURES',
216:                         {
217:                             threshold: config.maxConsecutiveJobFailures,
218:                             consecutiveFailures,
219:                             lastJobId: job.id,
220:                             lastJobType: job.type,
221:                             lastError: message,
222:                             accountId: account.id,
223:                         },
224:                         config.autoPauseMinutesOnFailureBurst
225:                     );
226:                     await logWarn('job_runner.paused.failure_burst', {
227:                         threshold: config.maxConsecutiveJobFailures,
228:                         consecutiveFailures,
229:                         pauseMinutes: config.autoPauseMinutesOnFailureBurst,
230:                         accountId: account.id,
231:                     });
232:                     break;
233:                 }
234:             }
235: 
236:             const rotateReasons: string[] = [];
237:             if (rotateEveryJobs > 0 && processedOnCurrentSession >= rotateEveryJobs) {
238:                 rotateReasons.push(`threshold_${rotateEveryJobs}_jobs`);
239:             }
240:             if (rotateEveryMs > 0 && Date.now() - sessionStartedAtMs >= rotateEveryMs) {
241:                 rotateReasons.push(`threshold_${rotateEveryMinutes}_minutes`);
242:             }
243: 
244:             if (rotateReasons.length > 0) {
245:                 const rotated = await rotateSessionWithLoginCheck(
246:                     session,
247:                     workerContext,
248:                     rotateReasons.join('+'),
249:                     account
250:                 );
251:                 if (!rotated) {
252:                     sessionClosed = true;
253:                     return;
254:                 }
255:                 session = rotated;
256:                 processedOnCurrentSession = 0;
257:                 sessionStartedAtMs = Date.now();
258:             }
259:         }
260:     } finally {
261:         if (!sessionClosed) {
262:             await closeBrowser(session);
263:         }
264:     }
265: }
266: 
267: export async function runQueuedJobs(options: RunJobsOptions): Promise<void> {
268:     const quarantineFlag = await getRuntimeFlag('account_quarantine');
269:     if (quarantineFlag === 'true') {
270:         await logWarn('job_runner.skipped_quarantine', { reason: 'account_quarantine=true' });
271:         return;
272:     }
273: 
274:     const accounts = getRuntimeAccountProfiles();
275:     for (let index = 0; index < accounts.length; index++) {
276:         const account = accounts[index];
277:         const includeLegacyDefaultQueue = isMultiAccountRuntimeEnabled() && index === 0 && account.id !== 'default';
278:         await logInfo('job_runner.account.start', {
279:             accountId: account.id,
280:             includeLegacyDefaultQueue,
281:             sessionDir: account.sessionDir,
282:         });
283: 
284:         await runQueuedJobsForAccount(options, account, includeLegacyDefaultQueue);
285: 
286:         await logInfo('job_runner.account.done', { accountId: account.id });
287:         const latestQuarantineFlag = await getRuntimeFlag('account_quarantine');
288:         if (latestQuarantineFlag === 'true') {
289:             break;
290:         }
291:     }
292: }
````

## File: src/core/scheduler.ts
````typescript
  1: import { config, getLocalDateString, getWeekStartDate } from '../config';
  2: import { pickAccountIdForLead, getRuntimeAccountProfiles } from '../accountManager';
  3: import { evaluateRisk, calculateDynamicBudget } from '../risk/riskEngine';
  4: import { JobType, RiskSnapshot } from '../types/domain';
  5: import {
  6:     countWeeklyInvites,
  7:     ensureLeadList,
  8:     enqueueJob,
  9:     getDailyStat,
 10:     getLeadStatusCountsForLists,
 11:     getLeadsByStatusForList,
 12:     getListDailyStat,
 13:     getRiskInputs,
 14:     listLeadCampaignConfigs,
 15:     promoteNewLeadsToReadyInvite,
 16:     syncLeadListsFromLeads,
 17:     getAccountAgeDays
 18: } from './repositories';
 19: import { transitionLead } from './leadStateService';
 20: 
 21: export type WorkflowSelection = 'invite' | 'check' | 'message' | 'warmup' | 'all';
 22: 
 23: export interface ScheduleResult {
 24:     localDate: string;
 25:     riskSnapshot: RiskSnapshot;
 26:     inviteBudget: number;
 27:     messageBudget: number;
 28:     queuedInviteJobs: number;
 29:     queuedCheckJobs: number;
 30:     queuedMessageJobs: number;
 31:     listBreakdown: ListScheduleBreakdown[];
 32:     dryRun: boolean;
 33: }
 34: 
 35: export interface ScheduleOptions {
 36:     dryRun?: boolean;
 37: }
 38: 
 39: export interface ListScheduleBreakdown {
 40:     listName: string;
 41:     inviteBudget: number;
 42:     messageBudget: number;
 43:     queuedInviteJobs: number;
 44:     queuedCheckJobs: number;
 45:     queuedMessageJobs: number;
 46:     adaptiveFactor: number;
 47:     adaptiveReasons: string[];
 48:     pendingRatio: number;
 49:     blockedRatio: number;
 50:     maxScheduledDelaySec: number;
 51: }
 52: 
 53: export function workflowToJobTypes(workflow: WorkflowSelection): JobType[] {
 54:     if (workflow === 'all') return ['INVITE', 'ACCEPTANCE_CHECK', 'MESSAGE', 'HYGIENE'];
 55:     if (workflow === 'invite') return ['INVITE'];
 56:     if (workflow === 'check' || workflow === 'warmup') return ['ACCEPTANCE_CHECK', 'HYGIENE'];
 57:     return ['MESSAGE', 'HYGIENE'];
 58: }
 59: 
 60: function buildInviteKey(leadId: number, localDate: string): string {
 61:     return `invite:${leadId}:${localDate}`;
 62: }
 63: 
 64: function buildMessageKey(leadId: number, acceptedAtDate: string): string {
 65:     return `message:${leadId}:${acceptedAtDate}`;
 66: }
 67: 
 68: function buildCheckKey(leadId: number, localDate: string): string {
 69:     return `check:${leadId}:${localDate}`;
 70: }
 71: 
 72: function computeListBudget(globalRemaining: number, listCap: number | null, alreadyConsumed: number): number {
 73:     const listRemaining = listCap === null
 74:         ? globalRemaining
 75:         : Math.max(0, listCap - alreadyConsumed);
 76:     return Math.max(0, Math.min(globalRemaining, listRemaining));
 77: }
 78: 
 79: interface AdaptiveBudgetContext {
 80:     factor: number;
 81:     reasons: string[];
 82:     pendingRatio: number;
 83:     blockedRatio: number;
 84: }
 85: 
 86: interface NoBurstPlanner {
 87:     nextDelaySec: () => number;
 88: }
 89: 
 90: function toNonNegativeInt(value: number): number {
 91:     return Math.max(0, Math.floor(value));
 92: }
 93: 
 94: function clamp01(value: number): number {
 95:     return Math.min(1, Math.max(0, value));
 96: }
 97: 
 98: function pickRandomInt(min: number, max: number): number {
 99:     const low = Math.min(min, max);
100:     const high = Math.max(min, max);
101:     if (high <= low) return low;
102:     return Math.floor(Math.random() * (high - low + 1)) + low;
103: }
104: 
105: function applyAdaptiveFactor(rawBudget: number, factor: number): number {
106:     if (rawBudget <= 0 || factor <= 0) {
107:         return 0;
108:     }
109:     const computed = Math.floor(rawBudget * factor);
110:     if (computed <= 0) {
111:         return 1;
112:     }
113:     return Math.min(rawBudget, computed);
114: }
115: 
116: function evaluateAdaptiveBudgetContext(
117:     statusCounts: Record<string, number>,
118:     riskAction: RiskSnapshot['action']
119: ): AdaptiveBudgetContext {
120:     if (!config.adaptiveCapsEnabled) {
121:         return {
122:             factor: riskAction === 'STOP' ? 0 : 1,
123:             reasons: riskAction === 'STOP' ? ['global_risk_stop'] : [],
124:             pendingRatio: 0,
125:             blockedRatio: 0,
126:         };
127:     }
128: 
129:     const invited = statusCounts.INVITED ?? 0;
130:     const acceptedLike = (statusCounts.ACCEPTED ?? 0) + (statusCounts.READY_MESSAGE ?? 0) + (statusCounts.MESSAGED ?? 0);
131:     const blockedSkipped = (statusCounts.BLOCKED ?? 0) + (statusCounts.SKIPPED ?? 0);
132: 
133:     const pendingRatioDenominator = Math.max(1, invited + acceptedLike);
134:     const pendingRatio = invited / pendingRatioDenominator;
135: 
136:     const blockedRatioDenominator = Math.max(1, invited + acceptedLike + blockedSkipped);
137:     const blockedRatio = blockedSkipped / blockedRatioDenominator;
138: 
139:     let factor = 1;
140:     const reasons: string[] = [];
141: 
142:     if (riskAction === 'STOP') {
143:         factor = 0;
144:         reasons.push('global_risk_stop');
145:     } else if (riskAction === 'WARN') {
146:         factor = Math.min(factor, clamp01(config.adaptiveCapsWarnFactor));
147:         reasons.push('global_risk_warn');
148:     }
149: 
150:     if (pendingRatio >= config.adaptiveCapsPendingStop) {
151:         factor = Math.min(factor, clamp01(config.adaptiveCapsMinFactor));
152:         reasons.push('list_pending_high');
153:     } else if (pendingRatio >= config.adaptiveCapsPendingWarn) {
154:         factor = Math.min(factor, 0.5);
155:         reasons.push('list_pending_warn');
156:     }
157: 
158:     if (blockedRatio >= config.adaptiveCapsBlockedWarn) {
159:         factor = Math.min(factor, 0.6);
160:         reasons.push('list_blocked_warn');
161:     }
162: 
163:     return {
164:         factor: clamp01(factor),
165:         reasons,
166:         pendingRatio: Number.parseFloat(pendingRatio.toFixed(4)),
167:         blockedRatio: Number.parseFloat(blockedRatio.toFixed(4)),
168:     };
169: }
170: 
171: function createNoBurstPlanner(): NoBurstPlanner {
172:     const minDelay = toNonNegativeInt(config.noBurstMinDelaySec);
173:     const maxDelay = toNonNegativeInt(config.noBurstMaxDelaySec);
174:     const longBreakEvery = toNonNegativeInt(config.noBurstLongBreakEvery);
175:     const longBreakMin = toNonNegativeInt(config.noBurstLongBreakMinSec);
176:     const longBreakMax = toNonNegativeInt(config.noBurstLongBreakMaxSec);
177: 
178:     let totalDelaySec = 0;
179:     let queuedJobs = 0;
180: 
181:     return {
182:         nextDelaySec: () => {
183:             queuedJobs += 1;
184:             totalDelaySec += pickRandomInt(minDelay, maxDelay);
185: 
186:             if (longBreakEvery > 0 && queuedJobs % longBreakEvery === 0) {
187:                 totalDelaySec += pickRandomInt(longBreakMin, longBreakMax);
188:             }
189: 
190:             return totalDelaySec;
191:         },
192:     };
193: }
194: 
195: async function resolveActiveLists(): Promise<string[]> {
196:     await syncLeadListsFromLeads();
197:     let lists = await listLeadCampaignConfigs(true);
198:     if (lists.length === 0) {
199:         await ensureLeadList('default');
200:         lists = await listLeadCampaignConfigs(true);
201:     }
202:     return lists.map((list) => list.name);
203: }
204: 
205: function initListBreakdown(listNames: string[]): Map<string, ListScheduleBreakdown> {
206:     const map = new Map<string, ListScheduleBreakdown>();
207:     for (const listName of listNames) {
208:         map.set(listName, {
209:             listName,
210:             inviteBudget: 0,
211:             messageBudget: 0,
212:             queuedInviteJobs: 0,
213:             queuedCheckJobs: 0,
214:             queuedMessageJobs: 0,
215:             adaptiveFactor: 1,
216:             adaptiveReasons: [],
217:             pendingRatio: 0,
218:             blockedRatio: 0,
219:             maxScheduledDelaySec: 0,
220:         });
221:     }
222:     return map;
223: }
224: 
225: export async function scheduleJobs(workflow: WorkflowSelection, options: ScheduleOptions = {}): Promise<ScheduleResult> {
226:     const dryRun = options.dryRun ?? false;
227:     const localDate = getLocalDateString();
228:     const riskInputs = await getRiskInputs(localDate, config.hardInviteCap);
229:     const riskSnapshot = evaluateRisk(riskInputs);
230: 
231:     const dailyInvitesSent = await getDailyStat(localDate, 'invites_sent');
232:     const dailyMessagesSent = await getDailyStat(localDate, 'messages_sent');
233:     const weekStartDate = getWeekStartDate();
234:     const weeklyInvitesSent = await countWeeklyInvites(weekStartDate);
235:     const weeklyRemaining = Math.max(0, config.weeklyInviteLimit - weeklyInvitesSent);
236: 
237:     const accountAgeDays = await getAccountAgeDays();
238: 
239:     const inviteBudget = Math.min(
240:         calculateDynamicBudget(config.softInviteCap, config.hardInviteCap, dailyInvitesSent, riskSnapshot.action, accountAgeDays),
241:         weeklyRemaining
242:     );
243:     const messageBudget = calculateDynamicBudget(config.softMsgCap, config.hardMsgCap, dailyMessagesSent, riskSnapshot.action, accountAgeDays);
244: 
245:     // WARMUP BYPASS: nessun invio email/connessioni
246:     const effectiveInviteBudget = workflow === 'warmup' ? 0 : inviteBudget;
247:     const effectiveMessageBudget = workflow === 'warmup' ? 0 : messageBudget;
248: 
249:     let queuedInviteJobs = 0;
250:     let queuedCheckJobs = 0;
251:     let queuedMessageJobs = 0;
252:     await syncLeadListsFromLeads();
253:     let listConfigs = await listLeadCampaignConfigs(true);
254:     if (listConfigs.length === 0) {
255:         await ensureLeadList('default');
256:         listConfigs = await listLeadCampaignConfigs(true);
257:     }
258:     const activeListNames = listConfigs.length > 0
259:         ? listConfigs.map((list) => list.name)
260:         : await resolveActiveLists();
261:     const listBreakdown = initListBreakdown(activeListNames);
262:     const listConfigMap = new Map(listConfigs.map((list) => [list.name, list]));
263:     const statusRows = await getLeadStatusCountsForLists(activeListNames);
264:     const listStatusCounts = new Map<string, Record<string, number>>();
265:     for (const row of statusRows) {
266:         const statusName = row.status === 'PENDING' ? 'READY_INVITE' : row.status;
267:         if (!listStatusCounts.has(row.list_name)) {
268:             listStatusCounts.set(row.list_name, {});
269:         }
270:         const target = listStatusCounts.get(row.list_name);
271:         if (!target) continue;
272:         target[statusName] = (target[statusName] ?? 0) + row.total;
273:     }
274:     const adaptiveContextMap = new Map<string, AdaptiveBudgetContext>();
275:     for (const listName of activeListNames) {
276:         const statusCounts = listStatusCounts.get(listName) ?? {};
277:         const context = evaluateAdaptiveBudgetContext(statusCounts, riskSnapshot.action);
278:         adaptiveContextMap.set(listName, context);
279:         const breakdown = listBreakdown.get(listName);
280:         if (breakdown) {
281:             breakdown.adaptiveFactor = context.factor;
282:             breakdown.adaptiveReasons = context.reasons;
283:             breakdown.pendingRatio = context.pendingRatio;
284:             breakdown.blockedRatio = context.blockedRatio;
285:         }
286:     }
287:     const noBurstPlanner = !dryRun && config.noBurstEnabled ? createNoBurstPlanner() : null;
288: 
289:     if (!dryRun && riskSnapshot.action !== 'STOP') {
290:         await promoteNewLeadsToReadyInvite(config.hardInviteCap * 4);
291:     }
292: 
293:     if (workflow === 'all' || workflow === 'invite') {
294:         let remainingInviteBudget = effectiveInviteBudget;
295:         for (const listName of activeListNames) {
296:             if (remainingInviteBudget <= 0) break;
297:             const breakdown = listBreakdown.get(listName);
298:             if (!breakdown) continue;
299: 
300:             const listConfig = listConfigMap.get(listName);
301:             const listInvitesSent = await getListDailyStat(localDate, listName, 'invites_sent');
302:             const rawListBudget = computeListBudget(remainingInviteBudget, listConfig?.dailyInviteCap ?? null, listInvitesSent);
303:             const adaptive = adaptiveContextMap.get(listName);
304:             const listBudget = applyAdaptiveFactor(rawListBudget, adaptive?.factor ?? 1);
305:             breakdown.inviteBudget = listBudget;
306:             if (listBudget <= 0) continue;
307: 
308:             if (dryRun) {
309:                 const readyCandidates = await getLeadsByStatusForList('READY_INVITE', listName, listBudget);
310:                 const newCandidates = await getLeadsByStatusForList('NEW', listName, listBudget);
311:                 const candidateIds = new Set<number>();
312:                 for (const lead of readyCandidates) candidateIds.add(lead.id);
313:                 for (const lead of newCandidates) candidateIds.add(lead.id);
314:                 const planned = Math.min(listBudget, candidateIds.size);
315:                 breakdown.queuedInviteJobs += planned;
316:                 queuedInviteJobs += planned;
317:                 remainingInviteBudget -= planned;
318:                 continue;
319:             }
320: 
321:             const inviteCandidates = await getLeadsByStatusForList('READY_INVITE', listName, listBudget);
322: 
323:             let insertedForList = 0;
324:             for (const lead of inviteCandidates) {
325:                 const initialDelaySec = noBurstPlanner ? noBurstPlanner.nextDelaySec() : 0;
326:                 const accountId = pickAccountIdForLead(lead.id);
327:                 const inserted = await enqueueJob(
328:                     'INVITE',
329:                     { leadId: lead.id, localDate },
330:                     buildInviteKey(lead.id, localDate),
331:                     10,
332:                     config.retryMaxAttempts,
333:                     initialDelaySec,
334:                     accountId
335:                 );
336:                 if (inserted) {
337:                     insertedForList += 1;
338:                     queuedInviteJobs += 1;
339:                     breakdown.maxScheduledDelaySec = Math.max(breakdown.maxScheduledDelaySec, initialDelaySec);
340:                 }
341:             }
342:             breakdown.queuedInviteJobs += insertedForList;
343:             remainingInviteBudget -= insertedForList;
344:         }
345:     }
346: 
347:     if (workflow === 'all' || workflow === 'check') {
348:         const checkLimitPerList = Math.max(25, config.hardInviteCap * 3);
349:         for (const listName of activeListNames) {
350:             const breakdown = listBreakdown.get(listName);
351:             if (!breakdown) continue;
352:             const invitedLeads = await getLeadsByStatusForList('INVITED', listName, checkLimitPerList);
353:             if (dryRun) {
354:                 breakdown.queuedCheckJobs += invitedLeads.length;
355:                 queuedCheckJobs += invitedLeads.length;
356:                 continue;
357:             }
358: 
359:             let insertedForList = 0;
360:             for (const lead of invitedLeads) {
361:                 const initialDelaySec = noBurstPlanner ? noBurstPlanner.nextDelaySec() : 0;
362:                 const accountId = pickAccountIdForLead(lead.id);
363:                 const inserted = await enqueueJob(
364:                     'ACCEPTANCE_CHECK',
365:                     { leadId: lead.id },
366:                     buildCheckKey(lead.id, localDate),
367:                     30,
368:                     config.retryMaxAttempts,
369:                     initialDelaySec,
370:                     accountId
371:                 );
372:                 if (inserted) {
373:                     insertedForList += 1;
374:                     queuedCheckJobs += 1;
375:                     breakdown.maxScheduledDelaySec = Math.max(breakdown.maxScheduledDelaySec, initialDelaySec);
376:                 }
377:             }
378:             breakdown.queuedCheckJobs += insertedForList;
379:         }
380:     }
381: 
382:     if (workflow === 'all' || workflow === 'message') {
383:         let remainingMessageBudget = effectiveMessageBudget;
384:         for (const listName of activeListNames) {
385:             if (remainingMessageBudget <= 0) break;
386:             const breakdown = listBreakdown.get(listName);
387:             if (!breakdown) continue;
388: 
389:             const listConfig = listConfigMap.get(listName);
390:             const listMessagesSent = await getListDailyStat(localDate, listName, 'messages_sent');
391:             const rawListBudget = computeListBudget(remainingMessageBudget, listConfig?.dailyMessageCap ?? null, listMessagesSent);
392:             const adaptive = adaptiveContextMap.get(listName);
393:             const listBudget = applyAdaptiveFactor(rawListBudget, adaptive?.factor ?? 1);
394:             breakdown.messageBudget = listBudget;
395:             if (listBudget <= 0) continue;
396: 
397:             if (dryRun) {
398:                 const accepted = await getLeadsByStatusForList('ACCEPTED', listName, listBudget);
399:                 const readyToMessage = await getLeadsByStatusForList('READY_MESSAGE', listName, listBudget);
400:                 const uniqueLeadIds = new Set<number>();
401:                 for (const lead of accepted) uniqueLeadIds.add(lead.id);
402:                 for (const lead of readyToMessage) uniqueLeadIds.add(lead.id);
403:                 const planned = Math.min(listBudget, uniqueLeadIds.size);
404:                 breakdown.queuedMessageJobs += planned;
405:                 queuedMessageJobs += planned;
406:                 remainingMessageBudget -= planned;
407:                 continue;
408:             }
409: 
410:             const accepted = await getLeadsByStatusForList('ACCEPTED', listName, Math.max(50, listBudget));
411:             for (const lead of accepted) {
412:                 await transitionLead(lead.id, 'READY_MESSAGE', 'scheduler_promote_to_ready_message');
413:             }
414:             const readyToMessage = await getLeadsByStatusForList('READY_MESSAGE', listName, listBudget);
415: 
416:             let insertedForList = 0;
417:             for (const lead of readyToMessage) {
418:                 const acceptedAtDate = lead.accepted_at ? lead.accepted_at.slice(0, 10) : localDate;
419:                 const minDelayHours = Math.max(0, config.messageScheduleMinDelayHours);
420:                 const maxDelayHours = Math.max(minDelayHours, config.messageScheduleMaxDelayHours);
421:                 let acceptanceDelaySec = 0;
422:                 if (maxDelayHours > 0) {
423:                     const targetDelaySec = pickRandomInt(minDelayHours * 3600, maxDelayHours * 3600);
424:                     const acceptedAtMs = lead.accepted_at ? Date.parse(lead.accepted_at) : NaN;
425:                     const elapsedSec = Number.isFinite(acceptedAtMs)
426:                         ? Math.max(0, Math.floor((Date.now() - acceptedAtMs) / 1000))
427:                         : 0;
428:                     acceptanceDelaySec = Math.max(0, targetDelaySec - elapsedSec);
429:                 }
430: 
431:                 const noBurstDelaySec = noBurstPlanner ? noBurstPlanner.nextDelaySec() : 0;
432:                 const initialDelaySec = acceptanceDelaySec + noBurstDelaySec;
433:                 const accountId = pickAccountIdForLead(lead.id);
434:                 const inserted = await enqueueJob(
435:                     'MESSAGE',
436:                     { leadId: lead.id, acceptedAtDate },
437:                     buildMessageKey(lead.id, acceptedAtDate),
438:                     20,
439:                     config.retryMaxAttempts,
440:                     initialDelaySec,
441:                     accountId
442:                 );
443:                 if (inserted) {
444:                     insertedForList += 1;
445:                     queuedMessageJobs += 1;
446:                     breakdown.maxScheduledDelaySec = Math.max(breakdown.maxScheduledDelaySec, initialDelaySec);
447:                 }
448:             }
449:             breakdown.queuedMessageJobs += insertedForList;
450:             remainingMessageBudget -= insertedForList;
451:         }
452:     }
453: 
454:     if (!dryRun && config.withdrawInvitesEnabled) {
455:         const accounts = await getRuntimeAccountProfiles();
456:         for (const acc of accounts) {
457:             await enqueueJob(
458:                 'HYGIENE',
459:                 { accountId: acc.id },
460:                 `hygiene:${acc.id}:${localDate}`,
461:                 5,
462:                 1,
463:                 pickRandomInt(1800, 14400),
464:                 acc.id
465:             );
466:         }
467:     }
468: 
469:     return {
470:         localDate,
471:         riskSnapshot,
472:         inviteBudget: effectiveInviteBudget,
473:         messageBudget: effectiveMessageBudget,
474:         queuedInviteJobs,
475:         queuedCheckJobs,
476:         queuedMessageJobs,
477:         listBreakdown: Array.from(listBreakdown.values()),
478:         dryRun,
479:     };
480: }
````

## File: src/workers/inviteWorker.ts
````typescript
  1: import { Page } from 'playwright';
  2: import { detectChallenge, humanDelay, humanMouseMove, humanType, simulateHumanReading } from '../browser';
  3: import { transitionLead } from '../core/leadStateService';
  4: import { getLeadById, incrementDailyStat, incrementListDailyStat, updateLeadScrapedContext, updateLeadPromptVariant } from '../core/repositories';
  5: import { SELECTORS } from '../selectors';
  6: import { InviteJobPayload, LeadRecord } from '../types/domain';
  7: import { WorkerContext } from './context';
  8: import { ChallengeDetectedError, RetryableWorkerError } from './errors';
  9: import { isSalesNavigatorUrl } from '../linkedinUrl';
 10: import { config } from '../config';
 11: import { buildPersonalizedInviteNote } from '../ai/inviteNotePersonalizer';
 12: import { pauseAutomation } from '../risk/incidentManager';
 13: import { bridgeDailyStat, bridgeLeadStatus } from '../cloud/cloudBridge';
 14: 
 15: async function clickConnectOnProfile(page: Page): Promise<boolean> {
 16:     const primaryBtn = page.locator(SELECTORS.connectButtonPrimary).first();
 17:     if (await primaryBtn.count() > 0) {
 18:         await humanMouseMove(page, SELECTORS.connectButtonPrimary);
 19:         await humanDelay(page, 120, 320);
 20:         await primaryBtn.click();
 21:         return true;
 22:     }
 23: 
 24:     const moreBtn = page.locator(SELECTORS.moreActionsButton).first();
 25:     if (await moreBtn.count() > 0) {
 26:         await humanMouseMove(page, SELECTORS.moreActionsButton);
 27:         await humanDelay(page, 120, 300);
 28:         await moreBtn.click();
 29:         await humanDelay(page, 700, 1300);
 30:         const connectInMenu = page.locator(SELECTORS.connectInMoreMenu).first();
 31:         if (await connectInMenu.count() > 0) {
 32:             await humanMouseMove(page, SELECTORS.connectInMoreMenu);
 33:             await humanDelay(page, 120, 300);
 34:             await connectInMenu.click();
 35:             return true;
 36:         }
 37:     }
 38: 
 39:     return false;
 40: }
 41: 
 42: async function detectInviteProof(page: Page): Promise<boolean> {
 43:     const pendingCount = await page.locator(SELECTORS.invitePendingIndicators).count();
 44:     if (pendingCount > 0) {
 45:         return true;
 46:     }
 47: 
 48:     const pageText = await page.textContent('body').catch(() => '');
 49:     if (!pageText) {
 50:         return false;
 51:     }
 52:     return /invitation sent|in attesa|pending/i.test(pageText);
 53: }
 54: 
 55: async function detectWeeklyInviteLimit(page: Page): Promise<boolean> {
 56:     const selectorCount = await page.locator(SELECTORS.inviteWeeklyLimitSignals).count();
 57:     if (selectorCount > 0) {
 58:         return true;
 59:     }
 60: 
 61:     const pageText = await page.textContent('body').catch(() => '');
 62:     if (!pageText) {
 63:         return false;
 64:     }
 65:     return /weekly invitation limit|limite settimanale(?: degli)? inviti|hai raggiunto il limite settimanale/i.test(pageText);
 66: }
 67: 
 68: /**
 69:  * Tenta di inviare l'invito con nota personalizzata (se INVITE_WITH_NOTE=true).
 70:  * Flusso:
 71:  *   1. Cerca il bottone "Add a note" nel modale
 72:  *   2. Scrive la nota via humanType
 73:  *   3. Clicca "Send" dal modale
 74:  * Se il bottone "Add a note" non √® presente, ricade su sendWithoutNote.
 75:  * Ritorna se l'invio √® avvenuto con nota e la source della nota (template/ai).
 76:  */
 77: async function handleInviteModal(
 78:     page: Page,
 79:     lead: LeadRecord,
 80:     dryRun: boolean,
 81:     localDate: string,
 82: ): Promise<{ sentWithNote: boolean; noteSource: 'template' | 'ai' | null; variant?: string | null }> {
 83:     if (dryRun) return { sentWithNote: false, noteSource: null, variant: null };
 84: 
 85:     // Controlla se c'√® il bottone "Add a note" (con retry breve se il modale sta caricando)
 86:     const addNoteBtn = page.locator(SELECTORS.addNoteButton).first();
 87:     let canAddNote = await addNoteBtn.count() > 0;
 88:     if (config.inviteWithNote && !canAddNote) {
 89:         await page.waitForSelector(SELECTORS.addNoteButton, { timeout: 2000 }).catch(() => null);
 90:         canAddNote = await addNoteBtn.count() > 0;
 91:     }
 92: 
 93:     if (config.inviteWithNote && canAddNote) {
 94:         await humanMouseMove(page, SELECTORS.addNoteButton);
 95:         await humanDelay(page, 150, 350);
 96:         await addNoteBtn.click();
 97:         await humanDelay(page, 600, 1200);
 98: 
 99:         // Scrivi la nota nella textarea del modale
100:         const generatedNote = await buildPersonalizedInviteNote(lead);
101:         if (generatedNote.variant) {
102:             await updateLeadPromptVariant(lead.id, generatedNote.variant);
103:             lead.invite_prompt_variant = generatedNote.variant;
104:         }
105: 
106:         try {
107:             await humanType(page, SELECTORS.noteTextarea, generatedNote.note);
108:         } catch {
109:             await incrementDailyStat(localDate, 'selector_failures');
110:             throw new RetryableWorkerError('Impossibile digitare la nota', 'TYPE_ERROR');
111:         }
112: 
113:         await humanDelay(page, 400, 800); // Changed from context.session.page to page
114: 
115:         const sendWithNote = page.locator(SELECTORS.sendWithNote).first(); // Changed from context.session.page to page
116:         if (await sendWithNote.count() > 0) {
117:             await humanMouseMove(page, SELECTORS.sendWithNote); // Changed from context.session.page to page
118:             await humanDelay(page, 150, 400); // Changed from context.session.page to page
119: 
120:             if (!dryRun) { // Changed from context.dryRun to dryRun
121:                 await sendWithNote.click();
122:             } else {
123:                 console.log(`[DRY RUN] Inviato invito a ${lead.linkedin_url} (nota: ${generatedNote.source} - var: ${generatedNote.variant || 'none'})`);
124:             }
125: 
126:             return { sentWithNote: true, noteSource: generatedNote.source, variant: generatedNote.variant };
127:         }
128: 
129:         // Se il bottone Send del modale non √® trovato, √® un errore bloccante
130:         await incrementDailyStat(localDate, 'selector_failures');
131:         throw new RetryableWorkerError('Send con nota non trovato nel modale', 'SEND_WITH_NOTE_NOT_FOUND');
132:     }
133: 
134:     // Fallback: invia senza nota
135:     const sendWithoutNote = page.locator(SELECTORS.sendWithoutNote).first();
136:     if (await sendWithoutNote.count() > 0) {
137:         await humanMouseMove(page, SELECTORS.sendWithoutNote);
138:         await humanDelay(page, 120, 300);
139:         await sendWithoutNote.click();
140:         return { sentWithNote: false, noteSource: null, variant: null };
141:     }
142: 
143:     const fallback = page.locator(SELECTORS.sendFallback).first();
144:     if (await fallback.count() > 0) {
145:         await humanMouseMove(page, SELECTORS.sendFallback);
146:         await humanDelay(page, 120, 300);
147:         await fallback.click();
148:         return { sentWithNote: false, noteSource: null, variant: null };
149:     }
150: 
151:     await incrementDailyStat(localDate, 'selector_failures');
152:     throw new RetryableWorkerError('Conferma invito senza nota non trovata', 'SEND_BUTTON_NOT_FOUND');
153: }
154: 
155: export async function processInviteJob(payload: InviteJobPayload, context: WorkerContext): Promise<void> {
156:     const lead = await getLeadById(payload.leadId);
157:     if (!lead) {
158:         throw new RetryableWorkerError(`Lead ${payload.leadId} non trovato`, 'LEAD_NOT_FOUND');
159:     }
160: 
161:     if (lead.status === 'NEW' || lead.status === 'PENDING') {
162:         await transitionLead(lead.id, 'READY_INVITE', 'new_lead_promoted');
163:     }
164: 
165:     if (lead.status !== 'READY_INVITE' && lead.status !== 'NEW' && lead.status !== 'PENDING') {
166:         return;
167:     }
168: 
169:     if (isSalesNavigatorUrl(lead.linkedin_url)) {
170:         await transitionLead(lead.id, 'BLOCKED', 'salesnav_url_requires_profile_invite');
171:         return;
172:     }
173: 
174:     await context.session.page.goto(lead.linkedin_url, { waitUntil: 'domcontentloaded' });
175:     await simulateHumanReading(context.session.page);
176: 
177:     if (await detectChallenge(context.session.page)) {
178:         throw new ChallengeDetectedError();
179:     }
180: 
181:     if (config.profileContextExtractionEnabled) {
182:         try {
183:             let extractedAbout: string | null = null;
184:             let extractedExperience: string | null = null;
185: 
186:             const aboutLocator = context.session.page.locator(SELECTORS.aboutSection).first();
187:             if (await aboutLocator.isVisible()) {
188:                 extractedAbout = (await aboutLocator.innerText()).trim();
189:             }
190: 
191:             const expLocator = context.session.page.locator(SELECTORS.experienceSection).first();
192:             if (await expLocator.isVisible()) {
193:                 extractedExperience = (await expLocator.innerText()).trim();
194:             }
195: 
196:             if (extractedAbout || extractedExperience) {
197:                 await updateLeadScrapedContext(lead.id, extractedAbout || null, extractedExperience || null);
198:                 lead.about = extractedAbout || null;
199:                 lead.experience = extractedExperience || null;
200: 
201:                 bridgeLeadStatus(lead.linkedin_url, lead.status, {
202:                     about: extractedAbout || null,
203:                     experience: extractedExperience || null
204:                 });
205:             }
206:         } catch (e) {
207:             // Estrazione opzionale: non bloccare l'invio dell'invito.
208:             console.warn(`[WARN] Impossibile estrarre contesto AI per lead ${lead.id}:`, e);
209:         }
210:     }
211: 
212:     const connectClicked = await clickConnectOnProfile(context.session.page);
213:     if (!connectClicked) {
214:         await incrementDailyStat(context.localDate, 'selector_failures');
215:         await transitionLead(lead.id, 'SKIPPED', 'connect_not_found');
216:         return;
217:     }
218: 
219:     await humanDelay(context.session.page, 900, 1800);
220: 
221:     const inviteResult = await handleInviteModal(
222:         context.session.page,
223:         lead,
224:         context.dryRun,
225:         context.localDate,
226:     );
227: 
228:     if (!context.dryRun) {
229:         const weeklyLimitReached = await detectWeeklyInviteLimit(context.session.page);
230:         if (weeklyLimitReached) {
231:             await pauseAutomation(
232:                 'WEEKLY_INVITE_LIMIT_REACHED',
233:                 {
234:                     leadId: lead.id,
235:                     linkedinUrl: lead.linkedin_url,
236:                     accountId: context.accountId,
237:                 },
238:                 7 * 24 * 60
239:             );
240:             throw new RetryableWorkerError('Limite settimanale inviti raggiunto', 'WEEKLY_LIMIT_REACHED');
241:         }
242:     }
243: 
244:     await humanDelay(context.session.page, 1200, 2200);
245:     const proofOfSend = context.dryRun ? true : await detectInviteProof(context.session.page);
246:     if (!proofOfSend) {
247:         throw new RetryableWorkerError('Proof-of-send non rilevato', 'NO_PROOF_OF_SEND');
248:     }
249: 
250:     await transitionLead(lead.id, 'INVITED', context.dryRun ? 'invite_dry_run' : 'invite_sent', {
251:         dryRun: context.dryRun,
252:         withNote: inviteResult.sentWithNote,
253:         withNoteSource: inviteResult.noteSource,
254:         variant: inviteResult.variant || null
255:     });
256:     await incrementDailyStat(context.localDate, 'invites_sent');
257:     await incrementListDailyStat(context.localDate, lead.list_name, 'invites_sent');
258:     // Cloud sync non-bloccante
259:     bridgeLeadStatus(lead.linkedin_url, 'INVITED', {
260:         invited_at: new Date().toISOString(),
261:         invite_prompt_variant: inviteResult.variant || null,
262:         invite_note_sent: inviteResult.sentWithNote ? 'yes' : 'no'
263:     });
264:     bridgeDailyStat(context.localDate, context.accountId, 'invites_sent');
265: }
````

## File: src/config.ts
````typescript
  1: import path from 'path';
  2: import fs from 'fs';
  3: import dotenv from 'dotenv';
  4: 
  5: const envPath = path.resolve(process.cwd(), '.env');
  6: if (fs.existsSync(envPath)) {
  7:     dotenv.config({ path: envPath });
  8: }
  9: 
 10: function parseIntEnv(name: string, fallback: number): number {
 11:     const raw = process.env[name];
 12:     if (!raw) return fallback;
 13:     const parsed = Number.parseInt(raw, 10);
 14:     return Number.isFinite(parsed) ? parsed : fallback;
 15: }
 16: 
 17: function parseFloatEnv(name: string, fallback: number): number {
 18:     const raw = process.env[name];
 19:     if (!raw) return fallback;
 20:     const parsed = Number.parseFloat(raw);
 21:     return Number.isFinite(parsed) ? parsed : fallback;
 22: }
 23: 
 24: function parseBoolEnv(name: string, defaultValue: boolean): boolean {
 25:     const val = process.env[name];
 26:     if (val === undefined || val === '') return defaultValue;
 27:     return val.toLowerCase() === 'true' || val === '1';
 28: }
 29: 
 30: function parseStringEnv(name: string, fallback: string = ''): string {
 31:     const raw = process.env[name];
 32:     if (raw === undefined) return fallback;
 33:     return raw.trim();
 34: }
 35: 
 36: function parseCsvEnv(name: string): string[] {
 37:     const raw = parseStringEnv(name);
 38:     if (!raw) return [];
 39:     return raw
 40:         .split(',')
 41:         .map((item) => item.trim())
 42:         .filter((item) => item.length > 0);
 43: }
 44: 
 45: function resolvePathValue(rawPath: string): string {
 46:     return path.isAbsolute(rawPath) ? rawPath : path.resolve(process.cwd(), rawPath);
 47: }
 48: 
 49: export type EventSyncSink = 'SUPABASE' | 'WEBHOOK' | 'NONE';
 50: 
 51: export interface AccountProfileConfig {
 52:     id: string;
 53:     sessionDir: string;
 54:     proxyUrl: string;
 55:     proxyUsername: string;
 56:     proxyPassword: string;
 57: }
 58: 
 59: function parseEventSyncSinkEnv(name: string, fallback: EventSyncSink): EventSyncSink {
 60:     const raw = parseStringEnv(name, fallback).toUpperCase();
 61:     if (raw === 'SUPABASE' || raw === 'WEBHOOK' || raw === 'NONE') {
 62:         return raw;
 63:     }
 64:     return fallback;
 65: }
 66: 
 67: function resolvePathFromEnv(name: string, fallbackRelativePath: string): string {
 68:     const raw = process.env[name];
 69:     if (!raw) {
 70:         return path.resolve(process.cwd(), fallbackRelativePath);
 71:     }
 72:     return path.isAbsolute(raw) ? raw : path.resolve(process.cwd(), raw);
 73: }
 74: 
 75: function parseAccountProfileFromEnv(slot: 1 | 2): AccountProfileConfig | null {
 76:     const sessionDirRaw = parseStringEnv(`ACCOUNT_${slot}_SESSION_DIR`);
 77:     if (!sessionDirRaw) {
 78:         return null;
 79:     }
 80: 
 81:     const fallbackId = `account${slot}`;
 82:     const id = parseStringEnv(`ACCOUNT_${slot}_ID`, fallbackId) || fallbackId;
 83:     return {
 84:         id,
 85:         sessionDir: resolvePathValue(sessionDirRaw),
 86:         proxyUrl: parseStringEnv(`ACCOUNT_${slot}_PROXY_URL`),
 87:         proxyUsername: parseStringEnv(`ACCOUNT_${slot}_PROXY_USERNAME`),
 88:         proxyPassword: parseStringEnv(`ACCOUNT_${slot}_PROXY_PASSWORD`),
 89:     };
 90: }
 91: 
 92: export interface AppConfig {
 93:     timezone: string;
 94:     headless: boolean;
 95:     dashboardAuthEnabled: boolean;
 96:     dashboardApiKey: string;
 97:     dashboardBasicUser: string;
 98:     dashboardBasicPassword: string;
 99:     dashboardTrustedIps: string[];
100:     workingHoursStart: number;
101:     workingHoursEnd: number;
102:     maxConcurrentJobs: number;
103:     jobStuckMinutes: number;
104:     retryMaxAttempts: number;
105:     retryBaseMs: number;
106:     workflowLoopIntervalMs: number;
107:     companyEnrichmentEnabled: boolean;
108:     companyEnrichmentBatch: number;
109:     companyEnrichmentMaxProfilesPerCompany: number;
110:     maxConsecutiveJobFailures: number;
111:     maxSelectorFailuresPerDay: number;
112:     maxRunErrorsPerDay: number;
113:     autoPauseMinutesOnFailureBurst: number;
114:     retentionDays: number;
115:     profileContextExtractionEnabled: boolean;
116:     softInviteCap: number;
117:     hardInviteCap: number;
118:     weeklyInviteLimit: number;
119:     softMsgCap: number;
120:     hardMsgCap: number;
121:     complianceEnforced: boolean;
122:     complianceMaxHardInviteCap: number;
123:     complianceMaxWeeklyInviteLimit: number;
124:     complianceMaxHardMsgCap: number;
125:     messageScheduleMinDelayHours: number;
126:     messageScheduleMaxDelayHours: number;
127:     riskWarnThreshold: number;
128:     riskStopThreshold: number;
129:     pendingRatioWarn: number;
130:     pendingRatioStop: number;
131:     adaptiveCapsEnabled: boolean;
132:     adaptiveCapsPendingWarn: number;
133:     adaptiveCapsPendingStop: number;
134:     adaptiveCapsBlockedWarn: number;
135:     adaptiveCapsMinFactor: number;
136:     adaptiveCapsWarnFactor: number;
137:     cooldownEnabled: boolean;
138:     cooldownWarnScore: number;
139:     cooldownHighScore: number;
140:     cooldownPendingThreshold: number;
141:     cooldownPendingHighThreshold: number;
142:     cooldownWarnMinutes: number;
143:     cooldownHighMinutes: number;
144:     noBurstEnabled: boolean;
145:     noBurstMinDelaySec: number;
146:     noBurstMaxDelaySec: number;
147:     noBurstLongBreakEvery: number;
148:     noBurstLongBreakMinSec: number;
149:     noBurstLongBreakMaxSec: number;
150:     autoSiteCheckEnabled: boolean;
151:     autoSiteCheckLimit: number;
152:     autoSiteCheckFix: boolean;
153:     autoSiteCheckIntervalHours: number;
154:     siteCheckStaleDays: number;
155:     postRunStateSyncEnabled: boolean;
156:     postRunStateSyncLimit: number;
157:     postRunStateSyncFix: boolean;
158:     selectorCanaryEnabled: boolean;
159:     outboxAlertBacklog: number;
160:     sessionDir: string;
161:     multiAccountEnabled: boolean;
162:     accountProfiles: AccountProfileConfig[];
163:     dbPath: string;
164:     allowSqliteInProduction: boolean;
165:     eventSyncSink: EventSyncSink;
166:     supabaseSyncEnabled: boolean;
167:     supabaseUrl: string;
168:     supabaseServiceRoleKey: string;
169:     supabaseSyncBatchSize: number;
170:     supabaseSyncIntervalMs: number;
171:     supabaseSyncMaxRetries: number;
172:     supabaseControlPlaneEnabled: boolean;
173:     supabaseControlPlaneSyncIntervalMs: number;
174:     supabaseControlPlaneMaxCampaigns: number;
175:     webhookSyncEnabled: boolean;
176:     webhookSyncUrl: string;
177:     webhookSyncSecret: string;
178:     webhookSyncBatchSize: number;
179:     webhookSyncTimeoutMs: number;
180:     webhookSyncMaxRetries: number;
181:     openaiApiKey: string;
182:     openaiBaseUrl: string;
183:     aiModel: string;
184:     aiAllowRemoteEndpoint: boolean;
185:     aiRequestTimeoutMs: number;
186:     aiPersonalizationEnabled: boolean;
187:     aiMessageMaxChars: number;
188:     aiGuardianEnabled: boolean;
189:     aiGuardianMinIntervalMinutes: number;
190:     aiGuardianPauseMinutes: number;
191:     telegramBotToken: string;
192:     telegramChatId: string;
193:     proxyUrl: string;
194:     proxyUsername: string;
195:     proxyPassword: string;
196:     proxyListPath: string;
197:     proxyFailureCooldownMinutes: number;
198:     proxyRotateEveryJobs: number;
199:     proxyRotateEveryMinutes: number;
200:     proxyHealthCheckTimeoutMs: number;
201:     proxyProviderApiEndpoint?: string;
202:     proxyProviderApiKey?: string;
203:     fingerprintApiEndpoint: string;
204: 
205:     // Hygiene settings (withdraw old pending invites)
206:     withdrawInvitesEnabled: boolean;
207:     pendingInviteMaxDays: number;
208:     inviteWithNote: boolean;
209:     inviteNoteMode: 'template' | 'ai';
210:     salesNavSyncEnabled: boolean;
211:     salesNavSyncListName: string;
212:     salesNavSyncListUrl: string;
213:     salesNavSyncMaxPages: number;
214:     salesNavSyncIntervalHours: number;
215:     salesNavSyncLimit: number;
216:     salesNavSyncAccountId: string;
217:     randomActivityEnabled: boolean;
218:     randomActivityProbability: number;
219:     randomActivityMaxActions: number;
220:     weekendPolicyEnabled: boolean;
221: }
222: 
223: const configuredAccountProfiles: AccountProfileConfig[] = [parseAccountProfileFromEnv(1), parseAccountProfileFromEnv(2)]
224:     .filter((profile): profile is AccountProfileConfig => profile !== null);
225: 
226: export const config: AppConfig = {
227:     timezone: process.env.TIMEZONE ?? 'Europe/Rome',
228:     headless: parseBoolEnv('HEADLESS', false),
229:     dashboardAuthEnabled: parseBoolEnv('DASHBOARD_AUTH_ENABLED', true),
230:     dashboardApiKey: parseStringEnv('DASHBOARD_API_KEY'),
231:     dashboardBasicUser: parseStringEnv('DASHBOARD_BASIC_USER'),
232:     dashboardBasicPassword: parseStringEnv('DASHBOARD_BASIC_PASSWORD'),
233:     dashboardTrustedIps: parseCsvEnv('DASHBOARD_TRUSTED_IPS'),
234:     workingHoursStart: parseIntEnv('HOUR_START', 9),
235:     workingHoursEnd: parseIntEnv('HOUR_END', 18),
236:     maxConcurrentJobs: Math.max(1, parseIntEnv('MAX_CONCURRENT_JOBS', 1)),
237:     jobStuckMinutes: Math.max(1, parseIntEnv('JOB_STUCK_MINUTES', 30)),
238:     retryMaxAttempts: Math.max(1, parseIntEnv('RETRY_MAX_ATTEMPTS', 3)),
239:     retryBaseMs: Math.max(100, parseIntEnv('RETRY_BASE_MS', 1200)),
240:     workflowLoopIntervalMs: Math.max(10_000, parseIntEnv('WORKFLOW_LOOP_INTERVAL_MS', 900000)),
241:     companyEnrichmentEnabled: parseBoolEnv('COMPANY_ENRICHMENT_ENABLED', true),
242:     companyEnrichmentBatch: Math.max(1, parseIntEnv('COMPANY_ENRICHMENT_BATCH', 5)),
243:     companyEnrichmentMaxProfilesPerCompany: Math.max(1, parseIntEnv('COMPANY_ENRICHMENT_MAX_PROFILES_PER_COMPANY', 3)),
244:     maxConsecutiveJobFailures: Math.max(1, parseIntEnv('MAX_CONSECUTIVE_JOB_FAILURES', 4)),
245:     maxSelectorFailuresPerDay: Math.max(1, parseIntEnv('MAX_SELECTOR_FAILURES_PER_DAY', 8)),
246:     maxRunErrorsPerDay: Math.max(1, parseIntEnv('MAX_RUN_ERRORS_PER_DAY', 20)),
247:     autoPauseMinutesOnFailureBurst: Math.max(1, parseIntEnv('AUTO_PAUSE_MINUTES_ON_FAILURE_BURST', 180)),
248:     retentionDays: Math.max(7, parseIntEnv('RETENTION_DAYS', 90)),
249:     profileContextExtractionEnabled: parseBoolEnv('PROFILE_CONTEXT_EXTRACTION_ENABLED', false),
250:     softInviteCap: Math.max(1, parseIntEnv('SOFT_INVITE_CAP', 25)),
251:     hardInviteCap: Math.max(1, parseIntEnv('HARD_INVITE_CAP', 35)),
252:     weeklyInviteLimit: Math.max(1, parseIntEnv('WEEKLY_INVITE_LIMIT', 120)),
253:     softMsgCap: Math.max(1, parseIntEnv('SOFT_MSG_CAP', 40)),
254:     hardMsgCap: Math.max(1, parseIntEnv('HARD_MSG_CAP', 60)),
255:     complianceEnforced: parseBoolEnv('COMPLIANCE_ENFORCED', true),
256:     complianceMaxHardInviteCap: Math.max(1, parseIntEnv('COMPLIANCE_MAX_HARD_INVITE_CAP', 20)),
257:     complianceMaxWeeklyInviteLimit: Math.max(1, parseIntEnv('COMPLIANCE_MAX_WEEKLY_INVITE_LIMIT', 100)),
258:     complianceMaxHardMsgCap: Math.max(1, parseIntEnv('COMPLIANCE_MAX_HARD_MSG_CAP', 40)),
259:     messageScheduleMinDelayHours: Math.max(0, parseIntEnv('MESSAGE_SCHEDULE_MIN_DELAY_HOURS', 0)),
260:     messageScheduleMaxDelayHours: Math.max(0, parseIntEnv('MESSAGE_SCHEDULE_MAX_DELAY_HOURS', 0)),
261:     riskWarnThreshold: parseIntEnv('RISK_WARN_THRESHOLD', 60),
262:     riskStopThreshold: parseIntEnv('RISK_STOP_THRESHOLD', 80),
263:     pendingRatioWarn: parseFloatEnv('PENDING_RATIO_WARN', 0.65),
264:     pendingRatioStop: parseFloatEnv('PENDING_RATIO_STOP', 0.8),
265:     adaptiveCapsEnabled: parseBoolEnv('ADAPTIVE_CAPS_ENABLED', true),
266:     adaptiveCapsPendingWarn: Math.min(1, Math.max(0, parseFloatEnv('ADAPTIVE_CAPS_PENDING_WARN', 0.55))),
267:     adaptiveCapsPendingStop: Math.min(1, Math.max(0, parseFloatEnv('ADAPTIVE_CAPS_PENDING_STOP', 0.72))),
268:     adaptiveCapsBlockedWarn: Math.min(1, Math.max(0, parseFloatEnv('ADAPTIVE_CAPS_BLOCKED_WARN', 0.25))),
269:     adaptiveCapsMinFactor: Math.min(1, Math.max(0.05, parseFloatEnv('ADAPTIVE_CAPS_MIN_FACTOR', 0.25))),
270:     adaptiveCapsWarnFactor: Math.min(1, Math.max(0.05, parseFloatEnv('ADAPTIVE_CAPS_WARN_FACTOR', 0.85))),
271:     cooldownEnabled: parseBoolEnv('COOLDOWN_ENABLED', true),
272:     cooldownWarnScore: Math.max(0, parseIntEnv('COOLDOWN_WARN_SCORE', 68)),
273:     cooldownHighScore: Math.max(0, parseIntEnv('COOLDOWN_HIGH_SCORE', 75)),
274:     cooldownPendingThreshold: Math.min(1, Math.max(0, parseFloatEnv('COOLDOWN_PENDING_THRESHOLD', 0.65))),
275:     cooldownPendingHighThreshold: Math.min(1, Math.max(0, parseFloatEnv('COOLDOWN_PENDING_HIGH_THRESHOLD', 0.75))),
276:     cooldownWarnMinutes: Math.max(10, parseIntEnv('COOLDOWN_WARN_MINUTES', 2880)),
277:     cooldownHighMinutes: Math.max(10, parseIntEnv('COOLDOWN_HIGH_MINUTES', 4320)),
278:     noBurstEnabled: parseBoolEnv('NO_BURST_ENABLED', true),
279:     noBurstMinDelaySec: Math.max(0, parseIntEnv('NO_BURST_MIN_DELAY_SEC', 8)),
280:     noBurstMaxDelaySec: Math.max(0, parseIntEnv('NO_BURST_MAX_DELAY_SEC', 25)),
281:     noBurstLongBreakEvery: Math.max(0, parseIntEnv('NO_BURST_LONG_BREAK_EVERY', 7)),
282:     noBurstLongBreakMinSec: Math.max(0, parseIntEnv('NO_BURST_LONG_BREAK_MIN_SEC', 120)),
283:     noBurstLongBreakMaxSec: Math.max(0, parseIntEnv('NO_BURST_LONG_BREAK_MAX_SEC', 360)),
284:     autoSiteCheckEnabled: parseBoolEnv('AUTO_SITE_CHECK_ENABLED', true),
285:     autoSiteCheckLimit: Math.max(1, parseIntEnv('AUTO_SITE_CHECK_LIMIT', 20)),
286:     autoSiteCheckFix: parseBoolEnv('AUTO_SITE_CHECK_FIX', true),
287:     autoSiteCheckIntervalHours: Math.max(1, parseIntEnv('AUTO_SITE_CHECK_INTERVAL_HOURS', 24)),
288:     siteCheckStaleDays: Math.max(0, parseIntEnv('SITE_CHECK_STALE_DAYS', 2)),
289:     postRunStateSyncEnabled: parseBoolEnv('POST_RUN_STATE_SYNC_ENABLED', true),
290:     postRunStateSyncLimit: Math.max(1, parseIntEnv('POST_RUN_STATE_SYNC_LIMIT', 8)),
291:     postRunStateSyncFix: parseBoolEnv('POST_RUN_STATE_SYNC_FIX', true),
292:     selectorCanaryEnabled: parseBoolEnv('SELECTOR_CANARY_ENABLED', true),
293:     outboxAlertBacklog: Math.max(1, parseIntEnv('OUTBOX_ALERT_BACKLOG', 1000)),
294:     sessionDir: resolvePathFromEnv('SESSION_DIR', path.join('data', 'session')),
295:     multiAccountEnabled: parseBoolEnv('MULTI_ACCOUNT_ENABLED', configuredAccountProfiles.length > 1),
296:     accountProfiles: configuredAccountProfiles,
297:     dbPath: resolvePathFromEnv('DB_PATH', path.join('data', 'linkedin_bot.sqlite')),
298:     allowSqliteInProduction: parseBoolEnv('ALLOW_SQLITE_IN_PRODUCTION', false),
299:     eventSyncSink: parseEventSyncSinkEnv('EVENT_SYNC_SINK', 'SUPABASE'),
300:     supabaseSyncEnabled: parseBoolEnv('SUPABASE_SYNC_ENABLED', true),
301:     supabaseUrl: parseStringEnv('SUPABASE_URL'),
302:     supabaseServiceRoleKey: parseStringEnv('SUPABASE_SERVICE_ROLE_KEY'),
303:     supabaseSyncBatchSize: Math.max(1, parseIntEnv('SUPABASE_SYNC_BATCH_SIZE', 100)),
304:     supabaseSyncIntervalMs: Math.max(1000, parseIntEnv('SUPABASE_SYNC_INTERVAL_MS', 15000)),
305:     supabaseSyncMaxRetries: Math.max(1, parseIntEnv('SUPABASE_SYNC_MAX_RETRIES', 8)),
306:     supabaseControlPlaneEnabled: parseBoolEnv('SUPABASE_CONTROL_PLANE_ENABLED', false),
307:     supabaseControlPlaneSyncIntervalMs: Math.max(1000, parseIntEnv('SUPABASE_CONTROL_PLANE_SYNC_INTERVAL_MS', 300000)),
308:     supabaseControlPlaneMaxCampaigns: Math.max(1, parseIntEnv('SUPABASE_CONTROL_PLANE_MAX_CAMPAIGNS', 500)),
309:     webhookSyncEnabled: parseBoolEnv('WEBHOOK_SYNC_ENABLED', false),
310:     webhookSyncUrl: parseStringEnv('WEBHOOK_SYNC_URL'),
311:     webhookSyncSecret: parseStringEnv('WEBHOOK_SYNC_SECRET'),
312:     webhookSyncBatchSize: Math.max(1, parseIntEnv('WEBHOOK_SYNC_BATCH_SIZE', 100)),
313:     webhookSyncTimeoutMs: Math.max(1000, parseIntEnv('WEBHOOK_SYNC_TIMEOUT_MS', 10000)),
314:     webhookSyncMaxRetries: Math.max(1, parseIntEnv('WEBHOOK_SYNC_MAX_RETRIES', 8)),
315:     openaiApiKey: parseStringEnv('OPENAI_API_KEY'),
316:     openaiBaseUrl: parseStringEnv('OPENAI_BASE_URL', 'http://127.0.0.1:11434/v1'),
317:     aiModel: parseStringEnv('AI_MODEL', 'llama3.1:8b'),
318:     aiAllowRemoteEndpoint: parseBoolEnv('AI_ALLOW_REMOTE_ENDPOINT', false),
319:     aiRequestTimeoutMs: Math.max(1000, parseIntEnv('AI_REQUEST_TIMEOUT_MS', 12000)),
320:     aiPersonalizationEnabled: parseBoolEnv('AI_PERSONALIZATION_ENABLED', false),
321:     aiMessageMaxChars: Math.max(120, parseIntEnv('AI_MESSAGE_MAX_CHARS', 450)),
322:     aiGuardianEnabled: parseBoolEnv('AI_GUARDIAN_ENABLED', false),
323:     aiGuardianMinIntervalMinutes: Math.max(1, parseIntEnv('AI_GUARDIAN_MIN_INTERVAL_MINUTES', 60)),
324:     aiGuardianPauseMinutes: Math.max(10, parseIntEnv('AI_GUARDIAN_PAUSE_MINUTES', 180)),
325:     telegramBotToken: parseStringEnv('TELEGRAM_BOT_TOKEN'),
326:     telegramChatId: parseStringEnv('TELEGRAM_CHAT_ID'),
327:     proxyUrl: parseStringEnv('PROXY_URL'),
328:     proxyUsername: parseStringEnv('PROXY_USERNAME'),
329:     proxyPassword: parseStringEnv('PROXY_PASSWORD'),
330:     proxyListPath: parseStringEnv('PROXY_LIST'),
331:     proxyFailureCooldownMinutes: Math.max(1, parseIntEnv('PROXY_FAILURE_COOLDOWN_MINUTES', 30)),
332:     proxyRotateEveryJobs: Math.max(0, parseIntEnv('PROXY_ROTATE_EVERY_JOBS', 0)),
333:     proxyRotateEveryMinutes: Math.max(0, parseIntEnv('PROXY_ROTATE_EVERY_MINUTES', 0)),
334:     proxyHealthCheckTimeoutMs: Math.max(1000, parseIntEnv('PROXY_HEALTH_CHECK_TIMEOUT_MS', 5000)),
335:     proxyProviderApiEndpoint: parseStringEnv('PROXY_PROVIDER_API_ENDPOINT'),
336:     proxyProviderApiKey: parseStringEnv('PROXY_PROVIDER_API_KEY'),
337:     fingerprintApiEndpoint: parseStringEnv('FINGERPRINT_API_ENDPOINT'),
338: 
339:     withdrawInvitesEnabled: parseBoolEnv('WITHDRAW_INVITES_ENABLED', true),
340:     pendingInviteMaxDays: parseIntEnv('PENDING_INVITE_MAX_DAYS', 30),
341:     inviteWithNote: parseBoolEnv('INVITE_WITH_NOTE', false),
342:     inviteNoteMode: (parseStringEnv('INVITE_NOTE_MODE', 'template') === 'ai' ? 'ai' : 'template') as 'template' | 'ai',
343:     salesNavSyncEnabled: parseBoolEnv('SALESNAV_SYNC_ENABLED', false),
344:     salesNavSyncListName: parseStringEnv('SALESNAV_SYNC_LIST_NAME', 'default'),
345:     salesNavSyncListUrl: parseStringEnv('SALESNAV_SYNC_LIST_URL'),
346:     salesNavSyncMaxPages: Math.max(1, parseIntEnv('SALESNAV_SYNC_MAX_PAGES', 3)),
347:     salesNavSyncIntervalHours: Math.max(1, parseIntEnv('SALESNAV_SYNC_INTERVAL_HOURS', 24)),
348:     salesNavSyncLimit: Math.max(1, parseIntEnv('SALESNAV_SYNC_LIMIT', 30)),
349:     salesNavSyncAccountId: parseStringEnv('SALESNAV_SYNC_ACCOUNT_ID'),
350:     randomActivityEnabled: parseBoolEnv('RANDOM_ACTIVITY_ENABLED', false),
351:     randomActivityProbability: Math.min(1, Math.max(0, parseFloatEnv('RANDOM_ACTIVITY_PROBABILITY', 0.15))),
352:     randomActivityMaxActions: Math.max(1, parseIntEnv('RANDOM_ACTIVITY_MAX_ACTIONS', 3)),
353:     weekendPolicyEnabled: parseBoolEnv('WEEKEND_POLICY_ENABLED', true),
354: };
355: 
356: // Retrocompatibilit√† con vecchi moduli ancora presenti nel repository.
357: export const legacyLimits = {
358:     dailyInviteLimit: config.hardInviteCap,
359:     weeklyInviteLimit: config.weeklyInviteLimit,
360:     dailyMsgLimit: config.hardMsgCap,
361: };
362: 
363: export function isWorkingHour(now: Date = new Date()): boolean {
364:     if (config.weekendPolicyEnabled) {
365:         const day = getDayInTimezone(now, config.timezone);
366:         if (day === 0 || day === 6) {
367:             return false;
368:         }
369:     }
370:     const hour = getHourInTimezone(now, config.timezone);
371:     return hour >= config.workingHoursStart && hour < config.workingHoursEnd;
372: }
373: 
374: export function getLocalDateString(now: Date = new Date(), timezone: string = config.timezone): string {
375:     const formatter = new Intl.DateTimeFormat('en-CA', {
376:         timeZone: timezone,
377:         year: 'numeric',
378:         month: '2-digit',
379:         day: '2-digit',
380:     });
381:     return formatter.format(now);
382: }
383: 
384: export function getHourInTimezone(now: Date, timezone: string): number {
385:     const formatter = new Intl.DateTimeFormat('en-GB', {
386:         timeZone: timezone,
387:         hour: '2-digit',
388:         hour12: false,
389:     });
390:     const formatted = formatter.format(now);
391:     return Number.parseInt(formatted, 10);
392: }
393: 
394: export function getDayInTimezone(now: Date, timezone: string): number {
395:     const formatter = new Intl.DateTimeFormat('en-US', {
396:         timeZone: timezone,
397:         weekday: 'short',
398:     });
399:     const formatted = formatter.format(now);
400:     const map: Record<string, number> = { 'Sun': 0, 'Mon': 1, 'Tue': 2, 'Wed': 3, 'Thu': 4, 'Fri': 5, 'Sat': 6 };
401:     return map[formatted] ?? now.getDay();
402: }
403: 
404: export function getWeekStartDate(now: Date = new Date(), timezone: string = config.timezone): string {
405:     const localDate = getLocalDateString(now, timezone);
406:     const [year, month, day] = localDate.split('-').map((value) => Number.parseInt(value, 10));
407:     const anchor = new Date(Date.UTC(year, month - 1, day));
408:     const weekday = anchor.getUTCDay();
409:     const delta = weekday === 0 ? -6 : 1 - weekday;
410:     anchor.setUTCDate(anchor.getUTCDate() + delta);
411:     const anchorYear = anchor.getUTCFullYear();
412:     const anchorMonth = String(anchor.getUTCMonth() + 1).padStart(2, '0');
413:     const anchorDay = String(anchor.getUTCDate()).padStart(2, '0');
414:     return `${anchorYear}-${anchorMonth}-${anchorDay}`;
415: }
````

## File: src/core/repositories.ts
````typescript
   1: import { Database } from 'sqlite';
   2: import { getDatabase } from '../db';
   3: import {
   4:     JobRecord,
   5:     JobStatus,
   6:     JobType,
   7:     LeadRecord,
   8:     LeadStatus,
   9:     OutboxEventRecord,
  10:     RiskInputs,
  11:     RunStatus,
  12:     ABTestStats,
  13: } from '../types/domain';
  14: import { normalizeLinkedInUrl } from '../linkedinUrl';
  15: import type { CloudAccount, CloudLeadUpsert } from '../cloud/supabaseDataClient';
  16: 
  17: function parsePayload<T>(raw: string): T {
  18:     try {
  19:         return JSON.parse(raw) as T;
  20:     } catch {
  21:         return {} as T;
  22:     }
  23: }
  24: 
  25: async function withTransaction<T>(database: Database, callback: () => Promise<T>): Promise<T> {
  26:     await database.exec('BEGIN IMMEDIATE');
  27:     try {
  28:         const result = await callback();
  29:         await database.exec('COMMIT');
  30:         return result;
  31:     } catch (error) {
  32:         await database.exec('ROLLBACK');
  33:         throw error;
  34:     }
  35: }
  36: 
  37: function normalizeLegacyStatus(status: LeadStatus): LeadStatus {
  38:     if (status === 'PENDING') {
  39:         return 'READY_INVITE';
  40:     }
  41:     return status;
  42: }
  43: 
  44: export async function ensureLeadList(listName: string): Promise<void> {
  45:     const db = await getDatabase();
  46:     await db.run(`INSERT OR IGNORE INTO lead_lists (name, source) VALUES (?, 'import')`, [listName]);
  47: }
  48: 
  49: export async function syncLeadListsFromLeads(): Promise<void> {
  50:     const db = await getDatabase();
  51:     await db.run(
  52:         `
  53:         INSERT OR IGNORE INTO lead_lists (name, source)
  54:         SELECT DISTINCT list_name, 'legacy'
  55:         FROM leads
  56:         WHERE TRIM(COALESCE(list_name, '')) <> ''
  57:     `
  58:     );
  59: }
  60: 
  61: export async function listLeadCampaignConfigs(onlyActive: boolean = false): Promise<LeadListCampaignConfig[]> {
  62:     const db = await getDatabase();
  63:     const rows = onlyActive
  64:         ? await db.all<LeadListRow[]>(
  65:             `
  66:             SELECT name, source, is_active, priority, daily_invite_cap, daily_message_cap, created_at
  67:             FROM lead_lists
  68:             WHERE is_active = 1
  69:             ORDER BY priority ASC, created_at ASC, name ASC
  70:         `
  71:         )
  72:         : await db.all<LeadListRow[]>(
  73:             `
  74:             SELECT name, source, is_active, priority, daily_invite_cap, daily_message_cap, created_at
  75:             FROM lead_lists
  76:             ORDER BY is_active DESC, priority ASC, created_at ASC, name ASC
  77:         `
  78:         );
  79: 
  80:     return rows.map(normalizeLeadListRow);
  81: }
  82: 
  83: export async function updateLeadCampaignConfig(listName: string, patch: UpdateLeadListCampaignInput): Promise<LeadListCampaignConfig> {
  84:     await ensureLeadList(listName);
  85: 
  86:     const setParts: string[] = [];
  87:     const params: unknown[] = [];
  88: 
  89:     if (Object.prototype.hasOwnProperty.call(patch, 'isActive')) {
  90:         setParts.push('is_active = ?');
  91:         params.push(patch.isActive ? 1 : 0);
  92:     }
  93:     if (Object.prototype.hasOwnProperty.call(patch, 'priority')) {
  94:         setParts.push('priority = ?');
  95:         params.push(Math.max(1, patch.priority ?? 100));
  96:     }
  97:     if (Object.prototype.hasOwnProperty.call(patch, 'dailyInviteCap')) {
  98:         setParts.push('daily_invite_cap = ?');
  99:         params.push(patch.dailyInviteCap === null ? null : Math.max(0, patch.dailyInviteCap ?? 0));
 100:     }
 101:     if (Object.prototype.hasOwnProperty.call(patch, 'dailyMessageCap')) {
 102:         setParts.push('daily_message_cap = ?');
 103:         params.push(patch.dailyMessageCap === null ? null : Math.max(0, patch.dailyMessageCap ?? 0));
 104:     }
 105: 
 106:     if (setParts.length > 0) {
 107:         const db = await getDatabase();
 108:         await db.run(
 109:             `
 110:             UPDATE lead_lists
 111:             SET ${setParts.join(', ')}
 112:             WHERE name = ?
 113:         `,
 114:             [...params, listName]
 115:         );
 116:     }
 117: 
 118:     const configs = await listLeadCampaignConfigs(false);
 119:     const updated = configs.find((config) => config.name === listName);
 120:     if (!updated) {
 121:         throw new Error(`Configurazione lista ${listName} non trovata dopo update.`);
 122:     }
 123:     return updated;
 124: }
 125: 
 126: export async function applyControlPlaneCampaignConfigs(
 127:     configs: ControlPlaneCampaignConfigInput[]
 128: ): Promise<ApplyControlPlaneCampaignResult> {
 129:     const result: ApplyControlPlaneCampaignResult = {
 130:         fetched: configs.length,
 131:         applied: 0,
 132:         created: 0,
 133:         updated: 0,
 134:         unchanged: 0,
 135:         skippedInvalid: 0,
 136:     };
 137: 
 138:     if (configs.length === 0) {
 139:         return result;
 140:     }
 141: 
 142:     const db = await getDatabase();
 143:     await withTransaction(db, async () => {
 144:         for (const configItem of configs) {
 145:             const listName = configItem.name.trim();
 146:             if (!listName) {
 147:                 result.skippedInvalid += 1;
 148:                 continue;
 149:             }
 150: 
 151:             const nextIsActive = configItem.isActive ? 1 : 0;
 152:             const nextPriority = Math.max(1, Math.floor(configItem.priority));
 153:             const nextInviteCap = configItem.dailyInviteCap === null ? null : Math.max(0, Math.floor(configItem.dailyInviteCap));
 154:             const nextMessageCap = configItem.dailyMessageCap === null ? null : Math.max(0, Math.floor(configItem.dailyMessageCap));
 155: 
 156:             const existing = await db.get<LeadListRow>(
 157:                 `
 158:                 SELECT name, source, is_active, priority, daily_invite_cap, daily_message_cap, created_at
 159:                 FROM lead_lists
 160:                 WHERE name = ?
 161:                 LIMIT 1
 162:             `,
 163:                 [listName]
 164:             );
 165: 
 166:             if (!existing) {
 167:                 await db.run(
 168:                     `
 169:                     INSERT INTO lead_lists (name, source, is_active, priority, daily_invite_cap, daily_message_cap)
 170:                     VALUES (?, 'control_plane', ?, ?, ?, ?)
 171:                 `,
 172:                     [listName, nextIsActive, nextPriority, nextInviteCap, nextMessageCap]
 173:                 );
 174:                 result.created += 1;
 175:                 result.applied += 1;
 176:                 continue;
 177:             }
 178: 
 179:             const changed = existing.source !== 'control_plane'
 180:                 || existing.is_active !== nextIsActive
 181:                 || existing.priority !== nextPriority
 182:                 || existing.daily_invite_cap !== nextInviteCap
 183:                 || existing.daily_message_cap !== nextMessageCap;
 184: 
 185:             if (!changed) {
 186:                 result.unchanged += 1;
 187:                 continue;
 188:             }
 189: 
 190:             await db.run(
 191:                 `
 192:                 UPDATE lead_lists
 193:                 SET source = 'control_plane',
 194:                     is_active = ?,
 195:                     priority = ?,
 196:                     daily_invite_cap = ?,
 197:                     daily_message_cap = ?
 198:                 WHERE name = ?
 199:             `,
 200:                 [nextIsActive, nextPriority, nextInviteCap, nextMessageCap, listName]
 201:             );
 202:             result.updated += 1;
 203:             result.applied += 1;
 204:         }
 205:     });
 206: 
 207:     return result;
 208: }
 209: 
 210: export async function upsertSalesNavList(name: string, url: string): Promise<SalesNavListRecord> {
 211:     const db = await getDatabase();
 212:     const normalizedName = name.trim();
 213:     const normalizedUrl = normalizeLinkedInUrl(url.trim());
 214:     if (!normalizedName || !normalizedUrl) {
 215:         throw new Error('upsertSalesNavList: name/url mancanti');
 216:     }
 217: 
 218:     await db.run(
 219:         `
 220:         INSERT INTO salesnav_lists (name, url)
 221:         VALUES (?, ?)
 222:         ON CONFLICT(name) DO UPDATE SET
 223:             url = excluded.url,
 224:             updated_at = CURRENT_TIMESTAMP
 225:     `,
 226:         [normalizedName, normalizedUrl]
 227:     );
 228: 
 229:     const row = await db.get<SalesNavListRecord>(
 230:         `SELECT id, name, url, last_synced_at, created_at, updated_at FROM salesnav_lists WHERE name = ?`,
 231:         [normalizedName]
 232:     );
 233:     if (!row) {
 234:         throw new Error(`Lista SalesNav non trovata dopo upsert: ${normalizedName}`);
 235:     }
 236:     return row;
 237: }
 238: 
 239: export async function markSalesNavListSynced(listId: number): Promise<void> {
 240:     const db = await getDatabase();
 241:     await db.run(
 242:         `
 243:         UPDATE salesnav_lists
 244:         SET last_synced_at = CURRENT_TIMESTAMP,
 245:             updated_at = CURRENT_TIMESTAMP
 246:         WHERE id = ?
 247:     `,
 248:         [listId]
 249:     );
 250: }
 251: 
 252: export async function linkLeadToSalesNavList(listId: number, leadId: number): Promise<void> {
 253:     const db = await getDatabase();
 254:     await db.run(
 255:         `
 256:         INSERT OR IGNORE INTO salesnav_list_items (list_id, lead_id)
 257:         VALUES (?, ?)
 258:     `,
 259:         [listId, leadId]
 260:     );
 261: }
 262: 
 263: export async function listSalesNavLists(limit: number = 200): Promise<SalesNavListSummary[]> {
 264:     const db = await getDatabase();
 265:     const safeLimit = Math.max(1, limit);
 266:     return db.all<SalesNavListSummary[]>(
 267:         `
 268:         SELECT
 269:             l.id,
 270:             l.name,
 271:             l.url,
 272:             l.last_synced_at,
 273:             l.created_at,
 274:             l.updated_at,
 275:             COUNT(i.id) as leads_count
 276:         FROM salesnav_lists l
 277:         LEFT JOIN salesnav_list_items i ON i.list_id = l.id
 278:         GROUP BY l.id, l.name, l.url, l.last_synced_at, l.created_at, l.updated_at
 279:         ORDER BY
 280:             CASE WHEN l.last_synced_at IS NULL THEN 0 ELSE 1 END ASC,
 281:             l.last_synced_at ASC,
 282:             l.name ASC
 283:         LIMIT ?
 284:     `,
 285:         [safeLimit]
 286:     );
 287: }
 288: 
 289: export async function getSalesNavListByName(name: string): Promise<SalesNavListRecord | null> {
 290:     const db = await getDatabase();
 291:     const normalizedName = name.trim();
 292:     if (!normalizedName) return null;
 293:     const row = await db.get<SalesNavListRecord>(
 294:         `SELECT id, name, url, last_synced_at, created_at, updated_at FROM salesnav_lists WHERE name = ? LIMIT 1`,
 295:         [normalizedName]
 296:     );
 297:     return row ?? null;
 298: }
 299: 
 300: export interface AddLeadInput {
 301:     accountName: string;
 302:     firstName: string;
 303:     lastName: string;
 304:     jobTitle: string;
 305:     website: string;
 306:     linkedinUrl: string;
 307:     listName: string;
 308:     leadScore?: number | null;
 309:     confidenceScore?: number | null;
 310:     status?: LeadStatus;
 311: }
 312: 
 313: export interface UpsertSalesNavigatorLeadInput {
 314:     accountName: string;
 315:     firstName: string;
 316:     lastName: string;
 317:     jobTitle: string;
 318:     website: string;
 319:     linkedinUrl: string;
 320:     listName: string;
 321:     leadScore?: number | null;
 322:     confidenceScore?: number | null;
 323: }
 324: 
 325: export interface UpsertSalesNavigatorLeadResult {
 326:     leadId: number;
 327:     action: 'inserted' | 'updated' | 'unchanged';
 328: }
 329: 
 330: export interface SalesNavListRecord {
 331:     id: number;
 332:     name: string;
 333:     url: string;
 334:     last_synced_at: string | null;
 335:     created_at: string;
 336:     updated_at: string;
 337: }
 338: 
 339: export interface SalesNavListSummary extends SalesNavListRecord {
 340:     leads_count: number;
 341: }
 342: 
 343: interface LeadListRow {
 344:     name: string;
 345:     source: string;
 346:     is_active: number;
 347:     priority: number;
 348:     daily_invite_cap: number | null;
 349:     daily_message_cap: number | null;
 350:     created_at: string;
 351: }
 352: 
 353: export interface LeadListCampaignConfig {
 354:     name: string;
 355:     source: string;
 356:     isActive: boolean;
 357:     priority: number;
 358:     dailyInviteCap: number | null;
 359:     dailyMessageCap: number | null;
 360:     createdAt: string;
 361: }
 362: 
 363: export interface UpdateLeadListCampaignInput {
 364:     isActive?: boolean;
 365:     priority?: number;
 366:     dailyInviteCap?: number | null;
 367:     dailyMessageCap?: number | null;
 368: }
 369: 
 370: export interface ControlPlaneCampaignConfigInput {
 371:     name: string;
 372:     isActive: boolean;
 373:     priority: number;
 374:     dailyInviteCap: number | null;
 375:     dailyMessageCap: number | null;
 376: }
 377: 
 378: export interface ApplyControlPlaneCampaignResult {
 379:     fetched: number;
 380:     applied: number;
 381:     created: number;
 382:     updated: number;
 383:     unchanged: number;
 384:     skippedInvalid: number;
 385: }
 386: 
 387: export interface AddCompanyTargetInput {
 388:     listName: string;
 389:     accountName: string;
 390:     website: string;
 391:     sourceFile?: string | null;
 392: }
 393: 
 394: export type CompanyTargetStatus = 'NEW' | 'ENRICHED' | 'NO_MATCH' | 'ERROR';
 395: 
 396: export interface CompanyTargetRecord {
 397:     id: number;
 398:     list_name: string;
 399:     account_name: string;
 400:     website: string;
 401:     source_file: string | null;
 402:     status: CompanyTargetStatus;
 403:     attempts: number;
 404:     last_error: string | null;
 405:     processed_at: string | null;
 406:     created_at: string;
 407:     updated_at: string;
 408: }
 409: 
 410: export interface DailyStatsSnapshot {
 411:     date: string;
 412:     invitesSent: number;
 413:     messagesSent: number;
 414:     challengesCount: number;
 415:     selectorFailures: number;
 416:     runErrors: number;
 417: }
 418: 
 419: export interface JobStatusCounts {
 420:     QUEUED: number;
 421:     RUNNING: number;
 422:     SUCCEEDED: number;
 423:     FAILED: number;
 424:     DEAD_LETTER: number;
 425:     PAUSED: number;
 426: }
 427: 
 428: export interface AutomationPauseState {
 429:     paused: boolean;
 430:     pausedUntil: string | null;
 431:     reason: string | null;
 432:     remainingSeconds: number | null;
 433: }
 434: 
 435: export interface PrivacyCleanupStats {
 436:     runLogs: number;
 437:     jobAttempts: number;
 438:     leadEvents: number;
 439:     messageHistory: number;
 440:     deliveredOutboxEvents: number;
 441:     resolvedIncidents: number;
 442:     staleListMemberships: number;
 443:     staleLeadEvents: number;
 444:     staleMessageHistory: number;
 445:     staleLeads: number;
 446: }
 447: 
 448: export interface ListLeadStatusCount {
 449:     list_name: string;
 450:     status: LeadStatus;
 451:     total: number;
 452: }
 453: 
 454: export interface RuntimeLockRecord {
 455:     lock_key: string;
 456:     owner_id: string;
 457:     acquired_at: string;
 458:     heartbeat_at: string;
 459:     expires_at: string;
 460:     metadata_json: string;
 461:     updated_at: string;
 462: }
 463: 
 464: export interface AcquireRuntimeLockResult {
 465:     acquired: boolean;
 466:     lock: RuntimeLockRecord | null;
 467: }
 468: 
 469: function normalizeLeadListRow(row: LeadListRow): LeadListCampaignConfig {
 470:     return {
 471:         name: row.name,
 472:         source: row.source,
 473:         isActive: row.is_active === 1,
 474:         priority: row.priority,
 475:         dailyInviteCap: row.daily_invite_cap,
 476:         dailyMessageCap: row.daily_message_cap,
 477:         createdAt: row.created_at,
 478:     };
 479: }
 480: 
 481: export async function addLead(input: AddLeadInput): Promise<boolean> {
 482:     const db = await getDatabase();
 483:     await ensureLeadList(input.listName);
 484: 
 485:     const result = await db.run(
 486:         `
 487:         INSERT OR IGNORE INTO leads
 488:             (account_name, first_name, last_name, job_title, website, linkedin_url, status, list_name, lead_score, confidence_score)
 489:         VALUES (?, ?, ?, ?, ?, ?, COALESCE(?, 'NEW'), ?, ?, ?)
 490:     `,
 491:         [
 492:             input.accountName,
 493:             input.firstName,
 494:             input.lastName,
 495:             input.jobTitle,
 496:             input.website,
 497:             input.linkedinUrl,
 498:             input.status ?? null,
 499:             input.listName,
 500:             input.leadScore ?? null,
 501:             input.confidenceScore ?? null,
 502:         ]
 503:     );
 504: 
 505:     // Mantiene la relazione lista<->lead anche quando il lead esiste gi√†.
 506:     const leadRow = await db.get<{ id: number }>(`SELECT id FROM leads WHERE linkedin_url = ?`, [input.linkedinUrl]);
 507:     const listRow = await db.get<{ id: number }>(`SELECT id FROM lead_lists WHERE name = ?`, [input.listName]);
 508:     if (leadRow?.id && listRow?.id) {
 509:         await db.run(`INSERT OR IGNORE INTO list_leads (list_id, lead_id) VALUES (?, ?)`, [listRow.id, leadRow.id]);
 510:     }
 511: 
 512:     return (result.changes ?? 0) > 0;
 513: }
 514: 
 515: function normalizeTextValue(value: string): string {
 516:     return (value ?? '').trim();
 517: }
 518: 
 519: function mergedLeadValue(current: string, incoming: string): string {
 520:     const normalizedIncoming = normalizeTextValue(incoming);
 521:     if (!normalizedIncoming) {
 522:         return current;
 523:     }
 524:     if (normalizeTextValue(current) === normalizedIncoming) {
 525:         return current;
 526:     }
 527:     return normalizedIncoming;
 528: }
 529: 
 530: export async function getLeadByLinkedinUrl(linkedinUrl: string): Promise<LeadRecord | null> {
 531:     const db = await getDatabase();
 532:     const normalizedUrl = normalizeLinkedInUrl(linkedinUrl);
 533:     const lead = await db.get<LeadRecord>(`SELECT * FROM leads WHERE linkedin_url = ?`, [normalizedUrl]);
 534:     if (!lead) return null;
 535:     lead.status = normalizeLegacyStatus(lead.status);
 536:     return lead;
 537: }
 538: 
 539: export async function upsertSalesNavigatorLead(input: UpsertSalesNavigatorLeadInput): Promise<UpsertSalesNavigatorLeadResult> {
 540:     const db = await getDatabase();
 541:     const listName = normalizeTextValue(input.listName) || 'default';
 542:     const linkedinUrl = normalizeLinkedInUrl(input.linkedinUrl);
 543: 
 544:     return withTransaction(db, async () => {
 545:         await ensureLeadList(listName);
 546:         const existing = await db.get<LeadRecord>(`SELECT * FROM leads WHERE linkedin_url = ?`, [linkedinUrl]);
 547: 
 548:         const normalizedAccountName = normalizeTextValue(input.accountName);
 549:         const normalizedFirstName = normalizeTextValue(input.firstName);
 550:         const normalizedLastName = normalizeTextValue(input.lastName);
 551:         const normalizedJobTitle = normalizeTextValue(input.jobTitle);
 552:         const normalizedWebsite = normalizeTextValue(input.website);
 553: 
 554:         let leadId = 0;
 555:         let action: UpsertSalesNavigatorLeadResult['action'] = 'unchanged';
 556: 
 557:         if (!existing) {
 558:             const insertResult = await db.run(
 559:                 `
 560:                 INSERT INTO leads
 561:                     (account_name, first_name, last_name, job_title, website, linkedin_url, status, list_name, about, experience, invite_prompt_variant, lead_score, confidence_score)
 562:                 VALUES (?, ?, ?, ?, ?, ?, 'NEW', ?, NULL, NULL, NULL, ?, ?)
 563:             `,
 564:                 [
 565:                     normalizedAccountName,
 566:                     normalizedFirstName,
 567:                     normalizedLastName,
 568:                     normalizedJobTitle,
 569:                     normalizedWebsite,
 570:                     linkedinUrl,
 571:                     listName,
 572:                     input.leadScore ?? null,
 573:                     input.confidenceScore ?? null,
 574:                 ]
 575:             );
 576:             leadId = insertResult.lastID ?? 0;
 577:             action = 'inserted';
 578:         } else {
 579:             leadId = existing.id;
 580:             const nextAccountName = mergedLeadValue(existing.account_name, normalizedAccountName);
 581:             const nextFirstName = mergedLeadValue(existing.first_name, normalizedFirstName);
 582:             const nextLastName = mergedLeadValue(existing.last_name, normalizedLastName);
 583:             const nextJobTitle = mergedLeadValue(existing.job_title, normalizedJobTitle);
 584:             const nextWebsite = normalizeTextValue(existing.website)
 585:                 ? existing.website
 586:                 : mergedLeadValue(existing.website, normalizedWebsite);
 587:             const nextListName = listName;
 588: 
 589:             const changed = nextAccountName !== existing.account_name
 590:                 || nextFirstName !== existing.first_name
 591:                 || nextLastName !== existing.last_name
 592:                 || nextJobTitle !== existing.job_title
 593:                 || nextWebsite !== existing.website
 594:                 || nextListName !== existing.list_name;
 595: 
 596:             if (changed) {
 597:                 await db.run(
 598:                     `
 599:                     UPDATE leads
 600:                     SET account_name = ?,
 601:                         first_name = ?,
 602:                         last_name = ?,
 603:                         job_title = ?,
 604:                         website = ?,
 605:                         list_name = ?,
 606:                         updated_at = CURRENT_TIMESTAMP
 607:                     WHERE id = ?
 608:                 `,
 609:                     [
 610:                         nextAccountName,
 611:                         nextFirstName,
 612:                         nextLastName,
 613:                         nextJobTitle,
 614:                         nextWebsite,
 615:                         nextListName,
 616:                         leadId,
 617:                     ]
 618:                 );
 619:                 action = 'updated';
 620:             }
 621:         }
 622: 
 623:         const linkedLead = leadId > 0
 624:             ? { id: leadId }
 625:             : await db.get<{ id: number }>(`SELECT id FROM leads WHERE linkedin_url = ?`, [linkedinUrl]);
 626:         const listRow = await db.get<{ id: number }>(`SELECT id FROM lead_lists WHERE name = ?`, [listName]);
 627:         if (linkedLead?.id && listRow?.id) {
 628:             await db.run(`INSERT OR IGNORE INTO list_leads (list_id, lead_id) VALUES (?, ?)`, [listRow.id, linkedLead.id]);
 629:         }
 630: 
 631:         return {
 632:             leadId: linkedLead?.id ?? leadId,
 633:             action,
 634:         };
 635:     });
 636: }
 637: 
 638: export async function getExpiredInvitedLeads(accountId: string, olderThanDays: number): Promise<LeadRecord[]> {
 639:     const db = await getDatabase();
 640:     return db.all<LeadRecord[]>(
 641:         `SELECT * FROM leads WHERE account_id = ? AND status = 'INVITED' AND invited_at < datetime('now', '-' || ? || ' days') LIMIT 50`,
 642:         [accountId, olderThanDays]
 643:     );
 644: }
 645: 
 646: export async function addCompanyTarget(input: AddCompanyTargetInput): Promise<boolean> {
 647:     const db = await getDatabase();
 648:     await ensureLeadList(input.listName);
 649: 
 650:     const normalizedAccountName = (input.accountName ?? '').trim();
 651:     const normalizedWebsite = (input.website ?? '').trim();
 652:     if (!normalizedAccountName && !normalizedWebsite) {
 653:         return false;
 654:     }
 655: 
 656:     const result = await db.run(
 657:         `
 658:         INSERT OR IGNORE INTO company_targets (list_name, account_name, website, source_file, status)
 659:         VALUES (?, ?, ?, ?, 'NEW')
 660:     `,
 661:         [input.listName, normalizedAccountName, normalizedWebsite, input.sourceFile ?? null]
 662:     );
 663:     return (result.changes ?? 0) > 0;
 664: }
 665: 
 666: export async function countCompanyTargets(listName?: string): Promise<number> {
 667:     const db = await getDatabase();
 668:     const row = listName
 669:         ? await db.get<{ total: number }>(
 670:             `SELECT COUNT(*) as total FROM company_targets WHERE list_name = ?`,
 671:             [listName]
 672:         )
 673:         : await db.get<{ total: number }>(
 674:             `SELECT COUNT(*) as total FROM company_targets`
 675:         );
 676:     return row?.total ?? 0;
 677: }
 678: 
 679: export async function listCompanyTargets(listName: string | null, limit: number): Promise<CompanyTargetRecord[]> {
 680:     const db = await getDatabase();
 681:     const safeLimit = Math.max(1, limit);
 682:     if (listName) {
 683:         return db.all<CompanyTargetRecord[]>(
 684:             `
 685:             SELECT id, list_name, account_name, website, source_file, status, attempts, last_error, processed_at, created_at, updated_at
 686:             FROM company_targets
 687:             WHERE list_name = ?
 688:             ORDER BY updated_at DESC, created_at DESC
 689:             LIMIT ?
 690:         `,
 691:             [listName, safeLimit]
 692:         );
 693:     }
 694: 
 695:     return db.all<CompanyTargetRecord[]>(
 696:         `
 697:         SELECT id, list_name, account_name, website, source_file, status, attempts, last_error, processed_at, created_at, updated_at
 698:         FROM company_targets
 699:         ORDER BY updated_at DESC, created_at DESC
 700:         LIMIT ?
 701:     `,
 702:         [safeLimit]
 703:     );
 704: }
 705: 
 706: export async function getCompanyTargetsForEnrichment(limit: number): Promise<CompanyTargetRecord[]> {
 707:     const db = await getDatabase();
 708:     const safeLimit = Math.max(1, limit);
 709:     return db.all<CompanyTargetRecord[]>(
 710:         `
 711:         SELECT id, list_name, account_name, website, source_file, status, attempts, last_error, processed_at, created_at, updated_at
 712:         FROM company_targets
 713:         WHERE status IN ('NEW', 'ERROR')
 714:         ORDER BY status DESC, created_at ASC
 715:         LIMIT ?
 716:     `,
 717:         [safeLimit]
 718:     );
 719: }
 720: 
 721: export async function setCompanyTargetStatus(
 722:     targetId: number,
 723:     status: CompanyTargetStatus,
 724:     lastError: string | null = null
 725: ): Promise<void> {
 726:     const db = await getDatabase();
 727:     await db.run(
 728:         `
 729:         UPDATE company_targets
 730:         SET status = ?,
 731:             attempts = attempts + 1,
 732:             last_error = ?,
 733:             processed_at = CURRENT_TIMESTAMP,
 734:             updated_at = CURRENT_TIMESTAMP
 735:         WHERE id = ?
 736:     `,
 737:         [status, lastError, targetId]
 738:     );
 739: }
 740: 
 741: export async function countCompanyTargetsByStatuses(statuses: CompanyTargetStatus[]): Promise<number> {
 742:     if (statuses.length === 0) return 0;
 743:     const db = await getDatabase();
 744:     const placeholders = statuses.map(() => '?').join(', ');
 745:     const row = await db.get<{ total: number }>(
 746:         `SELECT COUNT(*) as total FROM company_targets WHERE status IN (${placeholders})`,
 747:         statuses
 748:     );
 749:     return row?.total ?? 0;
 750: }
 751: 
 752: export async function promoteNewLeadsToReadyInvite(limit: number): Promise<number> {
 753:     const db = await getDatabase();
 754:     const leads = await db.all<{ id: number }[]>(
 755:         `SELECT id FROM leads WHERE status = 'NEW' ORDER BY created_at ASC LIMIT ?`,
 756:         [limit]
 757:     );
 758:     if (leads.length === 0) return 0;
 759: 
 760:     const ids = leads.map((lead) => lead.id);
 761:     const placeholders = ids.map(() => '?').join(', ');
 762:     const result = await db.run(
 763:         `UPDATE leads SET status = 'READY_INVITE', updated_at = CURRENT_TIMESTAMP WHERE id IN (${placeholders})`,
 764:         ids
 765:     );
 766:     return result.changes ?? 0;
 767: }
 768: 
 769: export async function getLeadById(leadId: number): Promise<LeadRecord | null> {
 770:     const db = await getDatabase();
 771:     const lead = await db.get<LeadRecord>(`SELECT * FROM leads WHERE id = ?`, [leadId]);
 772:     if (!lead) return null;
 773:     lead.status = normalizeLegacyStatus(lead.status);
 774:     return lead;
 775: }
 776: 
 777: export async function updateLeadScrapedContext(leadId: number, about: string | null, experience: string | null): Promise<void> {
 778:     const db = await getDatabase();
 779:     await db.run(
 780:         `
 781:         UPDATE leads
 782:         SET about = ?,
 783:             experience = ?,
 784:             updated_at = CURRENT_TIMESTAMP
 785:         WHERE id = ?
 786:     `,
 787:         [about, experience, leadId]
 788:     );
 789: }
 790: 
 791: export async function updateLeadPromptVariant(leadId: number, variant: string | null): Promise<void> {
 792:     const db = await getDatabase();
 793:     await db.run(
 794:         `
 795:         UPDATE leads
 796:         SET invite_prompt_variant = ?,
 797:             updated_at = CURRENT_TIMESTAMP
 798:         WHERE id = ?
 799:     `,
 800:         [variant, leadId]
 801:     );
 802: }
 803: 
 804: export async function updateLeadScores(leadId: number, leadScore: number | null, confidenceScore: number | null): Promise<void> {
 805:     const db = await getDatabase();
 806:     await db.run(
 807:         `
 808:         UPDATE leads
 809:         SET lead_score = ?,
 810:             confidence_score = ?,
 811:             updated_at = CURRENT_TIMESTAMP
 812:         WHERE id = ?
 813:     `,
 814:         [leadScore, confidenceScore, leadId]
 815:     );
 816: }
 817: 
 818: export async function getLeadsWithSalesNavigatorUrls(limit: number): Promise<LeadRecord[]> {
 819:     const db = await getDatabase();
 820:     const safeLimit = Math.max(1, limit);
 821:     const leads = await db.all<LeadRecord[]>(
 822:         `
 823:         SELECT *
 824:         FROM leads
 825:         WHERE linkedin_url LIKE '%linkedin.com/sales/%'
 826:           AND status IN ('NEW', 'READY_INVITE', 'INVITED', 'ACCEPTED', 'READY_MESSAGE', 'BLOCKED', 'PENDING')
 827:         ORDER BY updated_at DESC, created_at ASC
 828:         LIMIT ?
 829:     `,
 830:         [safeLimit]
 831:     );
 832:     return leads.map((lead) => ({ ...lead, status: normalizeLegacyStatus(lead.status) }));
 833: }
 834: 
 835: export interface UpdateLeadLinkedinUrlResult {
 836:     updated: boolean;
 837:     conflictLeadId: number | null;
 838: }
 839: 
 840: export async function updateLeadLinkedinUrl(leadId: number, nextLinkedinUrl: string): Promise<UpdateLeadLinkedinUrlResult> {
 841:     const db = await getDatabase();
 842:     const normalizedUrl = normalizeLinkedInUrl(nextLinkedinUrl);
 843: 
 844:     try {
 845:         const result = await db.run(
 846:             `
 847:             UPDATE leads
 848:             SET linkedin_url = ?,
 849:                 updated_at = CURRENT_TIMESTAMP
 850:             WHERE id = ?
 851:         `,
 852:             [normalizedUrl, leadId]
 853:         );
 854:         return {
 855:             updated: (result.changes ?? 0) > 0,
 856:             conflictLeadId: null,
 857:         };
 858:     } catch (error) {
 859:         const message = error instanceof Error ? error.message : String(error);
 860:         if (!/UNIQUE constraint failed:\s*leads\.linkedin_url/i.test(message)) {
 861:             throw error;
 862:         }
 863:         const conflict = await db.get<{ id: number }>(
 864:             `SELECT id FROM leads WHERE linkedin_url = ? LIMIT 1`,
 865:             [normalizedUrl]
 866:         );
 867:         return {
 868:             updated: false,
 869:             conflictLeadId: conflict?.id ?? null,
 870:         };
 871:     }
 872: }
 873: 
 874: export async function getLeadsByStatus(status: LeadStatus, limit: number): Promise<LeadRecord[]> {
 875:     const db = await getDatabase();
 876:     const normalized = normalizeLegacyStatus(status);
 877:     const leads = await db.all<LeadRecord[]>(
 878:         `SELECT * FROM leads WHERE status = ? ORDER BY created_at ASC LIMIT ?`,
 879:         [normalized, limit]
 880:     );
 881:     return leads.map((lead) => ({ ...lead, status: normalizeLegacyStatus(lead.status) }));
 882: }
 883: 
 884: export async function getLeadsByStatusForSiteCheck(status: LeadStatus, limit: number, staleDays: number): Promise<LeadRecord[]> {
 885:     const db = await getDatabase();
 886:     const normalized = normalizeLegacyStatus(status);
 887:     const safeLimit = Math.max(1, limit);
 888:     const safeStaleDays = Math.max(0, staleDays);
 889:     const leads = await db.all<LeadRecord[]>(
 890:         `
 891:         SELECT *
 892:         FROM leads
 893:         WHERE status = ?
 894:           AND (
 895:             last_site_check_at IS NULL
 896:             OR last_site_check_at <= DATETIME('now', '-' || ? || ' days')
 897:           )
 898:         ORDER BY
 899:             CASE WHEN last_site_check_at IS NULL THEN 0 ELSE 1 END ASC,
 900:             last_site_check_at ASC,
 901:             created_at ASC
 902:         LIMIT ?
 903:     `,
 904:         [normalized, safeStaleDays, safeLimit]
 905:     );
 906:     return leads.map((lead) => ({ ...lead, status: normalizeLegacyStatus(lead.status) }));
 907: }
 908: 
 909: export async function getLeadsByStatusForList(status: LeadStatus, listName: string, limit: number): Promise<LeadRecord[]> {
 910:     const db = await getDatabase();
 911:     const normalized = normalizeLegacyStatus(status);
 912:     const leads = await db.all<LeadRecord[]>(
 913:         `
 914:         SELECT *
 915:         FROM leads
 916:         WHERE status = ?
 917:           AND list_name = ?
 918:         ORDER BY
 919:             COALESCE(lead_score, -1) DESC,
 920:             created_at ASC
 921:         LIMIT ?
 922:     `,
 923:         [normalized, listName, limit]
 924:     );
 925:     return leads.map((lead) => ({ ...lead, status: normalizeLegacyStatus(lead.status) }));
 926: }
 927: 
 928: export async function touchLeadSiteCheckAt(leadId: number): Promise<void> {
 929:     const db = await getDatabase();
 930:     await db.run(
 931:         `
 932:         UPDATE leads
 933:         SET last_site_check_at = CURRENT_TIMESTAMP,
 934:             updated_at = CURRENT_TIMESTAMP
 935:         WHERE id = ?
 936:     `,
 937:         [leadId]
 938:     );
 939: }
 940: 
 941: export async function countLeadsByStatuses(statuses: LeadStatus[]): Promise<number> {
 942:     if (statuses.length === 0) return 0;
 943:     const db = await getDatabase();
 944:     const normalized = statuses.map((status) => normalizeLegacyStatus(status));
 945:     const placeholders = normalized.map(() => '?').join(', ');
 946:     const row = await db.get<{ total: number }>(
 947:         `SELECT COUNT(*) as total FROM leads WHERE status IN (${placeholders})`,
 948:         normalized
 949:     );
 950:     return row?.total ?? 0;
 951: }
 952: 
 953: export async function getLeadStatusCountsForLists(listNames: string[]): Promise<ListLeadStatusCount[]> {
 954:     if (listNames.length === 0) {
 955:         return [];
 956:     }
 957: 
 958:     const db = await getDatabase();
 959:     const placeholders = listNames.map(() => '?').join(', ');
 960:     return db.all<ListLeadStatusCount[]>(
 961:         `
 962:         SELECT list_name, status, COUNT(*) as total
 963:         FROM leads
 964:         WHERE list_name IN (${placeholders})
 965:         GROUP BY list_name, status
 966:     `,
 967:         listNames
 968:     );
 969: }
 970: 
 971: export async function setLeadStatus(leadId: number, status: LeadStatus, errorMessage?: string, blockedReason?: string): Promise<void> {
 972:     const db = await getDatabase();
 973:     const normalized = normalizeLegacyStatus(status);
 974:     const timestampColumn = normalized === 'INVITED' ? 'invited_at' : normalized === 'ACCEPTED' ? 'accepted_at' : normalized === 'MESSAGED' ? 'messaged_at' : null;
 975: 
 976:     if (timestampColumn) {
 977:         await db.run(
 978:             `
 979:             UPDATE leads
 980:             SET status = ?, ${timestampColumn} = CURRENT_TIMESTAMP, last_error = ?, blocked_reason = ?, updated_at = CURRENT_TIMESTAMP
 981:             WHERE id = ?
 982:         `,
 983:             [normalized, errorMessage ?? null, blockedReason ?? null, leadId]
 984:         );
 985:         return;
 986:     }
 987: 
 988:     await db.run(
 989:         `
 990:         UPDATE leads
 991:         SET status = ?, last_error = ?, blocked_reason = ?, updated_at = CURRENT_TIMESTAMP
 992:         WHERE id = ?
 993:     `,
 994:         [normalized, errorMessage ?? null, blockedReason ?? null, leadId]
 995:     );
 996: }
 997: 
 998: export async function appendLeadEvent(
 999:     leadId: number,
1000:     fromStatus: LeadStatus,
1001:     toStatus: LeadStatus,
1002:     reason: string,
1003:     metadata: Record<string, unknown>
1004: ): Promise<void> {
1005:     const db = await getDatabase();
1006:     await db.run(
1007:         `
1008:         INSERT INTO lead_events (lead_id, from_status, to_status, reason, metadata_json)
1009:         VALUES (?, ?, ?, ?, ?)
1010:     `,
1011:         [leadId, normalizeLegacyStatus(fromStatus), normalizeLegacyStatus(toStatus), reason, JSON.stringify(metadata)]
1012:     );
1013: }
1014: 
1015: export async function getDailyStat(dateString: string, field: 'invites_sent' | 'messages_sent' | 'challenges_count' | 'selector_failures' | 'run_errors'): Promise<number> {
1016:     const db = await getDatabase();
1017:     const row = await db.get<Record<string, number>>(
1018:         `SELECT ${field} FROM daily_stats WHERE date = ?`,
1019:         [dateString]
1020:     );
1021:     return row?.[field] ?? 0;
1022: }
1023: 
1024: export async function getDailyStatsSnapshot(dateString: string): Promise<DailyStatsSnapshot> {
1025:     const db = await getDatabase();
1026:     const row = await db.get<{
1027:         invites_sent: number;
1028:         messages_sent: number;
1029:         challenges_count: number;
1030:         selector_failures: number;
1031:         run_errors: number;
1032:     }>(
1033:         `SELECT invites_sent, messages_sent, challenges_count, selector_failures, run_errors FROM daily_stats WHERE date = ?`,
1034:         [dateString]
1035:     );
1036: 
1037:     return {
1038:         date: dateString,
1039:         invitesSent: row?.invites_sent ?? 0,
1040:         messagesSent: row?.messages_sent ?? 0,
1041:         challengesCount: row?.challenges_count ?? 0,
1042:         selectorFailures: row?.selector_failures ?? 0,
1043:         runErrors: row?.run_errors ?? 0,
1044:     };
1045: }
1046: 
1047: export async function getListDailyStat(
1048:     dateString: string,
1049:     listName: string,
1050:     field: 'invites_sent' | 'messages_sent'
1051: ): Promise<number> {
1052:     const db = await getDatabase();
1053:     const row = await db.get<Record<string, number>>(
1054:         `SELECT ${field} FROM list_daily_stats WHERE date = ? AND list_name = ?`,
1055:         [dateString, listName]
1056:     );
1057:     return row?.[field] ?? 0;
1058: }
1059: 
1060: export async function incrementDailyStat(
1061:     dateString: string,
1062:     field: 'invites_sent' | 'messages_sent' | 'acceptances' | 'challenges_count' | 'selector_failures' | 'run_errors',
1063:     amount: number = 1
1064: ): Promise<void> {
1065:     const db = await getDatabase();
1066:     await db.run(
1067:         `
1068:         INSERT INTO daily_stats (date, ${field}) VALUES (?, ?)
1069:         ON CONFLICT(date) DO UPDATE SET ${field} = ${field} + ?
1070:     `,
1071:         [dateString, amount, amount]
1072:     );
1073: }
1074: 
1075: export async function incrementListDailyStat(
1076:     dateString: string,
1077:     listName: string,
1078:     field: 'invites_sent' | 'messages_sent',
1079:     amount: number = 1
1080: ): Promise<void> {
1081:     const db = await getDatabase();
1082:     await db.run(
1083:         `
1084:         INSERT INTO list_daily_stats (date, list_name, ${field}) VALUES (?, ?, ?)
1085:         ON CONFLICT(date, list_name) DO UPDATE SET ${field} = ${field} + ?
1086:     `,
1087:         [dateString, listName, amount, amount]
1088:     );
1089: }
1090: 
1091: export async function countWeeklyInvites(weekStartDate: string): Promise<number> {
1092:     const db = await getDatabase();
1093:     const row = await db.get<{ total: number }>(
1094:         `SELECT COALESCE(SUM(invites_sent), 0) as total FROM daily_stats WHERE date >= ?`,
1095:         [weekStartDate]
1096:     );
1097:     return row?.total ?? 0;
1098: }
1099: 
1100: export async function enqueueJob(
1101:     type: JobType,
1102:     payload: Record<string, unknown>,
1103:     idempotencyKey: string,
1104:     priority: number,
1105:     maxAttempts: number,
1106:     initialDelaySeconds: number = 0,
1107:     accountId: string = 'default'
1108: ): Promise<boolean> {
1109:     const db = await getDatabase();
1110:     const safeDelay = Math.max(0, Math.floor(initialDelaySeconds));
1111:     const normalizedAccountId = accountId.trim() || 'default';
1112:     const result = await db.run(
1113:         `
1114:         INSERT OR IGNORE INTO jobs (type, status, account_id, payload_json, idempotency_key, priority, max_attempts, next_run_at)
1115:         VALUES (?, 'QUEUED', ?, ?, ?, ?, ?, DATETIME('now', '+' || ? || ' seconds'))
1116:     `,
1117:         [type, normalizedAccountId, JSON.stringify(payload), idempotencyKey, priority, maxAttempts, safeDelay]
1118:     );
1119:     return (result.changes ?? 0) > 0;
1120: }
1121: 
1122: export async function lockNextQueuedJob(
1123:     allowedTypes: JobType[],
1124:     accountId?: string,
1125:     includeLegacyDefaultQueue: boolean = false
1126: ): Promise<JobRecord | null> {
1127:     if (allowedTypes.length === 0) {
1128:         return null;
1129:     }
1130:     const db = await getDatabase();
1131:     return withTransaction(db, async () => {
1132:         const placeholders = allowedTypes.map(() => '?').join(', ');
1133:         const whereClauses = [
1134:             `status = 'QUEUED'`,
1135:             `next_run_at <= CURRENT_TIMESTAMP`,
1136:             `type IN (${placeholders})`,
1137:         ];
1138:         const params: unknown[] = [...allowedTypes];
1139: 
1140:         const normalizedAccountId = accountId?.trim();
1141:         if (normalizedAccountId) {
1142:             if (includeLegacyDefaultQueue && normalizedAccountId !== 'default') {
1143:                 whereClauses.push(`account_id IN (?, 'default')`);
1144:                 params.push(normalizedAccountId);
1145:             } else {
1146:                 whereClauses.push(`account_id = ?`);
1147:                 params.push(normalizedAccountId);
1148:             }
1149:         }
1150: 
1151:         const job = await db.get<JobRecord>(
1152:             `
1153:             SELECT * FROM jobs
1154:             WHERE ${whereClauses.join('\n              AND ')}
1155:             ORDER BY priority ASC, created_at ASC
1156:             LIMIT 1
1157:         `,
1158:             params
1159:         );
1160: 
1161:         if (!job) return null;
1162: 
1163:         const updateResult = await db.run(
1164:             `
1165:             UPDATE jobs
1166:             SET status = 'RUNNING', locked_at = CURRENT_TIMESTAMP, updated_at = CURRENT_TIMESTAMP
1167:             WHERE id = ? AND status = 'QUEUED'
1168:         `,
1169:             [job.id]
1170:         );
1171:         if ((updateResult.changes ?? 0) === 0) {
1172:             return null;
1173:         }
1174: 
1175:         return {
1176:             ...job,
1177:             status: 'RUNNING',
1178:             payload_json: job.payload_json,
1179:         };
1180:     });
1181: }
1182: 
1183: export async function markJobSucceeded(jobId: number): Promise<void> {
1184:     const db = await getDatabase();
1185:     await db.run(
1186:         `
1187:         UPDATE jobs
1188:         SET status = 'SUCCEEDED', locked_at = NULL, updated_at = CURRENT_TIMESTAMP
1189:         WHERE id = ?
1190:     `,
1191:         [jobId]
1192:     );
1193: }
1194: 
1195: export async function markJobRetryOrDeadLetter(
1196:     jobId: number,
1197:     attempts: number,
1198:     maxAttempts: number,
1199:     nextRetryDelayMs: number,
1200:     errorMessage: string
1201: ): Promise<JobStatus> {
1202:     const db = await getDatabase();
1203:     if (attempts >= maxAttempts) {
1204:         await db.run(
1205:             `
1206:             UPDATE jobs
1207:             SET status = 'DEAD_LETTER',
1208:                 attempts = ?,
1209:                 last_error = ?,
1210:                 locked_at = NULL,
1211:                 updated_at = CURRENT_TIMESTAMP
1212:             WHERE id = ?
1213:         `,
1214:             [attempts, errorMessage, jobId]
1215:         );
1216:         return 'DEAD_LETTER';
1217:     }
1218: 
1219:     const seconds = Math.max(1, Math.ceil(nextRetryDelayMs / 1000));
1220:     await db.run(
1221:         `
1222:         UPDATE jobs
1223:         SET status = 'QUEUED',
1224:             attempts = ?,
1225:             last_error = ?,
1226:             next_run_at = DATETIME('now', '+' || ? || ' seconds'),
1227:             locked_at = NULL,
1228:             updated_at = CURRENT_TIMESTAMP
1229:         WHERE id = ?
1230:     `,
1231:         [attempts, errorMessage, seconds, jobId]
1232:     );
1233:     return 'QUEUED';
1234: }
1235: 
1236: export async function createJobAttempt(
1237:     jobId: number,
1238:     success: boolean,
1239:     errorCode: string | null,
1240:     errorMessage: string | null,
1241:     evidencePath: string | null
1242: ): Promise<void> {
1243:     const db = await getDatabase();
1244:     await db.run(
1245:         `
1246:         INSERT INTO job_attempts (job_id, finished_at, success, error_code, error_message, evidence_path)
1247:         VALUES (?, CURRENT_TIMESTAMP, ?, ?, ?, ?)
1248:     `,
1249:         [jobId, success ? 1 : 0, errorCode, errorMessage, evidencePath]
1250:     );
1251: }
1252: 
1253: export async function createIncident(
1254:     type: string,
1255:     severity: 'INFO' | 'WARN' | 'CRITICAL',
1256:     details: Record<string, unknown>
1257: ): Promise<number> {
1258:     const db = await getDatabase();
1259:     const result = await db.run(
1260:         `
1261:         INSERT INTO account_incidents (type, severity, status, details_json)
1262:         VALUES (?, ?, 'OPEN', ?)
1263:     `,
1264:         [type, severity, JSON.stringify(details)]
1265:     );
1266:     return result.lastID ?? 0;
1267: }
1268: 
1269: export async function listOpenIncidents(): Promise<Array<{ id: number; type: string; severity: string; opened_at: string }>> {
1270:     const db = await getDatabase();
1271:     return db.all(`SELECT id, type, severity, opened_at FROM account_incidents WHERE status = 'OPEN' ORDER BY opened_at DESC`);
1272: }
1273: 
1274: export async function resolveIncident(incidentId: number): Promise<void> {
1275:     const db = await getDatabase();
1276:     await db.run(
1277:         `
1278:         UPDATE account_incidents
1279:         SET status = 'RESOLVED', resolved_at = CURRENT_TIMESTAMP
1280:         WHERE id = ?
1281:     `,
1282:         [incidentId]
1283:     );
1284: }
1285: 
1286: export async function pushOutboxEvent(topic: string, payload: Record<string, unknown>, idempotencyKey: string): Promise<void> {
1287:     const db = await getDatabase();
1288:     await db.run(
1289:         `
1290:         INSERT OR IGNORE INTO outbox_events (topic, payload_json, idempotency_key)
1291:         VALUES (?, ?, ?)
1292:     `,
1293:         [topic, JSON.stringify(payload), idempotencyKey]
1294:     );
1295: }
1296: 
1297: export async function getPendingOutboxEvents(limit: number): Promise<OutboxEventRecord[]> {
1298:     const db = await getDatabase();
1299:     return db.all<OutboxEventRecord[]>(
1300:         `
1301:         SELECT * FROM outbox_events
1302:         WHERE delivered_at IS NULL
1303:           AND next_retry_at <= CURRENT_TIMESTAMP
1304:         ORDER BY created_at ASC
1305:         LIMIT ?
1306:     `,
1307:         [limit]
1308:     );
1309: }
1310: 
1311: export async function markOutboxDelivered(eventId: number): Promise<void> {
1312:     const db = await getDatabase();
1313:     await db.run(
1314:         `
1315:         UPDATE outbox_events
1316:         SET delivered_at = CURRENT_TIMESTAMP,
1317:             last_error = NULL
1318:         WHERE id = ?
1319:     `,
1320:         [eventId]
1321:     );
1322: }
1323: 
1324: export async function markOutboxRetry(eventId: number, attempts: number, retryDelayMs: number, errorMessage: string): Promise<void> {
1325:     const db = await getDatabase();
1326:     const seconds = Math.max(1, Math.ceil(retryDelayMs / 1000));
1327:     await db.run(
1328:         `
1329:         UPDATE outbox_events
1330:         SET attempts = ?,
1331:             next_retry_at = DATETIME('now', '+' || ? || ' seconds'),
1332:             last_error = ?
1333:         WHERE id = ?
1334:     `,
1335:         [attempts, seconds, errorMessage, eventId]
1336:     );
1337: }
1338: 
1339: export async function markOutboxPermanentFailure(eventId: number, attempts: number, errorMessage: string): Promise<void> {
1340:     const db = await getDatabase();
1341:     await db.run(
1342:         `
1343:         UPDATE outbox_events
1344:         SET attempts = ?,
1345:             delivered_at = CURRENT_TIMESTAMP,
1346:             last_error = ?
1347:         WHERE id = ?
1348:     `,
1349:         [attempts, `PERMANENT_FAILURE: ${errorMessage}`, eventId]
1350:     );
1351: }
1352: 
1353: export async function countPendingOutboxEvents(): Promise<number> {
1354:     const db = await getDatabase();
1355:     const row = await db.get<{ total: number }>(`SELECT COUNT(*) as total FROM outbox_events WHERE delivered_at IS NULL`);
1356:     return row?.total ?? 0;
1357: }
1358: 
1359: export async function getJobStatusCounts(): Promise<JobStatusCounts> {
1360:     const db = await getDatabase();
1361:     const rows = await db.all<{ status: JobStatus; total: number }[]>(
1362:         `SELECT status, COUNT(*) as total FROM jobs GROUP BY status`
1363:     );
1364: 
1365:     const counts: JobStatusCounts = {
1366:         QUEUED: 0,
1367:         RUNNING: 0,
1368:         SUCCEEDED: 0,
1369:         FAILED: 0,
1370:         DEAD_LETTER: 0,
1371:         PAUSED: 0,
1372:     };
1373: 
1374:     for (const row of rows) {
1375:         if (row.status in counts) {
1376:             counts[row.status] = row.total;
1377:         }
1378:     }
1379: 
1380:     return counts;
1381: }
1382: 
1383: export async function getRuntimeLock(lockKey: string): Promise<RuntimeLockRecord | null> {
1384:     const db = await getDatabase();
1385:     const row = await db.get<RuntimeLockRecord>(`SELECT * FROM runtime_locks WHERE lock_key = ?`, [lockKey]);
1386:     return row ?? null;
1387: }
1388: 
1389: export async function acquireRuntimeLock(
1390:     lockKey: string,
1391:     ownerId: string,
1392:     ttlSeconds: number,
1393:     metadata: Record<string, unknown> = {}
1394: ): Promise<AcquireRuntimeLockResult> {
1395:     const db = await getDatabase();
1396:     const safeTtl = Math.max(1, ttlSeconds);
1397:     const metadataJson = JSON.stringify(metadata);
1398: 
1399:     return withTransaction(db, async () => {
1400:         const existing = await db.get<RuntimeLockRecord>(
1401:             `SELECT * FROM runtime_locks WHERE lock_key = ?`,
1402:             [lockKey]
1403:         );
1404: 
1405:         if (!existing) {
1406:             await db.run(
1407:                 `
1408:                 INSERT INTO runtime_locks (lock_key, owner_id, metadata_json, expires_at)
1409:                 VALUES (?, ?, ?, DATETIME('now', '+' || ? || ' seconds'))
1410:             `,
1411:                 [lockKey, ownerId, metadataJson, safeTtl]
1412:             );
1413:             const inserted = await db.get<RuntimeLockRecord>(`SELECT * FROM runtime_locks WHERE lock_key = ?`, [lockKey]);
1414:             return {
1415:                 acquired: true,
1416:                 lock: inserted ?? null,
1417:             };
1418:         }
1419: 
1420:         if (existing.owner_id === ownerId) {
1421:             await db.run(
1422:                 `
1423:                 UPDATE runtime_locks
1424:                 SET heartbeat_at = CURRENT_TIMESTAMP,
1425:                     expires_at = DATETIME('now', '+' || ? || ' seconds'),
1426:                     metadata_json = ?,
1427:                     updated_at = CURRENT_TIMESTAMP
1428:                 WHERE lock_key = ?
1429:             `,
1430:                 [safeTtl, metadataJson, lockKey]
1431:             );
1432:             const renewed = await db.get<RuntimeLockRecord>(`SELECT * FROM runtime_locks WHERE lock_key = ?`, [lockKey]);
1433:             return {
1434:                 acquired: true,
1435:                 lock: renewed ?? null,
1436:             };
1437:         }
1438: 
1439:         const isStaleRow = await db.get<{ stale: number }>(
1440:             `
1441:             SELECT CASE WHEN expires_at <= CURRENT_TIMESTAMP THEN 1 ELSE 0 END AS stale
1442:             FROM runtime_locks
1443:             WHERE lock_key = ?
1444:         `,
1445:             [lockKey]
1446:         );
1447: 
1448:         if ((isStaleRow?.stale ?? 0) === 1) {
1449:             await db.run(
1450:                 `
1451:                 UPDATE runtime_locks
1452:                 SET owner_id = ?,
1453:                     acquired_at = CURRENT_TIMESTAMP,
1454:                     heartbeat_at = CURRENT_TIMESTAMP,
1455:                     expires_at = DATETIME('now', '+' || ? || ' seconds'),
1456:                     metadata_json = ?,
1457:                     updated_at = CURRENT_TIMESTAMP
1458:                 WHERE lock_key = ?
1459:             `,
1460:                 [ownerId, safeTtl, metadataJson, lockKey]
1461:             );
1462:             const takenOver = await db.get<RuntimeLockRecord>(`SELECT * FROM runtime_locks WHERE lock_key = ?`, [lockKey]);
1463:             return {
1464:                 acquired: true,
1465:                 lock: takenOver ?? null,
1466:             };
1467:         }
1468: 
1469:         return {
1470:             acquired: false,
1471:             lock: existing,
1472:         };
1473:     });
1474: }
1475: 
1476: export async function heartbeatRuntimeLock(lockKey: string, ownerId: string, ttlSeconds: number): Promise<boolean> {
1477:     const db = await getDatabase();
1478:     const safeTtl = Math.max(1, ttlSeconds);
1479:     const result = await db.run(
1480:         `
1481:         UPDATE runtime_locks
1482:         SET heartbeat_at = CURRENT_TIMESTAMP,
1483:             expires_at = DATETIME('now', '+' || ? || ' seconds'),
1484:             updated_at = CURRENT_TIMESTAMP
1485:         WHERE lock_key = ?
1486:           AND owner_id = ?
1487:     `,
1488:         [safeTtl, lockKey, ownerId]
1489:     );
1490:     return (result.changes ?? 0) > 0;
1491: }
1492: 
1493: export async function releaseRuntimeLock(lockKey: string, ownerId: string): Promise<boolean> {
1494:     const db = await getDatabase();
1495:     const result = await db.run(
1496:         `
1497:         DELETE FROM runtime_locks
1498:         WHERE lock_key = ?
1499:           AND owner_id = ?
1500:     `,
1501:         [lockKey, ownerId]
1502:     );
1503:     return (result.changes ?? 0) > 0;
1504: }
1505: 
1506: export async function setRuntimeFlag(key: string, value: string): Promise<void> {
1507:     const db = await getDatabase();
1508:     await db.run(
1509:         `
1510:         INSERT INTO sync_state (key, value, updated_at) VALUES (?, ?, CURRENT_TIMESTAMP)
1511:         ON CONFLICT(key) DO UPDATE SET value = excluded.value, updated_at = CURRENT_TIMESTAMP
1512:     `,
1513:         [key, value]
1514:     );
1515: }
1516: 
1517: export async function getRuntimeFlag(key: string): Promise<string | null> {
1518:     const db = await getDatabase();
1519:     const row = await db.get<{ value: string }>(`SELECT value FROM sync_state WHERE key = ?`, [key]);
1520:     return row?.value ?? null;
1521: }
1522: 
1523: export async function setAutomationPause(minutes: number | null, reason: string): Promise<string | null> {
1524:     await setRuntimeFlag('automation_paused', 'true');
1525:     await setRuntimeFlag('automation_pause_reason', reason.trim() || 'manual_pause');
1526: 
1527:     if (minutes === null) {
1528:         await setRuntimeFlag('automation_paused_until', '');
1529:         return null;
1530:     }
1531: 
1532:     const safeMinutes = Math.max(1, minutes);
1533:     const until = new Date(Date.now() + safeMinutes * 60_000).toISOString();
1534:     await setRuntimeFlag('automation_paused_until', until);
1535:     return until;
1536: }
1537: 
1538: export async function clearAutomationPause(): Promise<void> {
1539:     await setRuntimeFlag('automation_paused', 'false');
1540:     await setRuntimeFlag('automation_paused_until', '');
1541:     await setRuntimeFlag('automation_pause_reason', '');
1542: }
1543: 
1544: export async function getAutomationPauseState(now: Date = new Date()): Promise<AutomationPauseState> {
1545:     const paused = (await getRuntimeFlag('automation_paused')) === 'true';
1546:     if (!paused) {
1547:         return {
1548:             paused: false,
1549:             pausedUntil: null,
1550:             reason: null,
1551:             remainingSeconds: null,
1552:         };
1553:     }
1554: 
1555:     const reasonRaw = await getRuntimeFlag('automation_pause_reason');
1556:     const untilRaw = await getRuntimeFlag('automation_paused_until');
1557:     const parsedUntil = untilRaw && Number.isFinite(Date.parse(untilRaw))
1558:         ? new Date(untilRaw).toISOString()
1559:         : null;
1560: 
1561:     if (parsedUntil && Date.parse(parsedUntil) <= now.getTime()) {
1562:         await clearAutomationPause();
1563:         return {
1564:             paused: false,
1565:             pausedUntil: null,
1566:             reason: null,
1567:             remainingSeconds: null,
1568:         };
1569:     }
1570: 
1571:     const remainingSeconds = parsedUntil
1572:         ? Math.max(0, Math.ceil((Date.parse(parsedUntil) - now.getTime()) / 1000))
1573:         : null;
1574: 
1575:     return {
1576:         paused: true,
1577:         pausedUntil: parsedUntil,
1578:         reason: reasonRaw && reasonRaw.trim() ? reasonRaw : null,
1579:         remainingSeconds,
1580:     };
1581: }
1582: 
1583: export async function recordRunLog(level: 'INFO' | 'WARN' | 'ERROR', event: string, payload: Record<string, unknown>): Promise<void> {
1584:     const db = await getDatabase();
1585:     await db.run(
1586:         `
1587:         INSERT INTO run_logs (level, event, payload_json)
1588:         VALUES (?, ?, ?)
1589:     `,
1590:         [level, event, JSON.stringify(payload)]
1591:     );
1592: }
1593: 
1594: export async function getLastRunLogs(limit: number): Promise<Array<{ level: string; event: string; payload_json: string; created_at: string }>> {
1595:     const db = await getDatabase();
1596:     return db.all(
1597:         `SELECT level, event, payload_json, created_at FROM run_logs ORDER BY created_at DESC LIMIT ?`,
1598:         [limit]
1599:     );
1600: }
1601: 
1602: export async function cleanupPrivacyData(retentionDays: number): Promise<PrivacyCleanupStats> {
1603:     const db = await getDatabase();
1604:     const safeDays = Math.max(7, retentionDays);
1605:     const daysParam = String(safeDays);
1606: 
1607:     const runLogs = await db.run(
1608:         `DELETE FROM run_logs WHERE created_at < DATETIME('now', '-' || ? || ' days')`,
1609:         [daysParam]
1610:     );
1611:     const jobAttempts = await db.run(
1612:         `DELETE FROM job_attempts WHERE started_at < DATETIME('now', '-' || ? || ' days')`,
1613:         [daysParam]
1614:     );
1615:     const leadEvents = await db.run(
1616:         `DELETE FROM lead_events WHERE created_at < DATETIME('now', '-' || ? || ' days')`,
1617:         [daysParam]
1618:     );
1619:     const messageHistory = await db.run(
1620:         `DELETE FROM message_history WHERE sent_at < DATETIME('now', '-' || ? || ' days')`,
1621:         [daysParam]
1622:     );
1623:     const deliveredOutboxEvents = await db.run(
1624:         `DELETE FROM outbox_events
1625:          WHERE delivered_at IS NOT NULL
1626:            AND created_at < DATETIME('now', '-' || ? || ' days')`,
1627:         [daysParam]
1628:     );
1629:     const resolvedIncidents = await db.run(
1630:         `DELETE FROM account_incidents
1631:          WHERE status = 'RESOLVED'
1632:            AND resolved_at < DATETIME('now', '-' || ? || ' days')`,
1633:         [daysParam]
1634:     );
1635: 
1636:     const staleLeadsSubquery = `
1637:         SELECT id
1638:         FROM leads
1639:         WHERE status IN ('SKIPPED', 'BLOCKED', 'DEAD', 'WITHDRAWN', 'REPLIED', 'CONNECTED')
1640:           AND COALESCE(updated_at, created_at) < DATETIME('now', '-' || ? || ' days')
1641:     `;
1642:     const staleListMemberships = await db.run(
1643:         `DELETE FROM list_leads WHERE lead_id IN (${staleLeadsSubquery})`,
1644:         [daysParam]
1645:     );
1646:     const staleLeadEvents = await db.run(
1647:         `DELETE FROM lead_events WHERE lead_id IN (${staleLeadsSubquery})`,
1648:         [daysParam]
1649:     );
1650:     const staleMessageHistory = await db.run(
1651:         `DELETE FROM message_history WHERE lead_id IN (${staleLeadsSubquery})`,
1652:         [daysParam]
1653:     );
1654:     const staleLeads = await db.run(
1655:         `DELETE FROM leads WHERE id IN (${staleLeadsSubquery})`,
1656:         [daysParam]
1657:     );
1658: 
1659:     return {
1660:         runLogs: runLogs.changes ?? 0,
1661:         jobAttempts: jobAttempts.changes ?? 0,
1662:         leadEvents: leadEvents.changes ?? 0,
1663:         messageHistory: messageHistory.changes ?? 0,
1664:         deliveredOutboxEvents: deliveredOutboxEvents.changes ?? 0,
1665:         resolvedIncidents: resolvedIncidents.changes ?? 0,
1666:         staleListMemberships: staleListMemberships.changes ?? 0,
1667:         staleLeadEvents: staleLeadEvents.changes ?? 0,
1668:         staleMessageHistory: staleMessageHistory.changes ?? 0,
1669:         staleLeads: staleLeads.changes ?? 0,
1670:     };
1671: }
1672: 
1673: export async function storeMessageHash(leadId: number, contentHash: string): Promise<void> {
1674:     const db = await getDatabase();
1675:     await db.run(
1676:         `
1677:         INSERT INTO message_history (lead_id, content_hash)
1678:         VALUES (?, ?)
1679:     `,
1680:         [leadId, contentHash]
1681:     );
1682: }
1683: 
1684: export async function countRecentMessageHash(contentHash: string, hoursWindow: number): Promise<number> {
1685:     const db = await getDatabase();
1686:     const row = await db.get<{ total: number }>(
1687:         `
1688:         SELECT COUNT(*) as total
1689:         FROM message_history
1690:         WHERE content_hash = ?
1691:           AND sent_at >= DATETIME('now', '-' || ? || ' hours')
1692:     `,
1693:         [contentHash, hoursWindow]
1694:     );
1695:     return row?.total ?? 0;
1696: }
1697: 
1698: export async function getRiskInputs(localDate: string, hardInviteCap: number): Promise<RiskInputs> {
1699:     const db = await getDatabase();
1700:     const pendingInvites = await countLeadsByStatuses(['INVITED']);
1701:     const invitedTotalRow = await db.get<{ total: number }>(
1702:         `SELECT COUNT(*) as total FROM leads WHERE invited_at IS NOT NULL`
1703:     );
1704:     const invitedTotal = invitedTotalRow?.total ?? 0;
1705:     const pendingRatio = invitedTotal > 0 ? pendingInvites / invitedTotal : 0;
1706: 
1707:     const attemptsRow = await db.get<{ total: number }>(
1708:         `
1709:         SELECT COUNT(*) as total
1710:         FROM job_attempts
1711:         WHERE started_at >= DATETIME('now', '-24 hours')
1712:     `
1713:     );
1714:     const failedRow = await db.get<{ total: number }>(
1715:         `
1716:         SELECT COUNT(*) as total
1717:         FROM job_attempts
1718:         WHERE started_at >= DATETIME('now', '-24 hours')
1719:           AND success = 0
1720:     `
1721:     );
1722:     const totalAttempts = attemptsRow?.total ?? 0;
1723:     const failedAttempts = failedRow?.total ?? 0;
1724:     const errorRate = totalAttempts > 0 ? failedAttempts / totalAttempts : 0;
1725: 
1726:     const selectorFailures = await getDailyStat(localDate, 'selector_failures');
1727:     const denominator = Math.max(1, totalAttempts);
1728:     const selectorFailureRate = selectorFailures / denominator;
1729: 
1730:     const challengeCount = await getDailyStat(localDate, 'challenges_count');
1731:     const invitesSent = await getDailyStat(localDate, 'invites_sent');
1732:     const inviteVelocityRatio = hardInviteCap > 0 ? invitesSent / hardInviteCap : 0;
1733: 
1734:     return {
1735:         pendingRatio,
1736:         errorRate,
1737:         selectorFailureRate,
1738:         challengeCount,
1739:         inviteVelocityRatio,
1740:     };
1741: }
1742: 
1743: export interface JobWithPayload<T extends Record<string, unknown>> extends JobRecord {
1744:     payload: T;
1745: }
1746: 
1747: export function parseJobPayload<T extends Record<string, unknown>>(job: JobRecord): JobWithPayload<T> {
1748:     return {
1749:         ...job,
1750:         payload: parsePayload<T>(job.payload_json),
1751:     };
1752: }
1753: 
1754: 
1755: /**
1756:  * Al boot, resetta i job RUNNING bloccati da troppo tempo.
1757:  * Un job resta RUNNING se il processo viene killato durante l'esecuzione.
1758:  */
1759: export async function recoverStuckJobs(staleAfterMinutes: number = 30): Promise<number> {
1760:     const db = await getDatabase();
1761:     const result = await db.run(
1762:         `UPDATE jobs
1763:          SET status = 'QUEUED',
1764:              locked_at = NULL,
1765:              updated_at = CURRENT_TIMESTAMP,
1766:              last_error = 'Recovered from RUNNING on startup'
1767:          WHERE status = 'RUNNING'
1768:            AND (
1769:              locked_at IS NULL
1770:              OR locked_at <= DATETIME('now', '-' || ? || ' minutes')
1771:            )`,
1772:         [Math.max(1, staleAfterMinutes)]
1773:     );
1774:     return result.changes ?? 0;
1775: }
1776: 
1777: // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
1778: // Downsync (Cloud -> Local) Application
1779: // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
1780: 
1781: export async function applyCloudAccountUpdates(updates: CloudAccount[]): Promise<void> {
1782:     if (updates.length === 0) return;
1783:     const db = await getDatabase();
1784:     await withTransaction(db, async () => {
1785:         for (const acc of updates) {
1786:             await db.run(
1787:                 `
1788:                 UPDATE accounts
1789:                 SET
1790:                     tier = COALESCE(?, tier),
1791:                     health = COALESCE(?, health),
1792:                     quarantine_reason = COALESCE(?, quarantine_reason),
1793:                     quarantine_until = COALESCE(?, quarantine_until),
1794:                     updated_at = COALESCE(?, updated_at)
1795:                 WHERE id = ?
1796:                 `,
1797:                 [
1798:                     acc.tier,
1799:                     acc.health,
1800:                     acc.quarantine_reason,
1801:                     acc.quarantine_until,
1802:                     acc.updated_at || new Date().toISOString(),
1803:                     acc.id
1804:                 ]
1805:             );
1806:         }
1807:     });
1808: }
1809: 
1810: export async function applyCloudLeadUpdates(updates: CloudLeadUpsert[]): Promise<void> {
1811:     if (updates.length === 0) return;
1812:     const db = await getDatabase();
1813:     await withTransaction(db, async () => {
1814:         for (const l of updates) {
1815:             await db.run(
1816:                 `
1817:                 UPDATE leads
1818:                 SET
1819:                     status = COALESCE(?, status),
1820:                     invited_at = COALESCE(?, invited_at),
1821:                     accepted_at = COALESCE(?, accepted_at),
1822:                     messaged_at = COALESCE(?, messaged_at),
1823:                     last_error = COALESCE(?, last_error),
1824:                     blocked_reason = COALESCE(?, blocked_reason),
1825:                     lead_score = COALESCE(?, lead_score),
1826:                     confidence_score = COALESCE(?, confidence_score),
1827:                     updated_at = COALESCE(?, updated_at)
1828:                 WHERE linkedin_url = ?
1829:                 `,
1830:                 [
1831:                     l.status,
1832:                     l.invited_at,
1833:                     l.accepted_at,
1834:                     l.messaged_at,
1835:                     l.last_error,
1836:                     l.blocked_reason,
1837:                     l.lead_score,
1838:                     l.confidence_score,
1839:                     l.updated_at || new Date().toISOString(),
1840:                     l.linkedin_url
1841:                 ]
1842:             );
1843:         }
1844:     });
1845: }
1846: 
1847: // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
1848: // KPI Analytics
1849: // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
1850: 
1851: export interface GlobalKPIData {
1852:     totalLeads: number;
1853:     statusCounts: Record<string, number>;
1854:     activeCampaigns: number;
1855:     totalAcceptances7d: number;
1856: }
1857: 
1858: export async function getGlobalKPIData(): Promise<GlobalKPIData> {
1859:     const db = await getDatabase();
1860: 
1861:     // Status counts
1862:     const counts = await db.all(`
1863:         SELECT status, COUNT(*) as count FROM leads GROUP BY status
1864:     `) as Array<{ status: string; count: number }>;
1865: 
1866:     let totalLeads = 0;
1867:     const statusCounts: Record<string, number> = {};
1868:     for (const row of counts) {
1869:         statusCounts[row.status] = row.count;
1870:         totalLeads += row.count;
1871:     }
1872: 
1873:     // Active campaigns
1874:     const activeCamps = await db.get(`
1875:         SELECT COUNT(*) as count FROM lead_lists WHERE is_active = 1
1876:     `) as { count: number } | undefined;
1877: 
1878:     // Acceptances in last 7 days from daily_stats
1879:     const weeklyAcceptancesRow = await db.get(`
1880:         SELECT SUM(acceptances) as count 
1881:         FROM daily_stats 
1882:         WHERE date >= date('now', '-7 days')
1883:     `) as { count: number } | undefined;
1884: 
1885:     return {
1886:         totalLeads,
1887:         statusCounts,
1888:         activeCampaigns: activeCamps?.count ?? 0,
1889:         totalAcceptances7d: weeklyAcceptancesRow?.count ?? 0
1890:     };
1891: }
1892: 
1893: export async function startCampaignRun(): Promise<number> {
1894:     const db = await getDatabase();
1895:     const result = await db.run(`
1896:         INSERT INTO campaign_runs (start_time, status)
1897:         VALUES (strftime('%Y-%m-%dT%H:%M:%f', 'now'), 'RUNNING')
1898:     `);
1899:     if (!result.lastID) {
1900:         throw new Error('Failed to create campaign run record');
1901:     }
1902:     return result.lastID;
1903: }
1904: 
1905: export interface CampaignRunMetrics {
1906:     discovered: number;
1907:     invites: number;
1908:     messages: number;
1909:     errors: number;
1910: }
1911: 
1912: export async function finishCampaignRun(runId: number, status: RunStatus, metrics: CampaignRunMetrics): Promise<void> {
1913:     const db = await getDatabase();
1914:     await db.run(
1915:         `
1916:         UPDATE campaign_runs
1917:         SET 
1918:             end_time = strftime('%Y-%m-%dT%H:%M:%f', 'now'),
1919:             status = ?,
1920:             profiles_discovered = ?,
1921:             invites_sent = ?,
1922:             messages_sent = ?,
1923:             errors_count = ?
1924:         WHERE id = ?
1925:     `,
1926:         [status, metrics.discovered, metrics.invites, metrics.messages, metrics.errors, runId]
1927:     );
1928: }
1929: 
1930: export async function getABTestingStats(): Promise<ABTestStats[]> {
1931:     const db = await getDatabase();
1932: 
1933:     // Group by invite_prompt_variant where status > INVITED
1934:     // Count total as totalSent
1935:     // Count ACCEPTED + READY_MESSAGE + MESSAGED + REPLIED + CONNECTED as accepted
1936:     // Count REPLIED as replied
1937:     const rows = await db.all<{ variant: string, totalSent: number, totalAccepted: number, totalReplied: number }[]>(`
1938:         SELECT 
1939:             COALESCE(invite_prompt_variant, 'default') as variant,
1940:             COUNT(id) as totalSent,
1941:             SUM(CASE WHEN status IN ('ACCEPTED', 'READY_MESSAGE', 'MESSAGED', 'REPLIED', 'CONNECTED') THEN 1 ELSE 0 END) as totalAccepted,
1942:             SUM(CASE WHEN status IN ('REPLIED', 'CONNECTED') THEN 1 ELSE 0 END) as totalReplied
1943:         FROM leads
1944:         WHERE status NOT IN ('NEW', 'READY_INVITE', 'REVIEW_REQUIRED', 'SKIPPED', 'BLOCKED', 'DEAD', 'WITHDRAWN', 'PENDING')
1945:           AND invite_prompt_variant IS NOT NULL
1946:         GROUP BY COALESCE(invite_prompt_variant, 'default')
1947:         ORDER BY totalSent DESC
1948:     `);
1949: 
1950:     return rows.map(r => {
1951:         const totalSent = r.totalSent || 0;
1952:         const totalAccepted = r.totalAccepted || 0;
1953:         const totalReplied = r.totalReplied || 0;
1954: 
1955:         return {
1956:             variant: r.variant,
1957:             totalSent,
1958:             totalAccepted,
1959:             totalReplied,
1960:             acceptanceRate: totalSent > 0 ? (totalAccepted / totalSent) * 100 : 0,
1961:             replyRate: totalSent > 0 ? (totalReplied / totalSent) * 100 : 0
1962:         };
1963:     });
1964: }
1965: 
1966: export async function getAccountAgeDays(): Promise<number> {
1967:     const db = await getDatabase();
1968:     const row = await db.get<{ firstDate: string }>(`
1969:         SELECT MIN(created_at) as firstDate FROM leads
1970:     `);
1971: 
1972:     if (!row || !row.firstDate) {
1973:         return 0; // Se non ci sono leads, l'account ha 0 giorni
1974:     }
1975: 
1976:     const firstDate = new Date(row.firstDate + 'Z'); // Convert from SQLite string to Date
1977:     const now = new Date();
1978:     const diffMs = now.getTime() - firstDate.getTime();
1979: 
1980:     // Ritorna l'et√† in giorni interi
1981:     return Math.max(0, Math.floor(diffMs / (1000 * 60 * 60 * 24)));
1982: }
````

## File: src/index.ts
````typescript
   1: import { closeDatabase, initDatabase, backupDatabase } from './db';
   2: import { config, getLocalDateString } from './config';
   3: import { checkLogin, closeBrowser as closeBrowserSession, detectChallenge, humanDelay, isLoggedIn, launchBrowser } from './browser';
   4: import { randomUUID } from 'crypto';
   5: import { importLeadsFromCSV } from './csvImporter';
   6: import { buildFunnelReport, runSiteCheck } from './core/audit';
   7: import { runCompanyEnrichmentBatch } from './core/companyEnrichment';
   8: import { runWorkflow } from './core/orchestrator';
   9: import { runDoctor } from './core/doctor';
  10: import { runSalesNavigatorListSync } from './core/salesNavigatorSync';
  11: import { reconcileLeadStatus } from './core/leadStateService';
  12: import { warmupSession } from './core/sessionWarmer';
  13: import {
  14:     acquireRuntimeLock,
  15:     cleanupPrivacyData,
  16:     countCompanyTargets,
  17:     getAutomationPauseState,
  18:     getDailyStatsSnapshot,
  19:     getLeadById,
  20:     getJobStatusCounts,
  21:     getSalesNavListByName,
  22:     getRuntimeLock,
  23:     getRuntimeFlag,
  24:     getLeadsWithSalesNavigatorUrls,
  25:     heartbeatRuntimeLock,
  26:     linkLeadToSalesNavList,
  27:     listCompanyTargets,
  28:     listLeadCampaignConfigs,
  29:     listOpenIncidents,
  30:     listSalesNavLists,
  31:     releaseRuntimeLock,
  32:     recoverStuckJobs,
  33:     resolveIncident,
  34:     clearAutomationPause as clearPauseState,
  35:     setAutomationPause,
  36:     setRuntimeFlag,
  37:     upsertSalesNavList,
  38:     updateLeadLinkedinUrl,
  39:     updateLeadCampaignConfig,
  40:     startCampaignRun,
  41:     finishCampaignRun,
  42: } from './core/repositories';
  43: import { RunStatus } from './types/domain';
  44: import { setQuarantine } from './risk/incidentManager';
  45: import { getEventSyncStatus, runEventSyncOnce } from './sync/eventSync';
  46: import { WorkflowSelection } from './core/scheduler';
  47: import { isProfileUrl, isSalesNavigatorUrl, normalizeLinkedInUrl } from './linkedinUrl';
  48: import { Page } from 'playwright';
  49: import { getAccountProfileById, getRuntimeAccountProfiles } from './accountManager';
  50: import { getProxyFailoverChain, getProxyPoolStatus } from './proxyManager';
  51: import { runRandomLinkedinActivity } from './workers/randomActivityWorker';
  52: import { addLeadToSalesNavList, createSalesNavList } from './salesnav/listActions';
  53: import { isOpenAIConfigured } from './ai/openaiClient';
  54: import { startTelegramListener } from './cloud/telegramListener';
  55: import { markTelegramCommandProcessed, pollPendingTelegramCommand } from './cloud/supabaseDataClient';
  56: import { generateAndSendDailyReport } from './telemetry/dailyReporter';
  57: import { startServer } from './api/server';
  58: 
  59: // Graceful shutdown: chiude DB prima di uscire per non lasciare job RUNNING.
  60: let shuttingDown = false;
  61: function setupGracefulShutdown(): void {
  62:     const handler = async (signal: string): Promise<void> => {
  63:         if (shuttingDown) return;
  64:         shuttingDown = true;
  65:         console.warn(`[SIGNAL] ${signal} ricevuto ‚Äî chiusura in corso...`);
  66:         await closeDatabase();
  67:         process.exit(0);
  68:     };
  69:     process.on('SIGINT', () => { void handler('SIGINT'); });
  70:     process.on('SIGTERM', () => { void handler('SIGTERM'); });
  71: }
  72: 
  73: function getOptionValue(args: string[], optionName: string): string | undefined {
  74:     const index = args.findIndex((value) => value === optionName);
  75:     if (index === -1 || index + 1 >= args.length) {
  76:         return undefined;
  77:     }
  78:     return args[index + 1];
  79: }
  80: 
  81: function hasOption(args: string[], optionName: string): boolean {
  82:     return args.includes(optionName);
  83: }
  84: 
  85: function parseWorkflow(input: string | undefined): WorkflowSelection {
  86:     if (input === 'invite' || input === 'check' || input === 'message' || input === 'warmup' || input === 'all') {
  87:         return input;
  88:     }
  89:     return 'all';
  90: }
  91: 
  92: function parseIntStrict(raw: string, optionName: string): number {
  93:     const parsed = Number.parseInt(raw, 10);
  94:     if (!Number.isFinite(parsed)) {
  95:         throw new Error(`Valore non valido per ${optionName}: ${raw} `);
  96:     }
  97:     return parsed;
  98: }
  99: 
 100: function parseNullableCap(raw: string, optionName: string): number | null {
 101:     const normalized = raw.trim().toLowerCase();
 102:     if (normalized === 'none' || normalized === 'null' || normalized === 'off' || normalized === '-1') {
 103:         return null;
 104:     }
 105:     const parsed = parseIntStrict(raw, optionName);
 106:     if (parsed < 0) {
 107:         throw new Error(`${optionName} deve essere >= 0 oppure none / null / off.`);
 108:     }
 109:     return parsed;
 110: }
 111: 
 112: function parsePauseMinutes(raw: string, optionName: string): number | null {
 113:     const normalized = raw.trim().toLowerCase();
 114:     if (normalized === 'none' || normalized === 'null' || normalized === 'off' || normalized === 'indefinite') {
 115:         return null;
 116:     }
 117:     const parsed = parseIntStrict(raw, optionName);
 118:     if (parsed < 1) {
 119:         throw new Error(`${optionName} deve essere >= 1 oppure none / null / off / indefinite.`);
 120:     }
 121:     return parsed;
 122: }
 123: 
 124: function parseBoolStrict(raw: string, optionName: string): boolean {
 125:     const normalized = raw.trim().toLowerCase();
 126:     if (normalized === 'true' || normalized === '1' || normalized === 'yes') return true;
 127:     if (normalized === 'false' || normalized === '0' || normalized === 'no') return false;
 128:     throw new Error(`Valore non valido per ${optionName}: ${raw} (usa true / false).`);
 129: }
 130: 
 131: function getWorkflowValue(args: string[]): string | undefined {
 132:     const explicit = getOptionValue(args, '--workflow');
 133:     if (explicit) {
 134:         return explicit;
 135:     }
 136:     const positional = args.find((value) => !value.startsWith('--'));
 137:     return positional;
 138: }
 139: 
 140: function getPositionalArgs(args: string[]): string[] {
 141:     return args.filter((value) => !value.startsWith('--'));
 142: }
 143: 
 144: function sleep(ms: number): Promise<void> {
 145:     return new Promise((resolve) => setTimeout(resolve, ms));
 146: }
 147: 
 148: interface SalesNavResolveItem {
 149:     leadId: number;
 150:     status: string;
 151:     currentUrl: string;
 152:     resolvedProfileUrl: string | null;
 153:     action: 'resolved' | 'updated' | 'conflict' | 'unresolved' | 'challenge_detected' | 'error';
 154:     conflictLeadId?: number | null;
 155:     error?: string;
 156: }
 157: 
 158: interface SalesNavResolveReport {
 159:     scanned: number;
 160:     resolvable: number;
 161:     updated: number;
 162:     conflicts: number;
 163:     unresolved: number;
 164:     challengeDetected: boolean;
 165:     fix: boolean;
 166:     dryRun: boolean;
 167:     items: SalesNavResolveItem[];
 168: }
 169: 
 170: async function collectProfileUrlCandidates(page: Page): Promise<string[]> {
 171:     const candidates = new Set<string>();
 172: 
 173:     const currentUrl = page.url();
 174:     if (currentUrl) candidates.add(currentUrl);
 175: 
 176:     const canonicalHref = await page.locator('link[rel="canonical"]').first().getAttribute('href').catch(() => null);
 177:     if (canonicalHref) candidates.add(canonicalHref);
 178: 
 179:     const ogUrl = await page.locator('meta[property="og:url"]').first().getAttribute('content').catch(() => null);
 180:     if (ogUrl) candidates.add(ogUrl);
 181: 
 182:     const anchors = await page.evaluate(() => {
 183:         return Array.from(document.querySelectorAll('a[href]'))
 184:             .map((node) => (node as HTMLAnchorElement).href)
 185:             .filter((href) => typeof href === 'string' && href.length > 0);
 186:     }).catch(() => [] as string[]);
 187: 
 188:     for (const href of anchors) {
 189:         candidates.add(href);
 190:     }
 191: 
 192:     return Array.from(candidates);
 193: }
 194: 
 195: function pickResolvedProfileUrl(candidates: string[]): string | null {
 196:     for (const candidate of candidates) {
 197:         const normalized = normalizeLinkedInUrl(candidate);
 198:         if (!isProfileUrl(normalized)) continue;
 199:         if (isSalesNavigatorUrl(normalized)) continue;
 200:         return normalized;
 201:     }
 202:     return null;
 203: }
 204: 
 205: function getRecoveryStatusFromBlockedReason(reason: string | null): 'READY_INVITE' | 'INVITED' | 'READY_MESSAGE' | null {
 206:     const normalized = (reason ?? '').toLowerCase();
 207:     if (normalized.includes('salesnav_url_requires_profile_invite')) {
 208:         return 'READY_INVITE';
 209:     }
 210:     if (normalized.includes('salesnav_url_requires_profile_check')) {
 211:         return 'INVITED';
 212:     }
 213:     if (normalized.includes('salesnav_url_requires_profile_message')) {
 214:         return 'READY_MESSAGE';
 215:     }
 216:     return null;
 217: }
 218: 
 219: const WORKFLOW_RUNNER_LOCK_KEY = 'workflow.runner';
 220: const WORKFLOW_RUNNER_MIN_TTL_SECONDS = 120;
 221: const WORKFLOW_RUNNER_HEARTBEAT_MS = 30_000;
 222: const AUTO_SITE_CHECK_LAST_RUN_KEY = 'site_check.last_run_at';
 223: const SALESNAV_LAST_SYNC_KEY = 'salesnav.last_sync_at';
 224: 
 225: function createLockOwnerId(command: string): string {
 226:     const suffix = randomUUID().split('-')[0];
 227:     return `${command}:${process.pid}:${suffix} `;
 228: }
 229: 
 230: function computeWorkflowLockTtlSeconds(intervalMs: number): number {
 231:     return Math.max(WORKFLOW_RUNNER_MIN_TTL_SECONDS, Math.ceil(intervalMs / 1000) + 120);
 232: }
 233: 
 234: async function acquireWorkflowRunnerLock(command: string, ttlSeconds: number, metadata: Record<string, unknown>): Promise<string> {
 235:     const ownerId = createLockOwnerId(command);
 236:     const result = await acquireRuntimeLock(WORKFLOW_RUNNER_LOCK_KEY, ownerId, ttlSeconds, metadata);
 237:     if (!result.acquired) {
 238:         const holder = result.lock;
 239:         throw new Error(
 240:             `[LOCK] Runner gi√† attivo.owner = ${holder?.owner_id ?? 'unknown'} heartbeat = ${holder?.heartbeat_at ?? 'n/a'} expires = ${holder?.expires_at ?? 'n/a'} `
 241:         );
 242:     }
 243:     console.log(`[LOCK] acquired key = ${WORKFLOW_RUNNER_LOCK_KEY} owner = ${ownerId} ttl = ${ttlSeconds} s`);
 244:     return ownerId;
 245: }
 246: 
 247: async function heartbeatWorkflowRunnerLock(ownerId: string, ttlSeconds: number): Promise<void> {
 248:     const ok = await heartbeatRuntimeLock(WORKFLOW_RUNNER_LOCK_KEY, ownerId, ttlSeconds);
 249:     if (!ok) {
 250:         throw new Error('[LOCK] Runtime lock perso durante l\'esecuzione.');
 251:     }
 252: }
 253: 
 254: async function releaseWorkflowRunnerLock(ownerId: string): Promise<void> {
 255:     const released = await releaseRuntimeLock(WORKFLOW_RUNNER_LOCK_KEY, ownerId);
 256:     console.log(`[LOCK] released key = ${WORKFLOW_RUNNER_LOCK_KEY} owner = ${ownerId} released = ${released} `);
 257: }
 258: 
 259: async function sleepWithLockHeartbeat(totalMs: number, ownerId: string, ttlSeconds: number): Promise<void> {
 260:     let remaining = Math.max(0, totalMs);
 261:     while (remaining > 0) {
 262:         const chunk = Math.min(WORKFLOW_RUNNER_HEARTBEAT_MS, remaining);
 263:         await sleep(chunk);
 264:         remaining -= chunk;
 265:         if (remaining > 0) {
 266:             await heartbeatWorkflowRunnerLock(ownerId, ttlSeconds);
 267:         }
 268:     }
 269: }
 270: 
 271: interface LoopDoctorGate {
 272:     proceed: boolean;
 273:     reason: string;
 274: }
 275: 
 276: interface AutoSiteCheckDecision {
 277:     shouldRun: boolean;
 278:     reason: string;
 279:     hoursSinceLastRun: number | null;
 280: }
 281: 
 282: interface SalesNavSyncDecision {
 283:     shouldRun: boolean;
 284:     reason: string;
 285:     hoursSinceLastRun: number | null;
 286: }
 287: 
 288: async function evaluateAutoSiteCheckDecision(dryRun: boolean): Promise<AutoSiteCheckDecision> {
 289:     if (dryRun) {
 290:         return { shouldRun: false, reason: 'dry_run', hoursSinceLastRun: null };
 291:     }
 292:     if (!config.autoSiteCheckEnabled) {
 293:         return { shouldRun: false, reason: 'auto_site_check_disabled', hoursSinceLastRun: null };
 294:     }
 295: 
 296:     const lastRunRaw = await getRuntimeFlag(AUTO_SITE_CHECK_LAST_RUN_KEY);
 297:     if (!lastRunRaw) {
 298:         return { shouldRun: true, reason: 'never_run', hoursSinceLastRun: null };
 299:     }
 300: 
 301:     const parsedMs = Date.parse(lastRunRaw);
 302:     if (!Number.isFinite(parsedMs)) {
 303:         return { shouldRun: true, reason: 'invalid_last_run', hoursSinceLastRun: null };
 304:     }
 305: 
 306:     const elapsedHours = (Date.now() - parsedMs) / (1000 * 60 * 60);
 307:     if (elapsedHours >= config.autoSiteCheckIntervalHours) {
 308:         return {
 309:             shouldRun: true,
 310:             reason: 'interval_elapsed',
 311:             hoursSinceLastRun: Number.parseFloat(elapsedHours.toFixed(2)),
 312:         };
 313:     }
 314: 
 315:     return {
 316:         shouldRun: false,
 317:         reason: 'interval_not_elapsed',
 318:         hoursSinceLastRun: Number.parseFloat(elapsedHours.toFixed(2)),
 319:     };
 320: }
 321: 
 322: async function evaluateSalesNavSyncDecision(dryRun: boolean): Promise<SalesNavSyncDecision> {
 323:     if (dryRun) {
 324:         return { shouldRun: false, reason: 'dry_run', hoursSinceLastRun: null };
 325:     }
 326:     if (!config.salesNavSyncEnabled) {
 327:         return { shouldRun: false, reason: 'salesnav_sync_disabled', hoursSinceLastRun: null };
 328:     }
 329: 
 330:     const lastRunRaw = await getRuntimeFlag(SALESNAV_LAST_SYNC_KEY);
 331:     if (!lastRunRaw) {
 332:         return { shouldRun: true, reason: 'never_run', hoursSinceLastRun: null };
 333:     }
 334: 
 335:     const parsedMs = Date.parse(lastRunRaw);
 336:     if (!Number.isFinite(parsedMs)) {
 337:         return { shouldRun: true, reason: 'invalid_last_run', hoursSinceLastRun: null };
 338:     }
 339: 
 340:     const elapsedHours = (Date.now() - parsedMs) / (1000 * 60 * 60);
 341:     if (elapsedHours >= config.salesNavSyncIntervalHours) {
 342:         return {
 343:             shouldRun: true,
 344:             reason: 'interval_elapsed',
 345:             hoursSinceLastRun: Number.parseFloat(elapsedHours.toFixed(2)),
 346:         };
 347:     }
 348: 
 349:     return {
 350:         shouldRun: false,
 351:         reason: 'interval_not_elapsed',
 352:         hoursSinceLastRun: Number.parseFloat(elapsedHours.toFixed(2)),
 353:     };
 354: }
 355: 
 356: async function evaluateLoopDoctorGate(dryRun: boolean): Promise<LoopDoctorGate> {
 357:     if (dryRun) {
 358:         return { proceed: true, reason: 'dry_run' };
 359:     }
 360: 
 361:     const report = await runDoctor();
 362:     const syncOk = !report.sync.enabled || report.sync.configured;
 363:     if (!report.sessionLoginOk) {
 364:         return { proceed: false, reason: 'doctor_login_missing' };
 365:     }
 366:     if (report.quarantine) {
 367:         return { proceed: false, reason: 'doctor_quarantine_active' };
 368:     }
 369:     if (!syncOk) {
 370:         return { proceed: false, reason: 'doctor_sync_not_configured' };
 371:     }
 372:     if (!report.compliance.ok) {
 373:         return { proceed: false, reason: 'doctor_compliance_violation' };
 374:     }
 375:     return { proceed: true, reason: 'doctor_ok' };
 376: }
 377: 
 378: async function processCloudCommands(): Promise<void> {
 379:     const activeProfiles = getRuntimeAccountProfiles();
 380:     for (const profile of activeProfiles) {
 381:         try {
 382:             const cmd = await pollPendingTelegramCommand(profile.id);
 383:             if (!cmd) continue;
 384: 
 385:             console.log(`[CLOUD] Comando ricevuto: ${cmd.command} args: ${cmd.args || 'nessuno'} (account: ${profile.id})`);
 386: 
 387:             if (cmd.command === 'pausa' || cmd.command === 'pause') {
 388:                 const minutes = cmd.args && /^[0-9]+$/.test(cmd.args) ? parseInt(cmd.args, 10) : null;
 389:                 await setAutomationPause(minutes || null, 'TELEGRAM_COMMAND');
 390:                 console.log(`[CLOUD] Automazione globale in pausa ${minutes ? 'per ' + minutes + ' min' : 'indefinitamente'}.`);
 391:             } else if (cmd.command === 'riprendi' || cmd.command === 'resume') {
 392:                 await clearPauseState();
 393:                 console.log(`[CLOUD] Automazione globale ripresa.`);
 394:             } else if (cmd.command === 'restart') {
 395:                 console.warn('[CLOUD] Restart comandato. Uscita 0...');
 396:                 process.exit(0);
 397:             }
 398: 
 399:             await markTelegramCommandProcessed(cmd.id);
 400:         } catch (e) {
 401:             console.error(`[CLOUD] Errore elaborazione comando per account ${profile.id}:`, e);
 402:         }
 403:     }
 404: }
 405: 
 406: function printHelp(): void {
 407:     console.log('Utilizzo consigliato (Windows): .\\bot.ps1 <comando> [opzioni]');
 408:     console.log('Alternativa: npx ts-node src/index.ts <comando> [opzioni]');
 409:     console.log('Compatibilit√†: npm start -- <comando> [opzioni]');
 410:     console.log('Comandi principali:');
 411:     console.log('  import --file <file.csv> --list <nome_lista>');
 412:     console.log('  run invite|check|message|all (oppure --workflow <valore>)');
 413:     console.log('  dry-run invite|check|message|all (oppure --workflow <valore>)');
 414:     console.log('  run-loop [workflow] [intervalSec] [--cycles <n>] [--dry-run]');
 415:     console.log('  autopilot [intervalSec] [--cycles <n>] [--dry-run]');
 416:     console.log('  login [timeoutSec] [--account <id_account>]');
 417:     console.log('  doctor');
 418:     console.log('  status');
 419:     console.log('  proxy-status');
 420:     console.log('  funnel');
 421:     console.log('  site-check [limit] [--fix]');
 422:     console.log('  state-sync [limit] [--fix]');
 423:     console.log('  salesnav-resolve [limit] [--fix] [--dry-run]');
 424:     console.log('  salesnav-sync [listName] [--url <salesnav_list_url>] [--max-pages <n>] [--limit <n>] [--account <id>] [--dry-run]');
 425:     console.log('  salesnav-lists [--limit <n>]');
 426:     console.log('  salesnav-create-list <nome> [--account <id>]');
 427:     console.log('  salesnav-add-lead <leadId> <listName> [--account <id>]');
 428:     console.log('  salesnav-add-to-list <leadId> <listName> [--account <id>]  # alias');
 429:     console.log('  random-activity [--account <id>] [--max-actions <n>] [--dry-run]');
 430:     console.log('  enrich-targets [limit] [--dry-run]');
 431:     console.log('  pause [minutes|indefinite] [reason]');
 432:     console.log('  resume');
 433:     console.log('  unquarantine');
 434:     console.log('  incidents [open]');
 435:     console.log('  incident-resolve <id>');
 436:     console.log('  privacy-cleanup [days]');
 437:     console.log('  lists');
 438:     console.log('  company-targets [list] [limit]');
 439:     console.log('  list-config <nome_lista> [priority] [inviteCap|none] [messageCap|none] [active]');
 440:     console.log('    (oppure con opzioni: --list, --priority, --invite-cap, --message-cap, --active)');
 441:     console.log('  sync-status');
 442:     console.log('  sync-run-once');
 443:     console.log('  db-backup');
 444:     console.log('Alias retrocompatibili: connect, check, message');
 445: }
 446: 
 447: async function runImportCommand(args: string[]): Promise<void> {
 448:     const legacyPath = args[0] && !args[0].startsWith('--') ? args[0] : undefined;
 449:     const filePath = getOptionValue(args, '--file') ?? legacyPath;
 450:     const listName = getOptionValue(args, '--list') ?? 'default';
 451: 
 452:     if (!filePath) {
 453:         throw new Error('Specifica il CSV: npm start -- import --file path/to/file.csv --list nome_lista');
 454:     }
 455: 
 456:     const result = await importLeadsFromCSV(filePath, listName);
 457:     console.log(
 458:         `Import completato.Lead inseriti = ${result.inserted}, Company target inseriti = ${result.companyTargetsInserted}, Skippati = ${result.skipped}, Lista = ${listName} `
 459:     );
 460: }
 461: 
 462: async function runLoginCommand(args: string[]): Promise<void> {
 463:     const positional = getPositionalArgs(args);
 464:     const positionalTimeout = positional.find((value) => /^\d+$/.test(value));
 465:     const positionalAccount = positional.find((value) => !/^\d+$/.test(value));
 466:     const timeoutRaw = getOptionValue(args, '--timeout') ?? positionalTimeout;
 467:     const timeoutSeconds = timeoutRaw ? Math.max(30, parseIntStrict(timeoutRaw, '--timeout')) : 300;
 468:     const timeoutMs = timeoutSeconds * 1000;
 469:     const accountRaw = getOptionValue(args, '--account') ?? positionalAccount;
 470:     const selectedAccount = getAccountProfileById(accountRaw);
 471:     const availableAccounts = getRuntimeAccountProfiles().map((account) => account.id);
 472:     if (accountRaw && accountRaw !== selectedAccount.id) {
 473:         console.warn(`[LOGIN] account = ${accountRaw} non trovato.Uso account = ${selectedAccount.id}.Disponibili: ${availableAccounts.join(', ')} `);
 474:     }
 475: 
 476:     const session = await launchBrowser({
 477:         headless: false,
 478:         sessionDir: selectedAccount.sessionDir,
 479:         proxy: selectedAccount.proxy,
 480:     });
 481:     try {
 482:         await session.page.goto('https://www.linkedin.com/login', { waitUntil: 'load' });
 483:         console.log(`Completa il login LinkedIn nella finestra aperta(account = ${selectedAccount.id}, timeout ${timeoutSeconds}s)...`);
 484:         console.log('Il browser resta aperto finch√© il login non viene verificato o finch√© scade il timeout.');
 485: 
 486:         const startedAt = Date.now();
 487:         let lastLogAt = 0;
 488:         while (Date.now() - startedAt <= timeoutMs) {
 489:             if (await isLoggedIn(session.page)) {
 490:                 const confirmed = await checkLogin(session.page);
 491:                 if (confirmed) {
 492:                     console.log('Login sessione completato con successo.');
 493:                     return;
 494:                 }
 495:             }
 496:             const now = Date.now();
 497:             if (now - lastLogAt >= 15_000) {
 498:                 const remaining = Math.max(0, Math.ceil((timeoutMs - (now - startedAt)) / 1000));
 499:                 console.log(`In attesa completamento login... (${remaining}s rimanenti)`);
 500:                 lastLogAt = now;
 501:             }
 502:             await session.page.waitForTimeout(2500);
 503:         }
 504: 
 505:         // Ultimo controllo esplicito sulla home LinkedIn.
 506:         const loggedIn = await checkLogin(session.page);
 507:         if (!loggedIn) {
 508:             throw new Error(`Login non rilevato entro ${timeoutSeconds} secondi.`);
 509:         }
 510:         console.log('Login sessione completato con successo.');
 511:     } finally {
 512:         await closeBrowserSession(session);
 513:     }
 514: }
 515: 
 516: async function runLoopCommand(args: string[]): Promise<void> {
 517:     const workflow = parseWorkflow(getWorkflowValue(args));
 518:     const positional = getPositionalArgs(args);
 519:     const workflowTokens = new Set(['invite', 'check', 'message', 'all']);
 520:     const numericPositionals = positional.filter((value) => /^\d+$/.test(value));
 521:     const intervalMsRaw = getOptionValue(args, '--interval-ms');
 522:     const intervalSecRaw = getOptionValue(args, '--interval-sec');
 523:     const cyclesRaw = getOptionValue(args, '--cycles') ?? numericPositionals[1];
 524:     const dryRun = hasOption(args, '--dry-run') || positional.some((value) => value.toLowerCase() === 'dry' || value.toLowerCase() === 'dry-run');
 525: 
 526:     let intervalMs = config.workflowLoopIntervalMs;
 527:     if (intervalMsRaw) {
 528:         intervalMs = Math.max(10_000, parseIntStrict(intervalMsRaw, '--interval-ms'));
 529:     } else if (intervalSecRaw) {
 530:         intervalMs = Math.max(10, parseIntStrict(intervalSecRaw, '--interval-sec')) * 1000;
 531:     } else {
 532:         const numericPositional = positional.find((value) => !workflowTokens.has(value) && /^\d+$/.test(value));
 533:         if (numericPositional) {
 534:             intervalMs = Math.max(10, parseIntStrict(numericPositional, 'intervalSec')) * 1000;
 535:         }
 536:     }
 537: 
 538:     const maxCycles = cyclesRaw ? Math.max(1, parseIntStrict(cyclesRaw, '--cycles')) : null;
 539:     console.log(`[LOOP] start workflow = ${workflow} dryRun = ${dryRun} intervalMs = ${intervalMs} cycles = ${maxCycles ?? 'infinite'} `);
 540: 
 541:     // Avvio Poller Telegram (interno o webhook) in background a inizio loop
 542:     if (!dryRun) {
 543:         await startTelegramListener().catch(e => console.error('[TELEGRAM] Errore listener background', e));
 544:     }
 545: 
 546:     const lockTtlSeconds = computeWorkflowLockTtlSeconds(intervalMs);
 547:     const lockOwnerId = dryRun
 548:         ? null
 549:         : await acquireWorkflowRunnerLock('run-loop', lockTtlSeconds, {
 550:             workflow,
 551:             dryRun,
 552:             intervalMs,
 553:             startedAt: new Date().toISOString(),
 554:         });
 555: 
 556:     try {
 557:         let cycle = 0;
 558:         while (true) {
 559:             cycle += 1;
 560:             const started = new Date().toISOString();
 561:             console.log(`[LOOP] cycle = ${cycle} started_at = ${started} `);
 562: 
 563:             let runId: number | null = null;
 564:             let profilesDiscoveredThisRun = 0;
 565:             let runStatus: RunStatus = 'RUNNING';
 566:             const localDate = getLocalDateString();
 567:             const preStats = await getDailyStatsSnapshot(localDate);
 568:             if (!dryRun) {
 569:                 runId = await startCampaignRun();
 570:             }
 571: 
 572:             try {
 573:                 if (lockOwnerId) {
 574:                     await heartbeatWorkflowRunnerLock(lockOwnerId, lockTtlSeconds);
 575:                 }
 576: 
 577:                 if (!dryRun) {
 578:                     await processCloudCommands();
 579:                 }
 580: 
 581:                 const doctorGate = await evaluateLoopDoctorGate(dryRun);
 582:                 if (!doctorGate.proceed) {
 583:                     console.warn(`[LOOP] cycle = ${cycle} skipped reason = ${doctorGate.reason} `);
 584:                 } else {
 585:                     const autoSiteCheck = await evaluateAutoSiteCheckDecision(dryRun);
 586:                     if (autoSiteCheck.shouldRun) {
 587:                         const siteCheckReport = await runSiteCheck({
 588:                             limitPerStatus: config.autoSiteCheckLimit,
 589:                             autoFix: config.autoSiteCheckFix,
 590:                         });
 591:                         await setRuntimeFlag(AUTO_SITE_CHECK_LAST_RUN_KEY, new Date().toISOString());
 592:                         console.log('[LOOP] auto-site-check', {
 593:                             reason: autoSiteCheck.reason,
 594:                             intervalHours: config.autoSiteCheckIntervalHours,
 595:                             limitPerStatus: config.autoSiteCheckLimit,
 596:                             staleDays: config.siteCheckStaleDays,
 597:                             autoFix: config.autoSiteCheckFix,
 598:                             report: siteCheckReport,
 599:                         });
 600: 
 601:                         // Sostituiamo il vecchio decoy pattern basilare con il nuovo motore avanzato Session Warming
 602:                         if (!dryRun) {
 603:                             try {
 604:                                 const warmupSessionInstance = await launchBrowser({ headless: config.headless });
 605:                                 try {
 606:                                     await warmupSession(warmupSessionInstance.page);
 607:                                 } finally {
 608:                                     await closeBrowserSession(warmupSessionInstance);
 609:                                 }
 610:                             } catch (e) {
 611:                                 console.log('[LOOP] Errore nel Session Warmer, ignoro (non fatale):', e);
 612:                             }
 613:                         }
 614:                     } else {
 615:                         console.log('[LOOP] auto-site-check skipped', autoSiteCheck);
 616:                     }
 617: 
 618:                     if (config.salesNavSyncEnabled && (workflow === 'all' || workflow === 'invite')) {
 619:                         const salesNavDecision = await evaluateSalesNavSyncDecision(dryRun);
 620:                         if (salesNavDecision.shouldRun) {
 621:                             const salesNavSyncReport = await runSalesNavigatorListSync({
 622:                                 listName: config.salesNavSyncListName,
 623:                                 listUrl: config.salesNavSyncListUrl || undefined,
 624:                                 maxPages: config.salesNavSyncMaxPages,
 625:                                 maxLeadsPerList: config.salesNavSyncLimit,
 626:                                 dryRun,
 627:                                 accountId: config.salesNavSyncAccountId || undefined,
 628:                             });
 629:                             await setRuntimeFlag(SALESNAV_LAST_SYNC_KEY, new Date().toISOString());
 630:                             console.log('[LOOP] salesnav-sync', {
 631:                                 reason: salesNavDecision.reason,
 632:                                 intervalHours: config.salesNavSyncIntervalHours,
 633:                                 limitPerList: config.salesNavSyncLimit,
 634:                                 report: salesNavSyncReport,
 635:                             });
 636:                         } else {
 637:                             console.log('[LOOP] salesnav-sync skipped', salesNavDecision);
 638:                         }
 639:                     }
 640: 
 641:                     // Auto-Backup Giornaliero SQLite
 642:                     if (!dryRun) {
 643:                         const AUTO_BACKUP_LAST_RUN_KEY = 'db_backup.last_run_at';
 644:                         const backupLastRunRaw = await getRuntimeFlag(AUTO_BACKUP_LAST_RUN_KEY);
 645:                         const shouldRunBackup = !backupLastRunRaw || (Date.now() - Date.parse(backupLastRunRaw)) > 24 * 60 * 60 * 1000;
 646:                         if (shouldRunBackup) {
 647:                             try {
 648:                                 const backupPath = await backupDatabase();
 649:                                 await setRuntimeFlag(AUTO_BACKUP_LAST_RUN_KEY, new Date().toISOString());
 650:                                 console.log(`[LOOP] Auto - backup giornaliero completato: ${backupPath} `);
 651:                             } catch (e) {
 652:                                 console.error(`[LOOP] Auto - backup fallito`, e);
 653:                             }
 654:                         }
 655:                     }
 656: 
 657:                     if (config.companyEnrichmentEnabled && (workflow === 'all' || workflow === 'invite')) {
 658:                         const enrichment = await runCompanyEnrichmentBatch({
 659:                             limit: config.companyEnrichmentBatch,
 660:                             maxProfilesPerCompany: config.companyEnrichmentMaxProfilesPerCompany,
 661:                             dryRun,
 662:                         });
 663:                         profilesDiscoveredThisRun += enrichment.createdLeads;
 664:                         console.log('[LOOP] enrichment', enrichment);
 665:                     }
 666:                     await runWorkflow({ workflow, dryRun });
 667: 
 668:                     if (!dryRun && config.randomActivityEnabled && Math.random() <= config.randomActivityProbability) {
 669:                         const randomActivityReport = await runRandomLinkedinActivity({
 670:                             accountId: config.salesNavSyncAccountId || undefined,
 671:                             maxActions: config.randomActivityMaxActions,
 672:                             dryRun,
 673:                         });
 674:                         console.log('[LOOP] random-activity', randomActivityReport);
 675:                     }
 676: 
 677:                     runStatus = 'SUCCESS';
 678:                     console.log(`[LOOP] cycle = ${cycle} completed`);
 679:                 }
 680:             } catch (error) {
 681:                 console.error(`[LOOP] cycle = ${cycle} failed`, error);
 682:                 runStatus = 'FAILED';
 683:             } finally {
 684:                 if (runId) {
 685:                     const postStats = await getDailyStatsSnapshot(localDate);
 686:                     const invitesDiff = Math.max(0, postStats.invitesSent - preStats.invitesSent);
 687:                     const messagesDiff = Math.max(0, postStats.messagesSent - preStats.messagesSent);
 688:                     const errorsDiff = Math.max(0, postStats.runErrors - preStats.runErrors);
 689: 
 690:                     await finishCampaignRun(runId, runStatus, {
 691:                         discovered: profilesDiscoveredThisRun,
 692:                         invites: invitesDiff,
 693:                         messages: messagesDiff,
 694:                         errors: errorsDiff
 695:                     });
 696:                     console.log(`[LOOP] Campaign run ${runId} completed with status ${runStatus}`);
 697:                 }
 698:             }
 699: 
 700:             if (maxCycles !== null && cycle >= maxCycles) {
 701:                 console.log(`[LOOP] completed ${cycle} cycle(s).`);
 702:                 break;
 703:             }
 704: 
 705:             console.log(`[LOOP] waiting ${Math.floor(intervalMs / 1000)}s before next cycle...`);
 706:             if (lockOwnerId) {
 707:                 await sleepWithLockHeartbeat(intervalMs, lockOwnerId, lockTtlSeconds);
 708:             } else {
 709:                 await sleep(intervalMs);
 710:             }
 711:         }
 712:     } finally {
 713:         if (lockOwnerId) {
 714:             await releaseWorkflowRunnerLock(lockOwnerId);
 715:         }
 716:     }
 717: }
 718: 
 719: async function runAutopilotCommand(args: string[]): Promise<void> {
 720:     const positional = getPositionalArgs(args);
 721:     const intervalRaw = getOptionValue(args, '--interval-sec') ?? positional[0];
 722:     const cyclesRaw = getOptionValue(args, '--cycles') ?? positional[1];
 723:     const intervalArg = intervalRaw ?? String(Math.floor(config.workflowLoopIntervalMs / 1000));
 724:     const forwarded = ['all', intervalArg];
 725:     if (cyclesRaw && /^\d+$/.test(cyclesRaw)) {
 726:         forwarded.push('--cycles', cyclesRaw);
 727:     }
 728:     if (hasOption(args, '--dry-run') || positional.includes('dry') || positional.includes('dry-run')) {
 729:         forwarded.push('--dry-run');
 730:     }
 731:     await runLoopCommand(forwarded);
 732: }
 733: 
 734: async function runWorkflowCommand(workflow: WorkflowSelection, dryRun: boolean): Promise<void> {
 735:     if (dryRun) {
 736:         await runWorkflow({ workflow, dryRun: true });
 737:         return;
 738:     }
 739: 
 740:     const lockTtlSeconds = Math.max(300, config.jobStuckMinutes * 60 + 300);
 741:     const lockOwnerId = await acquireWorkflowRunnerLock('run', lockTtlSeconds, {
 742:         workflow,
 743:         dryRun: false,
 744:         startedAt: new Date().toISOString(),
 745:     });
 746:     try {
 747:         await runWorkflow({ workflow, dryRun: false });
 748:         await heartbeatWorkflowRunnerLock(lockOwnerId, lockTtlSeconds);
 749:     } finally {
 750:         await releaseWorkflowRunnerLock(lockOwnerId);
 751:     }
 752: }
 753: 
 754: async function runFunnelCommand(): Promise<void> {
 755:     const report = await buildFunnelReport();
 756:     console.log(JSON.stringify(report, null, 2));
 757: }
 758: 
 759: async function runSiteCheckCommand(args: string[]): Promise<void> {
 760:     const positional = getPositionalArgs(args);
 761:     const limitRaw = getOptionValue(args, '--limit') ?? positional[0];
 762:     const limit = limitRaw ? Math.max(1, parseIntStrict(limitRaw, '--limit')) : 25;
 763:     const autoFix = hasOption(args, '--fix') || positional.includes('fix');
 764:     const report = await runSiteCheck({ limitPerStatus: limit, autoFix });
 765:     console.log(JSON.stringify(report, null, 2));
 766: }
 767: 
 768: async function runStateSyncCommand(args: string[]): Promise<void> {
 769:     const positional = getPositionalArgs(args);
 770:     const limitRaw = getOptionValue(args, '--limit') ?? positional[0];
 771:     const limit = limitRaw ? Math.max(1, parseIntStrict(limitRaw, '--limit')) : config.postRunStateSyncLimit;
 772:     const autoFix = hasOption(args, '--fix') || positional.includes('fix') || config.postRunStateSyncFix;
 773:     const report = await runSiteCheck({ limitPerStatus: limit, autoFix });
 774:     console.log(JSON.stringify({
 775:         mode: 'state_sync',
 776:         limitPerStatus: limit,
 777:         autoFix,
 778:         report,
 779:     }, null, 2));
 780: }
 781: 
 782: async function runSalesNavSyncCommand(args: string[]): Promise<void> {
 783:     const positional = getPositionalArgs(args);
 784:     const dryRun = hasOption(args, '--dry-run') || positional.includes('dry-run') || positional.includes('dry');
 785:     const listName = getOptionValue(args, '--list') ?? positional[0] ?? config.salesNavSyncListName;
 786:     const listUrl = getOptionValue(args, '--url') ?? positional[1] ?? config.salesNavSyncListUrl;
 787:     const maxPagesRaw = getOptionValue(args, '--max-pages');
 788:     const maxPages = maxPagesRaw ? Math.max(1, parseIntStrict(maxPagesRaw, '--max-pages')) : config.salesNavSyncMaxPages;
 789:     const limitRaw = getOptionValue(args, '--limit');
 790:     const maxLeadsPerList = limitRaw ? Math.max(1, parseIntStrict(limitRaw, '--limit')) : config.salesNavSyncLimit;
 791:     const accountId = getOptionValue(args, '--account') ?? config.salesNavSyncAccountId;
 792: 
 793:     const report = await runSalesNavigatorListSync({
 794:         listName: listName?.trim() ? listName : null,
 795:         listUrl: listUrl?.trim() ? listUrl : null,
 796:         maxPages,
 797:         maxLeadsPerList,
 798:         dryRun,
 799:         accountId: accountId || undefined,
 800:     });
 801:     console.log(JSON.stringify(report, null, 2));
 802: }
 803: 
 804: async function runSalesNavListsCommand(args: string[]): Promise<void> {
 805:     const positional = getPositionalArgs(args);
 806:     const limitRaw = getOptionValue(args, '--limit') ?? positional[0];
 807:     const limit = limitRaw ? Math.max(1, parseIntStrict(limitRaw, '--limit')) : 200;
 808:     const lists = await listSalesNavLists(limit);
 809:     console.log(JSON.stringify({ total: lists.length, items: lists }, null, 2));
 810: }
 811: 
 812: async function runSalesNavCreateListCommand(args: string[]): Promise<void> {
 813:     const positional = getPositionalArgs(args);
 814:     const listName = getOptionValue(args, '--name') ?? positional[0];
 815:     const accountId = getOptionValue(args, '--account') ?? config.salesNavSyncAccountId;
 816:     if (!listName || !listName.trim()) {
 817:         throw new Error('Specifica nome lista: salesnav-create-list <nome>');
 818:     }
 819:     const result = await createSalesNavList(listName, accountId || undefined);
 820:     let dbListId: number | null = null;
 821:     let dbSyncError: string | null = null;
 822: 
 823:     if (result.ok) {
 824:         try {
 825:             const normalizedName = (result.listName ?? listName).trim();
 826:             if (result.listUrl) {
 827:                 const listRow = await upsertSalesNavList(normalizedName, result.listUrl);
 828:                 dbListId = listRow.id;
 829:             } else {
 830:                 const existing = await getSalesNavListByName(normalizedName);
 831:                 dbListId = existing?.id ?? null;
 832:             }
 833:         } catch (error) {
 834:             dbSyncError = error instanceof Error ? error.message : String(error);
 835:         }
 836:     }
 837: 
 838:     console.log(JSON.stringify({
 839:         ...result,
 840:         dbSync: {
 841:             listId: dbListId,
 842:             synced: dbListId !== null,
 843:             error: dbSyncError,
 844:         },
 845:     }, null, 2));
 846: }
 847: 
 848: async function runSalesNavAddLeadCommand(args: string[]): Promise<void> {
 849:     const positional = getPositionalArgs(args);
 850:     const leadIdRaw = getOptionValue(args, '--lead-id') ?? positional[0];
 851:     const listName = getOptionValue(args, '--list') ?? positional[1];
 852:     const accountId = getOptionValue(args, '--account') ?? config.salesNavSyncAccountId;
 853: 
 854:     if (!leadIdRaw) {
 855:         throw new Error('Specifica leadId: salesnav-add-lead <leadId> <listName>');
 856:     }
 857:     if (!listName || !listName.trim()) {
 858:         throw new Error('Specifica listName: salesnav-add-lead <leadId> <listName>');
 859:     }
 860: 
 861:     const leadId = Math.max(1, parseIntStrict(leadIdRaw, '--lead-id'));
 862:     const lead = await getLeadById(leadId);
 863:     if (!lead) {
 864:         throw new Error(`Lead non trovato: ${leadId} `);
 865:     }
 866: 
 867:     const result = await addLeadToSalesNavList(lead.linkedin_url, listName, accountId || undefined);
 868:     const targetListName = (result.listName ?? listName).trim();
 869:     let dbListId: number | null = null;
 870:     let dbLinked = false;
 871:     let dbSyncError: string | null = null;
 872: 
 873:     if (result.ok) {
 874:         try {
 875:             let listRow = await getSalesNavListByName(targetListName);
 876:             if (!listRow && result.listUrl) {
 877:                 listRow = await upsertSalesNavList(targetListName, result.listUrl);
 878:             }
 879:             if (listRow) {
 880:                 dbListId = listRow.id;
 881:                 await linkLeadToSalesNavList(listRow.id, leadId);
 882:                 dbLinked = true;
 883:             }
 884:         } catch (error) {
 885:             dbSyncError = error instanceof Error ? error.message : String(error);
 886:         }
 887:     }
 888: 
 889:     console.log(JSON.stringify({
 890:         leadId,
 891:         listName,
 892:         leadUrl: lead.linkedin_url,
 893:         dbSync: {
 894:             listId: dbListId,
 895:             linked: dbLinked,
 896:             error: dbSyncError,
 897:         },
 898:         ...result,
 899:     }, null, 2));
 900: }
 901: 
 902: async function runProxyStatusCommand(): Promise<void> {
 903:     const status = getProxyPoolStatus();
 904:     const failoverChain = getProxyFailoverChain().map((proxy, index) => ({
 905:         order: index + 1,
 906:         server: proxy.server,
 907:         auth: !!proxy.username || !!proxy.password,
 908:     }));
 909: 
 910:     console.log(JSON.stringify({
 911:         ...status,
 912:         failoverChain,
 913:     }, null, 2));
 914: }
 915: 
 916: async function runRandomActivityCommand(args: string[]): Promise<void> {
 917:     const positional = getPositionalArgs(args);
 918:     const maxActionsRaw = getOptionValue(args, '--max-actions')
 919:         ?? getOptionValue(args, '--actions')
 920:         ?? positional.find((value) => /^\d+$/.test(value));
 921:     const accountId = getOptionValue(args, '--account')
 922:         ?? positional.find((value) => {
 923:             const normalized = value.toLowerCase();
 924:             if (normalized === 'dry' || normalized === 'dry-run') return false;
 925:             return !value.startsWith('--') && !/^\d+$/.test(value);
 926:         })
 927:         ?? config.salesNavSyncAccountId
 928:         ?? undefined;
 929:     const dryRun = hasOption(args, '--dry-run') || positional.includes('dry') || positional.includes('dry-run');
 930:     const maxActions = maxActionsRaw
 931:         ? Math.max(1, parseIntStrict(maxActionsRaw, '--max-actions'))
 932:         : config.randomActivityMaxActions;
 933: 
 934:     const report = await runRandomLinkedinActivity({
 935:         accountId: accountId || undefined,
 936:         maxActions,
 937:         dryRun,
 938:     });
 939:     console.log(JSON.stringify(report, null, 2));
 940: }
 941: 
 942: async function runSalesNavResolveCommand(args: string[]): Promise<void> {
 943:     const positional = getPositionalArgs(args);
 944:     const limitRaw = getOptionValue(args, '--limit') ?? positional[0];
 945:     const limit = limitRaw ? Math.max(1, parseIntStrict(limitRaw, '--limit')) : 25;
 946:     const fix = hasOption(args, '--fix') || positional.includes('fix');
 947:     const dryRun = hasOption(args, '--dry-run') || positional.includes('dry-run') || positional.includes('dry');
 948: 
 949:     const leads = await getLeadsWithSalesNavigatorUrls(limit);
 950:     const report: SalesNavResolveReport = {
 951:         scanned: 0,
 952:         resolvable: 0,
 953:         updated: 0,
 954:         conflicts: 0,
 955:         unresolved: 0,
 956:         challengeDetected: false,
 957:         fix,
 958:         dryRun,
 959:         items: [],
 960:     };
 961: 
 962:     if (leads.length === 0) {
 963:         console.log(JSON.stringify(report, null, 2));
 964:         return;
 965:     }
 966: 
 967:     const session = await launchBrowser({ headless: config.headless });
 968:     try {
 969:         const loggedIn = await checkLogin(session.page);
 970:         if (!loggedIn) {
 971:             throw new Error('Sessione LinkedIn non autenticata. Esegui prima: .\\bot.ps1 login');
 972:         }
 973: 
 974:         for (const lead of leads) {
 975:             report.scanned += 1;
 976:             try {
 977:                 await session.page.goto(lead.linkedin_url, { waitUntil: 'domcontentloaded' });
 978:                 await humanDelay(session.page, 1000, 2000);
 979: 
 980:                 if (await detectChallenge(session.page)) {
 981:                     report.challengeDetected = true;
 982:                     report.items.push({
 983:                         leadId: lead.id,
 984:                         status: lead.status,
 985:                         currentUrl: lead.linkedin_url,
 986:                         resolvedProfileUrl: null,
 987:                         action: 'challenge_detected',
 988:                     });
 989:                     break;
 990:                 }
 991: 
 992:                 const candidates = await collectProfileUrlCandidates(session.page);
 993:                 const resolvedProfileUrl = pickResolvedProfileUrl(candidates);
 994:                 if (!resolvedProfileUrl) {
 995:                     report.unresolved += 1;
 996:                     report.items.push({
 997:                         leadId: lead.id,
 998:                         status: lead.status,
 999:                         currentUrl: lead.linkedin_url,
1000:                         resolvedProfileUrl: null,
1001:                         action: 'unresolved',
1002:                     });
1003:                     continue;
1004:                 }
1005: 
1006:                 report.resolvable += 1;
1007:                 if (!fix || dryRun) {
1008:                     report.items.push({
1009:                         leadId: lead.id,
1010:                         status: lead.status,
1011:                         currentUrl: lead.linkedin_url,
1012:                         resolvedProfileUrl,
1013:                         action: 'resolved',
1014:                     });
1015:                     continue;
1016:                 }
1017: 
1018:                 const updated = await updateLeadLinkedinUrl(lead.id, resolvedProfileUrl);
1019:                 if (updated.updated) {
1020:                     const recoveryStatus = lead.status === 'BLOCKED'
1021:                         ? getRecoveryStatusFromBlockedReason(lead.blocked_reason)
1022:                         : null;
1023:                     if (recoveryStatus) {
1024:                         await reconcileLeadStatus(lead.id, recoveryStatus, 'salesnav_profile_url_resolved', {
1025:                             previousStatus: lead.status,
1026:                             blockedReason: lead.blocked_reason,
1027:                         });
1028:                     }
1029:                     report.updated += 1;
1030:                     report.items.push({
1031:                         leadId: lead.id,
1032:                         status: lead.status,
1033:                         currentUrl: lead.linkedin_url,
1034:                         resolvedProfileUrl,
1035:                         action: 'updated',
1036:                     });
1037:                 } else {
1038:                     report.conflicts += 1;
1039:                     report.items.push({
1040:                         leadId: lead.id,
1041:                         status: lead.status,
1042:                         currentUrl: lead.linkedin_url,
1043:                         resolvedProfileUrl,
1044:                         action: 'conflict',
1045:                         conflictLeadId: updated.conflictLeadId,
1046:                     });
1047:                 }
1048:             } catch (error) {
1049:                 report.items.push({
1050:                     leadId: lead.id,
1051:                     status: lead.status,
1052:                     currentUrl: lead.linkedin_url,
1053:                     resolvedProfileUrl: null,
1054:                     action: 'error',
1055:                     error: error instanceof Error ? error.message : String(error),
1056:                 });
1057:             }
1058:         }
1059:     } finally {
1060:         await closeBrowserSession(session);
1061:     }
1062: 
1063:     console.log(JSON.stringify(report, null, 2));
1064: }
1065: 
1066: async function runEnrichTargetsCommand(args: string[]): Promise<void> {
1067:     const positional = getPositionalArgs(args);
1068:     const limitRaw = getOptionValue(args, '--limit') ?? positional[0];
1069:     const limit = limitRaw ? Math.max(1, parseIntStrict(limitRaw, '--limit')) : config.companyEnrichmentBatch;
1070:     const dryRun = hasOption(args, '--dry-run') || positional.includes('dry') || positional.includes('dry-run');
1071:     const report = await runCompanyEnrichmentBatch({
1072:         limit,
1073:         maxProfilesPerCompany: config.companyEnrichmentMaxProfilesPerCompany,
1074:         dryRun,
1075:     });
1076:     console.log(JSON.stringify(report, null, 2));
1077: }
1078: 
1079: async function runStatusCommand(): Promise<void> {
1080:     const localDate = getLocalDateString();
1081:     const [
1082:         quarantineFlag,
1083:         pauseState,
1084:         incidents,
1085:         jobStatusCounts,
1086:         dailyStats,
1087:         syncStatus,
1088:         runnerLock,
1089:         autoSiteCheckLastRunAt,
1090:         salesNavSyncLastRunAt,
1091:     ] = await Promise.all([
1092:         getRuntimeFlag('account_quarantine'),
1093:         getAutomationPauseState(),
1094:         listOpenIncidents(),
1095:         getJobStatusCounts(),
1096:         getDailyStatsSnapshot(localDate),
1097:         getEventSyncStatus(),
1098:         getRuntimeLock(WORKFLOW_RUNNER_LOCK_KEY),
1099:         getRuntimeFlag(AUTO_SITE_CHECK_LAST_RUN_KEY),
1100:         getRuntimeFlag(SALESNAV_LAST_SYNC_KEY),
1101:     ]);
1102: 
1103:     const payload = {
1104:         localDate,
1105:         quarantine: quarantineFlag === 'true',
1106:         accounts: getRuntimeAccountProfiles().map((account) => ({
1107:             id: account.id,
1108:             sessionDir: account.sessionDir,
1109:             dedicatedProxy: !!account.proxy,
1110:         })),
1111:         pause: pauseState,
1112:         openIncidents: incidents.length,
1113:         jobs: jobStatusCounts,
1114:         proxy: getProxyPoolStatus(),
1115:         dailyStats,
1116:         sync: syncStatus,
1117:         runnerLock,
1118:         autoSiteCheck: {
1119:             enabled: config.autoSiteCheckEnabled,
1120:             fix: config.autoSiteCheckFix,
1121:             limitPerStatus: config.autoSiteCheckLimit,
1122:             intervalHours: config.autoSiteCheckIntervalHours,
1123:             staleDays: config.siteCheckStaleDays,
1124:             lastRunAt: autoSiteCheckLastRunAt,
1125:         },
1126:         stateSync: {
1127:             postRunEnabled: config.postRunStateSyncEnabled,
1128:             postRunLimit: config.postRunStateSyncLimit,
1129:             postRunFix: config.postRunStateSyncFix,
1130:         },
1131:         salesNavSync: {
1132:             enabled: config.salesNavSyncEnabled,
1133:             listName: config.salesNavSyncListName,
1134:             listUrlConfigured: !!config.salesNavSyncListUrl.trim(),
1135:             maxPages: config.salesNavSyncMaxPages,
1136:             intervalHours: config.salesNavSyncIntervalHours,
1137:             limitPerList: config.salesNavSyncLimit,
1138:             accountId: config.salesNavSyncAccountId || null,
1139:             lastRunAt: salesNavSyncLastRunAt,
1140:         },
1141:         randomActivity: {
1142:             enabled: config.randomActivityEnabled,
1143:             probability: config.randomActivityProbability,
1144:             maxActions: config.randomActivityMaxActions,
1145:         },
1146:         ai: {
1147:             personalizationEnabled: config.aiPersonalizationEnabled,
1148:             guardianEnabled: config.aiGuardianEnabled,
1149:             model: config.aiModel,
1150:             openaiConfigured: isOpenAIConfigured(),
1151:             guardianMinIntervalMinutes: config.aiGuardianMinIntervalMinutes,
1152:             guardianPauseMinutes: config.aiGuardianPauseMinutes,
1153:         },
1154:     };
1155:     console.log(JSON.stringify(payload, null, 2));
1156: }
1157: 
1158: async function runPauseCommand(args: string[]): Promise<void> {
1159:     const positional = getPositionalArgs(args);
1160:     const minutesRaw = getOptionValue(args, '--minutes') ?? positional[0];
1161:     const reasonRaw = getOptionValue(args, '--reason') ?? (positional.length > 1 ? positional.slice(1).join(' ') : 'manual_pause');
1162: 
1163:     const minutes = minutesRaw
1164:         ? parsePauseMinutes(minutesRaw, '--minutes')
1165:         : config.autoPauseMinutesOnFailureBurst;
1166:     const pausedUntil = await setAutomationPause(minutes, reasonRaw);
1167:     const renderedUntil = pausedUntil ?? 'manual resume';
1168:     console.log(`Automazione in pausa.pausedUntil=${renderedUntil} reason = ${reasonRaw} `);
1169: }
1170: 
1171: async function runResumeCommand(): Promise<void> {
1172:     await clearPauseState();
1173:     console.log('Pausa automazione rimossa.');
1174: }
1175: 
1176: async function runUnquarantineCommand(): Promise<void> {
1177:     await setQuarantine(false);
1178:     await clearPauseState();
1179:     console.log('Quarantine disattivata e pausa rimossa.');
1180: }
1181: 
1182: async function runResolveIncidentCommand(args: string[]): Promise<void> {
1183:     const positional = getPositionalArgs(args);
1184:     const idRaw = getOptionValue(args, '--id') ?? positional[0];
1185:     if (!idRaw) {
1186:         throw new Error('Specifica ID incidente: npm start -- incident-resolve <id>');
1187:     }
1188:     const incidentId = parseIntStrict(idRaw, '--id');
1189:     if (incidentId < 1) {
1190:         throw new Error('--id deve essere >= 1');
1191:     }
1192:     await resolveIncident(incidentId);
1193:     console.log(`Incidente ${incidentId} risolto.`);
1194: }
1195: 
1196: async function runPrivacyCleanupCommand(args: string[]): Promise<void> {
1197:     const positional = getPositionalArgs(args);
1198:     const daysRaw = getOptionValue(args, '--days') ?? positional[0];
1199:     const days = daysRaw ? Math.max(7, parseIntStrict(daysRaw, '--days')) : config.retentionDays;
1200:     const result = await cleanupPrivacyData(days);
1201:     console.log(JSON.stringify({ retentionDays: days, ...result }, null, 2));
1202: }
1203: 
1204: async function runCompanyTargetsCommand(args: string[]): Promise<void> {
1205:     const positional = getPositionalArgs(args);
1206:     const listName = getOptionValue(args, '--list') ?? positional[0] ?? null;
1207:     const limitRaw = getOptionValue(args, '--limit') ?? positional[1];
1208:     const limit = limitRaw ? Math.max(1, parseIntStrict(limitRaw, '--limit')) : 50;
1209:     const [total, items] = await Promise.all([
1210:         countCompanyTargets(listName ?? undefined),
1211:         listCompanyTargets(listName, limit),
1212:     ]);
1213:     console.log(JSON.stringify({ list: listName ?? 'all', total, shown: items.length, items }, null, 2));
1214: }
1215: 
1216: async function runDbBackupCommand(): Promise<void> {
1217:     console.log('Avvio backup database manuale...');
1218:     try {
1219:         const backupPath = await backupDatabase();
1220:         console.log(`Backup completato con successo.File salvato in: ${backupPath} `);
1221:     } catch (e) {
1222:         console.error('Errore durante il backup del database:', e);
1223:     }
1224: }
1225: 
1226: async function main(): Promise<void> {
1227:     setupGracefulShutdown();
1228:     const args = process.argv.slice(2);
1229:     const command = args[0];
1230:     const commandArgs = args.slice(1);
1231: 
1232:     await initDatabase();
1233:     const shouldRecoverStuckJobs = command === 'run'
1234:         || command === 'connect'
1235:         || command === 'check'
1236:         || command === 'message'
1237:         || (command === 'run-loop' && !hasOption(commandArgs, '--dry-run'));
1238:     if (shouldRecoverStuckJobs) {
1239:         const recoveredJobs = await recoverStuckJobs(config.jobStuckMinutes);
1240:         if (recoveredJobs > 0) {
1241:             console.warn(`[BOOT] Ripristinati ${recoveredJobs} job RUNNING bloccati da oltre ${config.jobStuckMinutes} minuti.`);
1242:         }
1243:     }
1244: 
1245:     switch (command) {
1246:         case 'import':
1247:             await runImportCommand(commandArgs);
1248:             break;
1249:         case 'run': {
1250:             const workflow = parseWorkflow(getWorkflowValue(commandArgs));
1251:             await runWorkflowCommand(workflow, false);
1252:             break;
1253:         }
1254:         case 'dry-run': {
1255:             const workflow = parseWorkflow(getWorkflowValue(commandArgs));
1256:             await runWorkflowCommand(workflow, true);
1257:             break;
1258:         }
1259:         case 'run-loop':
1260:             await runLoopCommand(commandArgs);
1261:             break;
1262:         case 'autopilot':
1263:             await runAutopilotCommand(commandArgs);
1264:             break;
1265:         case 'login':
1266:             await runLoginCommand(commandArgs);
1267:             break;
1268:         case 'doctor': {
1269:             const report = await runDoctor();
1270:             console.log(JSON.stringify(report, null, 2));
1271:             break;
1272:         }
1273:         case 'funnel':
1274:             await runFunnelCommand();
1275:             break;
1276:         case 'site-check':
1277:             await runSiteCheckCommand(commandArgs);
1278:             break;
1279:         case 'state-sync':
1280:             await runStateSyncCommand(commandArgs);
1281:             break;
1282:         case 'salesnav-sync':
1283:             await runSalesNavSyncCommand(commandArgs);
1284:             break;
1285:         case 'salesnav-lists':
1286:             await runSalesNavListsCommand(commandArgs);
1287:             break;
1288:         case 'salesnav-create-list':
1289:             await runSalesNavCreateListCommand(commandArgs);
1290:             break;
1291:         case 'salesnav-add-lead':
1292:             await runSalesNavAddLeadCommand(commandArgs);
1293:             break;
1294:         case 'salesnav-add-to-list':
1295:             await runSalesNavAddLeadCommand(commandArgs);
1296:             break;
1297:         case 'salesnav-resolve':
1298:             await runSalesNavResolveCommand(commandArgs);
1299:             break;
1300:         case 'enrich-targets':
1301:             await runEnrichTargetsCommand(commandArgs);
1302:             break;
1303:         case 'status':
1304:             await runStatusCommand();
1305:             break;
1306:         case 'proxy-status':
1307:             await runProxyStatusCommand();
1308:             break;
1309:         case 'random-activity':
1310:             await runRandomActivityCommand(commandArgs);
1311:             break;
1312:         case 'pause':
1313:             await runPauseCommand(commandArgs);
1314:             break;
1315:         case 'resume':
1316:             await runResumeCommand();
1317:             break;
1318:         case 'unquarantine':
1319:             await runUnquarantineCommand();
1320:             break;
1321:         case 'incidents': {
1322:             const positional = getPositionalArgs(commandArgs);
1323:             const openOnly = commandArgs.includes('--open') || positional.includes('open') || positional.length === 0;
1324:             if (!openOnly) {
1325:                 console.log('Usa: npm start -- incidents open');
1326:                 break;
1327:             }
1328:             const incidents = await listOpenIncidents();
1329:             console.log(JSON.stringify(incidents, null, 2));
1330:             break;
1331:         }
1332:         case 'incident-resolve':
1333:             await runResolveIncidentCommand(commandArgs);
1334:             break;
1335:         case 'privacy-cleanup':
1336:             await runPrivacyCleanupCommand(commandArgs);
1337:             break;
1338:         case 'lists': {
1339:             const lists = await listLeadCampaignConfigs(false);
1340:             console.log(JSON.stringify(lists, null, 2));
1341:             break;
1342:         }
1343:         case 'company-targets':
1344:             await runCompanyTargetsCommand(commandArgs);
1345:             break;
1346:         case 'list-config': {
1347:             const positional = getPositionalArgs(commandArgs);
1348:             const listName = getOptionValue(commandArgs, '--list') ?? positional[0];
1349:             if (!listName) {
1350:                 throw new Error('Specifica la lista: npm start -- list-config --list <nome_lista> ...');
1351:             }
1352: 
1353:             const patch: {
1354:                 priority?: number;
1355:                 dailyInviteCap?: number | null;
1356:                 dailyMessageCap?: number | null;
1357:                 isActive?: boolean;
1358:             } = {};
1359: 
1360:             const priorityRaw = getOptionValue(commandArgs, '--priority') ?? positional[1];
1361:             if (hasOption(commandArgs, '--priority') || priorityRaw !== undefined) {
1362:                 const raw = priorityRaw;
1363:                 if (!raw) throw new Error('Manca valore per --priority');
1364:                 const parsed = parseIntStrict(raw, '--priority');
1365:                 if (parsed < 1) throw new Error('--priority deve essere >= 1');
1366:                 patch.priority = parsed;
1367:             }
1368:             const inviteCapRaw = getOptionValue(commandArgs, '--invite-cap') ?? positional[2];
1369:             if (hasOption(commandArgs, '--invite-cap') || inviteCapRaw !== undefined) {
1370:                 const raw = inviteCapRaw;
1371:                 if (!raw) throw new Error('Manca valore per --invite-cap');
1372:                 patch.dailyInviteCap = parseNullableCap(raw, '--invite-cap');
1373:             }
1374:             const messageCapRaw = getOptionValue(commandArgs, '--message-cap') ?? positional[3];
1375:             if (hasOption(commandArgs, '--message-cap') || messageCapRaw !== undefined) {
1376:                 const raw = messageCapRaw;
1377:                 if (!raw) throw new Error('Manca valore per --message-cap');
1378:                 patch.dailyMessageCap = parseNullableCap(raw, '--message-cap');
1379:             }
1380:             const activeRaw = getOptionValue(commandArgs, '--active') ?? positional[4];
1381:             if (hasOption(commandArgs, '--active') || activeRaw !== undefined) {
1382:                 const raw = activeRaw;
1383:                 if (!raw) throw new Error('Manca valore per --active');
1384:                 patch.isActive = parseBoolStrict(raw, '--active');
1385:             }
1386: 
1387:             const updated = await updateLeadCampaignConfig(listName, patch);
1388:             console.log(JSON.stringify(updated, null, 2));
1389:             break;
1390:         }
1391:         case 'sync-status': {
1392:             const status = await getEventSyncStatus();
1393:             console.log(JSON.stringify(status, null, 2));
1394:             break;
1395:         }
1396:         case 'sync-run-once':
1397:             await runEventSyncOnce();
1398:             console.log('Sync eventi completato.');
1399:             break;
1400:         case 'db-backup':
1401:             await runDbBackupCommand();
1402:             break;
1403:         case 'connect':
1404:             await runWorkflowCommand('invite', false);
1405:             break;
1406:         case 'check':
1407:             await runWorkflowCommand('check', false);
1408:             break;
1409:         case 'message':
1410:             await runWorkflowCommand('message', false);
1411:             break;
1412:         case 'warmup':
1413:             await runWorkflowCommand('warmup', false);
1414:             break;
1415:         case 'daily-report':
1416:             await generateAndSendDailyReport();
1417:             break;
1418:         case 'dashboard':
1419:             await initDatabase(); // Initialize DB for the server
1420:             startServer(3000);
1421:             console.log('Premi Ctrl+C per fermare la Dashboard e spegnere il database.');
1422:             // Block the process to keep the DB connection alive
1423:             await new Promise(() => { });
1424:             break;
1425:         default:
1426:             printHelp();
1427:             break;
1428:     }
1429: }
1430: 
1431: main()
1432:     .catch((error) => {
1433:         console.error('[FATAL]', error);
1434:         process.exitCode = 1;
1435:     })
1436:     .finally(async () => {
1437:         await closeDatabase();
1438:     });
````
