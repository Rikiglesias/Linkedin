This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where line numbers have been added.

# File Summary

## Purpose
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A header with the file path (## File: path/to/file)
  b. The full contents of the file in a code block

## Usage Guidelines
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
- Pay special attention to the Repository Description. These contain important context and guidelines specific to this project.

## Notes
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: src/**/*, package.json, tsconfig.json, eslint.config.js, .env.example, ROADMAP.md, INTEGRATIONS.md, SECURITY.md
- Files matching these patterns are excluded: node_modules/**, dist/**, data/**, .env, *.log, package-lock.json, repomix-output.txt, .git/**
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Line numbers have been added to the beginning of each line
- Files are sorted by Git change count (files with more changes are at the bottom)

# User Provided Header
LinkedIn Bot Codebase - Condiviso per analisi AI

# Directory Structure
```
.env.example
eslint.config.js
INTEGRATIONS.md
package.json
ROADMAP.md
SECURITY.md
src/acceptanceChecker.ts
src/ai/guardian.ts
src/ai/messagePersonalizer.ts
src/ai/openaiClient.ts
src/browser.ts
src/config.ts
src/connectWorkflow.ts
src/core/audit.ts
src/core/companyEnrichment.ts
src/core/doctor.ts
src/core/jobRunner.ts
src/core/leadStateService.ts
src/core/orchestrator.ts
src/core/repositories.ts
src/core/scheduler.ts
src/csvImporter.ts
src/db.ts
src/db/migrations/001_core.sql
src/db/migrations/002_legacy_status_backfill.sql
src/db/migrations/003_add_person_fields.sql
src/db/migrations/004_list_campaign_controls.sql
src/db/migrations/005_performance_indexes.sql
src/db/migrations/006_company_targets.sql
src/db/migrations/007_company_target_tracking.sql
src/db/migrations/008_runtime_locks.sql
src/index.ts
src/linkedinUrl.ts
src/messages.ts
src/messagingWorkflow.ts
src/models.ts
src/risk/incidentManager.ts
src/risk/riskEngine.ts
src/security/filesystem.ts
src/security/redaction.ts
src/selectors.ts
src/sync/eventSync.ts
src/sync/supabase.schema.sql
src/sync/supabaseSyncWorker.ts
src/sync/webhookSyncWorker.ts
src/telemetry/alerts.ts
src/telemetry/logger.ts
src/tests/e2eDry.ts
src/tests/integration.ts
src/tests/unit.ts
src/types/domain.ts
src/validation/messageValidator.ts
src/workers/acceptanceWorker.ts
src/workers/context.ts
src/workers/errors.ts
src/workers/inviteWorker.ts
src/workers/messageWorker.ts
tsconfig.json
```

# Files

## File: .env.example
````
 1: # Runtime locale
 2: TIMEZONE=Europe/Rome
 3: HEADLESS=false
 4: HOUR_START=9
 5: HOUR_END=18
 6: DB_PATH=./data/linkedin_bot.sqlite
 7: SESSION_DIR=./data/session
 8: MAX_CONCURRENT_JOBS=1
 9: JOB_STUCK_MINUTES=30
10: RETRY_MAX_ATTEMPTS=3
11: RETRY_BASE_MS=1200
12: WORKFLOW_LOOP_INTERVAL_MS=900000
13: COMPANY_ENRICHMENT_ENABLED=true
14: COMPANY_ENRICHMENT_BATCH=5
15: COMPANY_ENRICHMENT_MAX_PROFILES_PER_COMPANY=3
16: MAX_CONSECUTIVE_JOB_FAILURES=4
17: MAX_SELECTOR_FAILURES_PER_DAY=8
18: MAX_RUN_ERRORS_PER_DAY=20
19: AUTO_PAUSE_MINUTES_ON_FAILURE_BURST=180
20: RETENTION_DAYS=45
21: 
22: # Budget dinamico
23: SOFT_INVITE_CAP=25
24: HARD_INVITE_CAP=35
25: SOFT_MSG_CAP=40
26: HARD_MSG_CAP=60
27: WEEKLY_INVITE_LIMIT=120
28: 
29: # Risk engine
30: RISK_WARN_THRESHOLD=60
31: RISK_STOP_THRESHOLD=80
32: PENDING_RATIO_WARN=0.65
33: PENDING_RATIO_STOP=0.8
34: ADAPTIVE_CAPS_ENABLED=true
35: ADAPTIVE_CAPS_PENDING_WARN=0.55
36: ADAPTIVE_CAPS_PENDING_STOP=0.72
37: ADAPTIVE_CAPS_BLOCKED_WARN=0.25
38: ADAPTIVE_CAPS_MIN_FACTOR=0.25
39: ADAPTIVE_CAPS_WARN_FACTOR=0.85
40: COOLDOWN_ENABLED=true
41: COOLDOWN_WARN_SCORE=68
42: COOLDOWN_HIGH_SCORE=75
43: COOLDOWN_PENDING_THRESHOLD=0.65
44: COOLDOWN_PENDING_HIGH_THRESHOLD=0.75
45: COOLDOWN_WARN_MINUTES=2880
46: COOLDOWN_HIGH_MINUTES=4320
47: NO_BURST_ENABLED=true
48: NO_BURST_MIN_DELAY_SEC=8
49: NO_BURST_MAX_DELAY_SEC=25
50: NO_BURST_LONG_BREAK_EVERY=7
51: NO_BURST_LONG_BREAK_MIN_SEC=120
52: NO_BURST_LONG_BREAK_MAX_SEC=360
53: AUTO_SITE_CHECK_ENABLED=true
54: AUTO_SITE_CHECK_LIMIT=20
55: AUTO_SITE_CHECK_FIX=true
56: AUTO_SITE_CHECK_INTERVAL_HOURS=24
57: POST_RUN_STATE_SYNC_ENABLED=true
58: POST_RUN_STATE_SYNC_LIMIT=8
59: POST_RUN_STATE_SYNC_FIX=true
60: SELECTOR_CANARY_ENABLED=true
61: OUTBOX_ALERT_BACKLOG=1000
62: 
63: # Alerting Telegram (opzionale)
64: TELEGRAM_BOT_TOKEN=
65: TELEGRAM_CHAT_ID=
66: 
67: # Supabase Control Plane (asincrono)
68: EVENT_SYNC_SINK=SUPABASE
69: SUPABASE_SYNC_ENABLED=true
70: SUPABASE_URL=
71: SUPABASE_SERVICE_ROLE_KEY=
72: SUPABASE_SYNC_BATCH_SIZE=100
73: SUPABASE_SYNC_INTERVAL_MS=15000
74: SUPABASE_SYNC_MAX_RETRIES=8
75: 
76: # Webhook sink (n8n / Make / Pipedream)
77: WEBHOOK_SYNC_ENABLED=false
78: WEBHOOK_SYNC_URL=
79: WEBHOOK_SYNC_SECRET=
80: WEBHOOK_SYNC_BATCH_SIZE=100
81: WEBHOOK_SYNC_TIMEOUT_MS=10000
82: WEBHOOK_SYNC_MAX_RETRIES=8
83: 
84: # AI (opzionale)
85: OPENAI_API_KEY=
86: OPENAI_BASE_URL=https://api.openai.com/v1
87: AI_MODEL=gpt-4.1-mini
88: AI_REQUEST_TIMEOUT_MS=12000
89: AI_PERSONALIZATION_ENABLED=false
90: AI_MESSAGE_MAX_CHARS=450
91: AI_GUARDIAN_ENABLED=false
92: AI_GUARDIAN_MIN_INTERVAL_MINUTES=60
93: AI_GUARDIAN_PAUSE_MINUTES=180
````

## File: eslint.config.js
````javascript
 1: const typescriptEslintEslintPlugin = require("@typescript-eslint/eslint-plugin");
 2: const typescriptEslintParser = require("@typescript-eslint/parser");
 3: 
 4: module.exports = [
 5:     {
 6:         files: ["**/*.ts"],
 7:         languageOptions: {
 8:             parser: typescriptEslintParser,
 9:             parserOptions: {
10:                 ecmaVersion: "latest",
11:                 sourceType: "module",
12:             },
13:         },
14:         plugins: {
15:             "@typescript-eslint": typescriptEslintEslintPlugin,
16:         },
17:         rules: {
18:             "no-console": "off",
19:             "@typescript-eslint/no-unused-vars": "error",
20:             "@typescript-eslint/no-explicit-any": "error",
21:             "semi": ["error", "always"]
22:         },
23:     },
24: ];
````

## File: INTEGRATIONS.md
````markdown
 1: # Integrations Guide
 2: 
 3: This bot can export control-plane events from `outbox_events` to one sink at a time:
 4: - `SUPABASE` (table `cp_events`)
 5: - `WEBHOOK` (for n8n, Make, Pipedream, custom middleware)
 6: 
 7: Set the active sink with:
 8: 
 9: ```env
10: EVENT_SYNC_SINK=SUPABASE
11: ```
12: 
13: Allowed values: `SUPABASE`, `WEBHOOK`, `NONE`.
14: 
15: ## n8n Setup (recommended external orchestrator)
16: 
17: 1. Create a workflow with a `Webhook` trigger (POST).
18: 2. Add an auth guard step:
19:    - verify `x-signature-sha256` if `WEBHOOK_SYNC_SECRET` is configured
20:    - deduplicate by `x-idempotency-key`
21: 3. Route by `topic` (for example `lead.transition`, `lead.reconciled`, `scheduler.snapshot`, `incident.opened`).
22: 4. Add actions (alerts, CRM update, BI, ticketing, etc.).
23: 
24: Bot `.env` example:
25: 
26: ```env
27: EVENT_SYNC_SINK=WEBHOOK
28: WEBHOOK_SYNC_ENABLED=true
29: WEBHOOK_SYNC_URL=https://your-n8n-host/webhook/linkedin-events
30: WEBHOOK_SYNC_SECRET=replace_with_long_random_secret
31: WEBHOOK_SYNC_BATCH_SIZE=100
32: WEBHOOK_SYNC_TIMEOUT_MS=10000
33: WEBHOOK_SYNC_MAX_RETRIES=8
34: 
35: # Optional: disable Supabase sink if not used
36: SUPABASE_SYNC_ENABLED=false
37: ```
38: 
39: ## Payload format sent to Webhook sink
40: 
41: ```json
42: {
43:   "topic": "lead.transition",
44:   "payload": { "leadId": 123, "fromStatus": "READY_INVITE", "toStatus": "INVITED" },
45:   "idempotencyKey": "lead.transition:123:READY_INVITE:INVITED:invite_sent",
46:   "createdAt": "2026-02-25 20:10:00"
47: }
48: ```
49: 
50: Headers:
51: - `x-idempotency-key`
52: - `x-event-topic`
53: - `x-signature-sha256` (only if `WEBHOOK_SYNC_SECRET` is configured)
54: 
55: ## Operational commands
56: 
57: - Check sink status: `.\bot.ps1 sync-status`
58: - Force one sync batch: `.\bot.ps1 sync-run-once`
59: 
60: ## Notes
61: 
62: - Do not enable stealth/evasion tooling. Keep automation conservative and policy-safe.
63: - Keep only one active sink in production to avoid configuration ambiguity.
64: - If both sink toggles are enabled, `EVENT_SYNC_SINK` decides which sink is used.
````

## File: package.json
````json
 1: {
 2:   "name": "linkedin",
 3:   "version": "1.0.0",
 4:   "description": "",
 5:   "main": "index.js",
 6:   "scripts": {
 7:     "build": "tsc",
 8:     "lint": "eslint src/**/*.ts",
 9:     "typecheck": "tsc --noEmit",
10:     "conta-problemi": "npm run typecheck && npm run lint",
11:     "pre-modifiche": "npm run conta-problemi",
12:     "post-modifiche": "npm run conta-problemi",
13:     "helper-manuali": "echo 'Esegui le correzioni manuali come da policy'",
14:     "start": "ts-node src/index.ts",
15:     "test:unit": "ts-node src/tests/unit.ts",
16:     "test:integration": "ts-node src/tests/integration.ts",
17:     "test:e2e:dry": "ts-node src/tests/e2eDry.ts",
18:     "test": "npm run test:unit && npm run test:integration && npm run test:e2e:dry"
19:   },
20:   "keywords": [],
21:   "author": "",
22:   "license": "ISC",
23:   "type": "commonjs",
24:   "dependencies": {
25:     "@supabase/supabase-js": "^2.57.4",
26:     "csv-parser": "^3.2.0",
27:     "dotenv": "^17.3.1",
28:     "playwright": "^1.58.2",
29:     "sqlite": "^5.1.1",
30:     "sqlite3": "^5.1.7"
31:   },
32:   "devDependencies": {
33:     "@types/node": "^25.3.0",
34:     "@types/sqlite3": "^3.1.11",
35:     "@typescript-eslint/eslint-plugin": "^8.56.1",
36:     "@typescript-eslint/parser": "^8.56.1",
37:     "eslint": "^10.0.2",
38:     "ts-node": "^10.9.2",
39:     "typescript": "^5.9.3"
40:   }
41: }
````

## File: ROADMAP.md
````markdown
 1: # LinkedIn Bot Roadmap
 2: 
 3: ## Objective
 4: Build a safer, more reliable, and measurable end-to-end automation flow:
 5: - Source lists from DB/control-plane
 6: - Execute invite/check/message workflows with strict safeguards
 7: - Keep LinkedIn state and local DB in sync
 8: - Reduce operational risk with adaptive policies and incident controls
 9: 
10: ## Status Legend
11: - `todo`: not started
12: - `in_progress`: currently being implemented
13: - `done`: completed and verified
14: - `blocked`: waiting on external input/decision
15: 
16: ## Owners
17: - `YOU`: business decisions, account operation, approvals
18: - `AI`: implementation in codebase
19: - `JOINT`: requires both
20: 
21: ## Priority Roadmap
22: 
23: | ID | Priority | Area | Task | Owner | Status | Dependencies | Done Criteria |
24: |---|---|---|---|---|---|---|---|
25: | P0-01 | P0 | Security | Rotate `SUPABASE_SERVICE_ROLE_KEY` and update `.env` | YOU | todo | None | Old key revoked, new key active, bot works |
26: | P0-02 | P0 | Security | Verify no secrets in logs/outbox payloads | AI | todo | P0-01 | No sensitive token appears in runtime logs |
27: | P0-03 | P0 | Security | Confirm private permissions on DB/session folders | AI | todo | None | `data` paths protected and documented |
28: | P0-04 | P0 | Runtime Safety | Add global single-runner lock (no dual bot) | AI | done | None | Second process exits with lock message |
29: | P0-05 | P0 | Runtime Safety | Add lock heartbeat and stale-lock recovery | AI | done | P0-04 | Crashed lock auto-recovers safely |
30: | P0-06 | P0 | Runtime Safety | Run `doctor` automatically before each loop cycle | AI | done | None | Loop skips if health check fails |
31: | P0-07 | P0 | Risk Engine | Implement adaptive caps per list/account | AI | done | None | Budgets auto-adjust from recent KPIs |
32: | P0-08 | P0 | Risk Engine | Implement auto cooldown engine (48h/72h policy) | AI | done | P0-07 | Cooldown triggers after risk anomalies |
33: | P0-09 | P0 | Risk Engine | Enforce no-burst pacing policy | AI | done | P0-07 | No clustered spikes in job execution |
34: | P0-10 | P0 | Session Safety | Add session/IP/device consistency guard + auto-pause | AI | todo | None | Context drift triggers pause and incident |
35: 
36: | ID | Priority | Area | Task | Owner | Status | Dependencies | Done Criteria |
37: |---|---|---|---|---|---|---|---|
38: | P1-01 | P1 | Workflow | Schedule daily `site-check --fix` from autopilot | AI | done | P0-04 | Daily reconciliation runs automatically |
39: | P1-02 | P1 | Workflow | Improve LinkedIn-vs-DB state reconciliation rules | AI | done | P1-01 | Mismatch false positives reduced |
40: | P1-03 | P1 | Workflow | Add `REVIEW_REQUIRED` lead state for ambiguous cases | AI | todo | P1-02 | Unsafe transitions blocked for review |
41: | P1-04 | P1 | Workflow | Add pending invite hygiene policy (age-based) | JOINT | todo | P1-02 | Old pending invites handled by policy |
42: | P1-05 | P1 | Control Plane | Upgrade Supabase from sink-only to control-plane | AI | todo | P0-01 | Campaign config can be managed remotely |
43: | P1-06 | P1 | Control Plane | Implement bidirectional sync (Supabase <-> local) | AI | todo | P1-05 | Config/data parity verified |
44: | P1-07 | P1 | Observability | Add dashboard KPIs (funnel, risk, pending, acceptance) | AI | todo | P1-05 | KPI panel populated from live data |
45: | P1-08 | P1 | Lead Quality | Add lead scoring before invite scheduling | AI | todo | P0-07 | Low-score leads filtered/deprioritized |
46: | P1-09 | P1 | Enrichment | Add confidence score + review queue for enrichment | AI | todo | P1-03 | Low-confidence matches not auto-sent |
47: | P1-10 | P1 | Messaging | Add semantic similarity anti-duplication checks | AI | todo | None | Repetitive messages auto-blocked |
48: | P1-11 | P1 | Integrations | Add selectable event-sync sink (`SUPABASE`/`WEBHOOK`) for n8n/Make/Pipedream | AI | done | None | `sync-status` mostra sink attivo; `sync-run-once` supporta webhook |
49: | P1-12 | P1 | Workflow | Add automatic post-run state sync (invite/accept/message reconciliation) | AI | done | P1-02 | DB state auto-updated each run from site signals |
50: | P1-13 | P1 | AI | Add optional AI message personalization with template fallback | AI | done | None | Messages can be AI-personalized without blocking flow |
51: | P1-14 | P1 | AI | Add optional AI guardian for preemptive risk pause/watch decisions | AI | done | P0-07 | Guardian emits decision and can auto-pause on critical |
52: 
53: | ID | Priority | Area | Task | Owner | Status | Dependencies | Done Criteria |
54: |---|---|---|---|---|---|---|---|
55: | P2-01 | P2 | Audit | Add `campaign_runs` table and run-by-run telemetry | AI | todo | None | Every loop writes run summary |
56: | P2-02 | P2 | Alerts | Expand alerting on challenge/quarantine/backlog bursts | AI | todo | P2-01 | Alerts fire with actionable context |
57: | P2-03 | P2 | Incident Ops | Create incident runbook with auto actions | JOINT | todo | P2-02 | Clear SOP for pause/recover/resume |
58: | P2-04 | P2 | Reporting | Add automated daily summary report | AI | todo | P2-01 | Daily report produced reliably |
59: | P2-05 | P2 | Testing | Add tests for lock/cooldown/adaptive caps/reconcile | AI | todo | P0-04, P0-08, P1-02 | New tests pass in CI/local |
60: | P2-06 | P2 | Testing | Run realistic e2e dry-run scenarios | AI | todo | P2-05 | Dry-run validates full orchestration |
61: | P2-07 | P2 | Rollout | Canary rollout on one list for 7 days | JOINT | todo | P0 and P1 complete | Stable KPIs, no major incidents |
62: | P2-08 | P2 | Rollout | Controlled ramp-up policy with stop thresholds | JOINT | todo | P2-07 | Scaled traffic without safety regressions |
63: | P2-09 | P2 | Intelligence | Monthly review of official + community signals | JOINT | todo | None | Risk policy updated monthly |
64: 
65: ## Execution Sequence
66: 1. Complete all `P0` tasks first.
67: 2. Enable `P1` control-plane and workflow intelligence.
68: 3. Stabilize with `P2` testing, reporting, and rollout governance.
69: 
70: ## Immediate Next Actions
71: 1. `YOU`: rotate Supabase service key (`P0-01`).
72: 2. `AI`: harden secret/privacy controls in logs and runtime paths (`P0-02`, `P0-03`).
73: 3. `AI`: implement session/IP/device consistency guard with auto-pause (`P0-10`).
74: 4. `AI`: add `REVIEW_REQUIRED` guardrail state for ambiguous reconciliation (`P1-03`).
````

## File: SECURITY.md
````markdown
 1: # Security & Privacy Hardening
 2: 
 3: ## What is already hardened
 4: - No stealth/evasion browser plugins in runtime dependencies.
 5: - Automatic pause/quarantine on risk bursts.
 6: - Sensitive log redaction (`token`, `key`, `cookie`, JWT-like values).
 7: - Local session and DB storage created with private-permission best effort.
 8: - Privacy retention cleanup command to reduce stored historical data.
 9: - AI integration is fail-safe: if AI API fails, bot falls back to local template/heuristics.
10: 
11: ## Daily operator workflow
12: 1. `.\bot.ps1 doctor`
13: 2. `.\bot.ps1 status`
14: 3. Run jobs only if `sessionLoginOk=true`, `quarantine=false`, `pause.paused=false`.
15: 
16: ## Emergency controls
17: - Pause immediately: `.\bot.ps1 pause 180 suspicious_activity`
18: - Resume: `.\bot.ps1 resume`
19: - Remove quarantine after manual checks: `.\bot.ps1 unquarantine`
20: - Inspect incidents: `.\bot.ps1 incidents`
21: - Resolve incident: `.\bot.ps1 incident-resolve <id>`
22: 
23: ## Privacy retention
24: - Default retention from `.env` via `RETENTION_DAYS` (recommended: `45`).
25: - Cleanup old operational data:
26:   - `.\bot.ps1 privacy-cleanup`
27:   - `.\bot.ps1 privacy-cleanup --days 30`
28: 
29: This cleanup removes only old operational history (`run_logs`, `job_attempts`, `lead_events`, `message_history`, delivered `outbox_events`, resolved incidents).  
30: It does not delete active leads/jobs.
31: 
32: ## Host machine recommendations
33: - Keep OS and browser updated automatically.
34: - Use full-disk encryption (BitLocker on Windows).
35: - Keep a dedicated OS user profile for automation.
36: - Use a password manager and enable 2FA on LinkedIn and email.
37: - Restrict remote-access software and unknown browser extensions.
38: 
39: ## AI key hygiene (if enabled)
40: - Keep `OPENAI_API_KEY` only in local `.env` (never in repository files).
41: - Rotate key periodically and after any suspected leak.
42: - Keep `AI_PERSONALIZATION_ENABLED=false` / `AI_GUARDIAN_ENABLED=false` until dry-run validation is complete.
43: 
44: ## Dependency note
45: `npm audit` currently reports high advisories related to `sqlite3` build-chain dependencies (`node-gyp` / `tar`) during install tooling.  
46: The runtime currently requires `sqlite3`; monitor upstream advisories and patch quickly when a safe upgrade path appears.
````

## File: src/acceptanceChecker.ts
````typescript
1: import { runWorkflow } from './core/orchestrator';
2: 
3: export async function runAcceptanceChecker(): Promise<void> {
4:     await runWorkflow({
5:         workflow: 'check',
6:         dryRun: false,
7:     });
8: }
````

## File: src/ai/guardian.ts
````typescript
  1: import { config } from '../config';
  2: import { ScheduleResult, WorkflowSelection } from '../core/scheduler';
  3: import { getRuntimeFlag, setRuntimeFlag } from '../core/repositories';
  4: import { requestOpenAIText } from './openaiClient';
  5: 
  6: const AI_GUARDIAN_LAST_RUN_AT_KEY = 'ai_guardian.last_run_at';
  7: 
  8: export type AiGuardianSeverity = 'normal' | 'watch' | 'critical';
  9: 
 10: export interface AiGuardianDecision {
 11:     source: 'heuristic' | 'ai';
 12:     severity: AiGuardianSeverity;
 13:     summary: string;
 14:     recommendations: string[];
 15:     pauseMinutes: number;
 16: }
 17: 
 18: export interface AiGuardianResult {
 19:     executed: boolean;
 20:     reason: string;
 21:     decision: AiGuardianDecision | null;
 22: }
 23: 
 24: interface ParsedAiGuardianPayload {
 25:     severity: AiGuardianSeverity;
 26:     summary: string;
 27:     recommendations: string[];
 28:     pauseMinutes: number;
 29: }
 30: 
 31: function clampPauseMinutes(value: number): number {
 32:     const parsed = Number.isFinite(value) ? Math.floor(value) : 0;
 33:     if (parsed <= 0) return 0;
 34:     return Math.min(24 * 60, parsed);
 35: }
 36: 
 37: function heuristics(schedule: ScheduleResult): AiGuardianDecision {
 38:     const criticalList = schedule.listBreakdown.find(
 39:         (list) => list.pendingRatio >= 0.78 || list.blockedRatio >= 0.35
 40:     );
 41: 
 42:     if (schedule.riskSnapshot.action === 'STOP' || criticalList) {
 43:         return {
 44:             source: 'heuristic',
 45:             severity: 'critical',
 46:             summary: 'Rischio elevato rilevato prima dell’esecuzione.',
 47:             recommendations: [
 48:                 'Pausa automatica e controllo manuale account.',
 49:                 'Ridurre limiti giornalieri su inviti e messaggi.',
 50:                 'Eseguire site-check con --fix prima della ripartenza.',
 51:             ],
 52:             pauseMinutes: config.aiGuardianPauseMinutes,
 53:         };
 54:     }
 55: 
 56:     if (
 57:         schedule.riskSnapshot.action === 'WARN'
 58:         || schedule.riskSnapshot.pendingRatio >= config.pendingRatioWarn
 59:         || schedule.riskSnapshot.errorRate >= 0.2
 60:     ) {
 61:         return {
 62:             source: 'heuristic',
 63:             severity: 'watch',
 64:             summary: 'Rischio intermedio: conviene rallentare e monitorare.',
 65:             recommendations: [
 66:                 'Ridurre volume inviti nel prossimo ciclo.',
 67:                 'Aumentare intervallo loop e verificare mismatch DB/sito.',
 68:             ],
 69:             pauseMinutes: 0,
 70:         };
 71:     }
 72: 
 73:     return {
 74:         source: 'heuristic',
 75:         severity: 'normal',
 76:         summary: 'Situazione stabile.',
 77:         recommendations: ['Continuare con policy conservative attive.'],
 78:         pauseMinutes: 0,
 79:     };
 80: }
 81: 
 82: function tryExtractJsonBlock(raw: string): string | null {
 83:     const start = raw.indexOf('{');
 84:     const end = raw.lastIndexOf('}');
 85:     if (start === -1 || end === -1 || end <= start) {
 86:         return null;
 87:     }
 88:     return raw.slice(start, end + 1);
 89: }
 90: 
 91: function parseAiDecision(raw: string): ParsedAiGuardianPayload | null {
 92:     const jsonBlock = tryExtractJsonBlock(raw);
 93:     if (!jsonBlock) return null;
 94: 
 95:     try {
 96:         const parsed = JSON.parse(jsonBlock) as Record<string, unknown>;
 97:         const severityRaw = typeof parsed.severity === 'string' ? parsed.severity.toLowerCase() : '';
 98:         const severity: AiGuardianSeverity = severityRaw === 'critical' || severityRaw === 'watch' || severityRaw === 'normal'
 99:             ? severityRaw
100:             : 'watch';
101:         const summary = typeof parsed.summary === 'string' ? parsed.summary.trim() : '';
102:         const recommendationsRaw = Array.isArray(parsed.recommendations) ? parsed.recommendations : [];
103:         const recommendations = recommendationsRaw
104:             .filter((item): item is string => typeof item === 'string')
105:             .map((item) => item.trim())
106:             .filter(Boolean)
107:             .slice(0, 5);
108:         const pauseMinutesRaw = typeof parsed.pauseMinutes === 'number'
109:             ? parsed.pauseMinutes
110:             : Number.parseInt(String(parsed.pauseMinutes ?? '0'), 10);
111: 
112:         return {
113:             severity,
114:             summary: summary || 'AI guardian non ha fornito un summary dettagliato.',
115:             recommendations: recommendations.length > 0 ? recommendations : ['Verificare manualmente trend rischio.'],
116:             pauseMinutes: clampPauseMinutes(pauseMinutesRaw),
117:         };
118:     } catch {
119:         return null;
120:     }
121: }
122: 
123: async function shouldRunAiGuardianNow(now: Date): Promise<{ allowed: boolean; reason: string }> {
124:     const lastRaw = await getRuntimeFlag(AI_GUARDIAN_LAST_RUN_AT_KEY);
125:     if (!lastRaw) {
126:         return { allowed: true, reason: 'first_run' };
127:     }
128:     const parsed = Date.parse(lastRaw);
129:     if (!Number.isFinite(parsed)) {
130:         return { allowed: true, reason: 'invalid_last_run' };
131:     }
132:     const elapsedMinutes = (now.getTime() - parsed) / 60_000;
133:     if (elapsedMinutes >= config.aiGuardianMinIntervalMinutes) {
134:         return { allowed: true, reason: 'interval_elapsed' };
135:     }
136:     return { allowed: false, reason: 'interval_not_elapsed' };
137: }
138: 
139: export async function evaluateAiGuardian(
140:     workflow: WorkflowSelection,
141:     schedule: ScheduleResult
142: ): Promise<AiGuardianResult> {
143:     const heuristicDecision = heuristics(schedule);
144:     if (!config.aiGuardianEnabled || !config.openaiApiKey) {
145:         return {
146:             executed: true,
147:             reason: 'heuristic_only',
148:             decision: heuristicDecision,
149:         };
150:     }
151: 
152:     const now = new Date();
153:     const runCheck = await shouldRunAiGuardianNow(now);
154:     if (!runCheck.allowed) {
155:         return {
156:             executed: false,
157:             reason: runCheck.reason,
158:             decision: null,
159:         };
160:     }
161: 
162:     const systemPrompt = [
163:         'Sei un risk controller per automazione LinkedIn.',
164:         'Valuta il rischio in anticipo e rispondi SOLO JSON valido.',
165:         'Schema JSON: {"severity":"normal|watch|critical","summary":"...","recommendations":["..."],"pauseMinutes":number}',
166:         'Usa approccio conservativo, no ottimismo.',
167:     ].join(' ');
168:     const userPrompt = JSON.stringify({
169:         workflow,
170:         riskSnapshot: schedule.riskSnapshot,
171:         inviteBudget: schedule.inviteBudget,
172:         messageBudget: schedule.messageBudget,
173:         queuedInviteJobs: schedule.queuedInviteJobs,
174:         queuedCheckJobs: schedule.queuedCheckJobs,
175:         queuedMessageJobs: schedule.queuedMessageJobs,
176:         listBreakdown: schedule.listBreakdown,
177:         fallbackHeuristic: heuristicDecision,
178:     });
179: 
180:     try {
181:         const text = await requestOpenAIText({
182:             system: systemPrompt,
183:             user: `Valuta questo contesto operativo e decidi: ${userPrompt}`,
184:             maxOutputTokens: 260,
185:             temperature: 0.2,
186:         });
187:         const parsed = parseAiDecision(text);
188:         await setRuntimeFlag(AI_GUARDIAN_LAST_RUN_AT_KEY, now.toISOString());
189: 
190:         if (!parsed) {
191:             return {
192:                 executed: true,
193:                 reason: 'ai_parse_failed_fallback_heuristic',
194:                 decision: heuristicDecision,
195:             };
196:         }
197: 
198:         return {
199:             executed: true,
200:             reason: runCheck.reason,
201:             decision: {
202:                 source: 'ai',
203:                 severity: parsed.severity,
204:                 summary: parsed.summary,
205:                 recommendations: parsed.recommendations,
206:                 pauseMinutes: parsed.pauseMinutes,
207:             },
208:         };
209:     } catch {
210:         return {
211:             executed: true,
212:             reason: 'ai_error_fallback_heuristic',
213:             decision: heuristicDecision,
214:         };
215:     }
216: }
````

## File: src/ai/messagePersonalizer.ts
````typescript
 1: import { config } from '../config';
 2: import { buildFollowUpMessage } from '../messages';
 3: import { LeadRecord } from '../types/domain';
 4: import { requestOpenAIText } from './openaiClient';
 5: import { logWarn } from '../telemetry/logger';
 6: 
 7: export interface PersonalizedMessageResult {
 8:     message: string;
 9:     source: 'template' | 'ai';
10:     model: string | null;
11: }
12: 
13: function trimToMaxChars(input: string, maxChars: number): string {
14:     const normalized = input.replace(/\s+\n/g, '\n').replace(/\n{3,}/g, '\n\n').trim();
15:     if (normalized.length <= maxChars) {
16:         return normalized;
17:     }
18:     return normalized.slice(0, maxChars).trim();
19: }
20: 
21: function safeFirstName(lead: LeadRecord): string {
22:     const value = (lead.first_name ?? '').trim();
23:     if (value) return value;
24:     return 'there';
25: }
26: 
27: export async function buildPersonalizedFollowUpMessage(lead: LeadRecord): Promise<PersonalizedMessageResult> {
28:     const template = buildFollowUpMessage(lead);
29:     if (!config.aiPersonalizationEnabled || !config.openaiApiKey) {
30:         return {
31:             message: trimToMaxChars(template, config.aiMessageMaxChars),
32:             source: 'template',
33:             model: null,
34:         };
35:     }
36: 
37:     const systemPrompt = [
38:         'Sei un assistant B2B per outreach LinkedIn in italiano.',
39:         'Genera un singolo messaggio breve, naturale, professionale.',
40:         `Massimo ${config.aiMessageMaxChars} caratteri.`,
41:         'Niente hype, niente emoji, niente claim aggressivi, niente link.',
42:         'Mantieni tono rispettoso e personalizzato sul profilo.',
43:     ].join(' ');
44: 
45:     const userPrompt = JSON.stringify({
46:         firstName: safeFirstName(lead),
47:         lastName: lead.last_name,
48:         company: lead.account_name,
49:         role: lead.job_title,
50:         website: lead.website,
51:         fallbackTemplate: template,
52:     });
53: 
54:     try {
55:         const generated = await requestOpenAIText({
56:             system: systemPrompt,
57:             user: `Dati lead: ${userPrompt}`,
58:             maxOutputTokens: 220,
59:             temperature: 0.6,
60:         });
61:         const finalMessage = trimToMaxChars(generated, config.aiMessageMaxChars);
62:         if (!finalMessage) {
63:             return {
64:                 message: trimToMaxChars(template, config.aiMessageMaxChars),
65:                 source: 'template',
66:                 model: null,
67:             };
68:         }
69:         return {
70:             message: finalMessage,
71:             source: 'ai',
72:             model: config.aiModel,
73:         };
74:     } catch (error) {
75:         await logWarn('ai.personalization.fallback_template', {
76:             leadId: lead.id,
77:             error: error instanceof Error ? error.message : String(error),
78:         });
79:         return {
80:             message: trimToMaxChars(template, config.aiMessageMaxChars),
81:             source: 'template',
82:             model: null,
83:         };
84:     }
85: }
````

## File: src/ai/openaiClient.ts
````typescript
 1: import { config } from '../config';
 2: 
 3: interface OpenAITextRequest {
 4:     system: string;
 5:     user: string;
 6:     maxOutputTokens: number;
 7:     temperature: number;
 8: }
 9: 
10: function safeJoinUrl(baseUrl: string, suffix: string): string {
11:     return `${baseUrl.replace(/\/+$/, '')}${suffix}`;
12: }
13: 
14: function extractOutputText(payload: unknown): string {
15:     if (!payload || typeof payload !== 'object') {
16:         return '';
17:     }
18: 
19:     const direct = (payload as { output_text?: unknown }).output_text;
20:     if (typeof direct === 'string' && direct.trim()) {
21:         return direct.trim();
22:     }
23: 
24:     const output = (payload as { output?: unknown }).output;
25:     if (!Array.isArray(output)) {
26:         return '';
27:     }
28: 
29:     const fragments: string[] = [];
30:     for (const item of output) {
31:         if (!item || typeof item !== 'object') continue;
32:         const content = (item as { content?: unknown }).content;
33:         if (!Array.isArray(content)) continue;
34:         for (const block of content) {
35:             if (!block || typeof block !== 'object') continue;
36:             const type = (block as { type?: unknown }).type;
37:             if (type !== 'output_text') continue;
38:             const text = (block as { text?: unknown }).text;
39:             if (typeof text === 'string' && text.trim()) {
40:                 fragments.push(text.trim());
41:             }
42:         }
43:     }
44: 
45:     return fragments.join('\n').trim();
46: }
47: 
48: export function isOpenAIConfigured(): boolean {
49:     return !!config.openaiApiKey;
50: }
51: 
52: export async function requestOpenAIText(input: OpenAITextRequest): Promise<string> {
53:     if (!config.openaiApiKey) {
54:         throw new Error('OPENAI_API_KEY mancante.');
55:     }
56: 
57:     const response = await fetch(safeJoinUrl(config.openaiBaseUrl, '/responses'), {
58:         method: 'POST',
59:         headers: {
60:             'content-type': 'application/json',
61:             authorization: `Bearer ${config.openaiApiKey}`,
62:         },
63:         body: JSON.stringify({
64:             model: config.aiModel,
65:             input: [
66:                 { role: 'system', content: input.system },
67:                 { role: 'user', content: input.user },
68:             ],
69:             temperature: input.temperature,
70:             max_output_tokens: input.maxOutputTokens,
71:         }),
72:         signal: AbortSignal.timeout(config.aiRequestTimeoutMs),
73:     });
74: 
75:     if (!response.ok) {
76:         const text = (await response.text().catch(() => '')).slice(0, 500);
77:         throw new Error(`OpenAI HTTP ${response.status}: ${response.statusText}${text ? ` ${text}` : ''}`);
78:     }
79: 
80:     const payload = await response.json().catch(() => null);
81:     const outputText = extractOutputText(payload);
82:     if (!outputText) {
83:         throw new Error('Risposta AI vuota o non parseabile.');
84:     }
85:     return outputText;
86: }
````

## File: src/browser.ts
````typescript
  1: import { chromium, BrowserContext, Page } from 'playwright';
  2: import { config } from './config';
  3: import { ensureDirectoryPrivate } from './security/filesystem';
  4: import { SELECTORS } from './selectors';
  5: 
  6: export interface BrowserSession {
  7:     browser: BrowserContext;
  8:     page: Page;
  9: }
 10: 
 11: export interface LaunchBrowserOptions {
 12:     headless?: boolean;
 13: }
 14: 
 15: export async function launchBrowser(options: LaunchBrowserOptions = {}): Promise<BrowserSession> {
 16:     ensureDirectoryPrivate(config.sessionDir);
 17: 
 18:     const browser = await chromium.launchPersistentContext(config.sessionDir, {
 19:         headless: options.headless ?? config.headless,
 20:         viewport: { width: 1280, height: 800 },
 21:     });
 22: 
 23:     const existingPage = browser.pages()[0];
 24:     const page = existingPage ?? await browser.newPage();
 25:     return { browser, page };
 26: }
 27: 
 28: export async function closeBrowser(session: BrowserSession): Promise<void> {
 29:     await session.browser.close();
 30: }
 31: 
 32: async function hasLinkedinAuthCookie(page: Page): Promise<boolean> {
 33:     try {
 34:         const cookies = await page.context().cookies('https://www.linkedin.com');
 35:         return cookies.some((cookie) => cookie.name === 'li_at' && cookie.value.trim().length > 0);
 36:     } catch {
 37:         return false;
 38:     }
 39: }
 40: 
 41: export async function isLoggedIn(page: Page): Promise<boolean> {
 42:     if (await hasLinkedinAuthCookie(page)) {
 43:         return true;
 44:     }
 45: 
 46:     const count = await page.locator(SELECTORS.globalNav).count();
 47:     if (count > 0) {
 48:         return true;
 49:     }
 50: 
 51:     const currentUrl = page.url().toLowerCase();
 52:     if (currentUrl.includes('/login') || currentUrl.includes('/checkpoint') || currentUrl.includes('/challenge')) {
 53:         return false;
 54:     }
 55: 
 56:     const loginForm = await page.locator('form[action*="login"], input[name="session_key"]').count();
 57:     return loginForm === 0;
 58: }
 59: 
 60: export async function checkLogin(page: Page): Promise<boolean> {
 61:     await page.goto('https://www.linkedin.com/', { waitUntil: 'load' });
 62:     await humanDelay(page, 2000, 4000);
 63:     return isLoggedIn(page);
 64: }
 65: 
 66: export async function detectChallenge(page: Page): Promise<boolean> {
 67:     const currentUrl = page.url().toLowerCase();
 68:     const challengeInUrl = ['checkpoint', 'challenge', 'captcha', 'security-verification'].some((token) => currentUrl.includes(token));
 69:     if (challengeInUrl) {
 70:         return true;
 71:     }
 72: 
 73:     const selectorMatches = await page.locator(SELECTORS.challengeSignals).count();
 74:     return selectorMatches > 0;
 75: }
 76: 
 77: export async function humanDelay(page: Page, min: number = 1500, max: number = 3500): Promise<void> {
 78:     const delay = Math.floor(Math.random() * (max - min + 1) + min);
 79:     await page.waitForTimeout(delay);
 80: }
 81: 
 82: export async function simulateHumanReading(page: Page): Promise<void> {
 83:     await page.evaluate(() => window.scrollBy(0, 400));
 84:     await humanDelay(page, 1000, 2500);
 85:     await page.evaluate(() => window.scrollBy(0, 450));
 86:     await humanDelay(page, 800, 1800);
 87:     await page.evaluate(() => window.scrollTo(0, 0));
 88:     await humanDelay(page, 600, 1500);
 89: }
 90: 
 91: /**
 92:  * Digita il testo carattere per carattere con delay variabile,
 93:  * simulando la velocità di digitazione umana (40–120 WPM ≈ 50–250 ms/carattere).
 94:  * Evita il pattern rilevabile di fill() / paste istantaneo.
 95:  */
 96: export async function humanType(page: Page, selector: string, text: string): Promise<void> {
 97:     const element = page.locator(selector).first();
 98:     await element.click();
 99:     await humanDelay(page, 200, 500);
100:     for (const char of text) {
101:         await element.pressSequentially(char, { delay: Math.floor(Math.random() * 180) + 50 });
102:         // Pausa occasionale più lunga (simula pausa mentre si pensa)
103:         if (Math.random() < 0.04) {
104:             await humanDelay(page, 400, 1200);
105:         }
106:     }
107: }
108: 
109: /**
110:  * Pausa randomizzata tra un job e il successivo per evitare il pattern burst.
111:  * Range: 30–120 secondi di base, con picco occasionale ("pausa caffè").
112:  */
113: export async function interJobDelay(page: Page): Promise<void> {
114:     // Pausa base 30–90 s
115:     const base = Math.floor(Math.random() * 60_000) + 30_000;
116:     // 8% di probabilità di pausa lunga 3–7 minuti
117:     const longBreak = Math.random() < 0.08 ? Math.floor(Math.random() * 240_000) + 180_000 : 0;
118:     await page.waitForTimeout(base + longBreak);
119: }
120: 
121: export async function runSelectorCanary(page: Page): Promise<boolean> {
122:     await page.goto('https://www.linkedin.com/feed/', { waitUntil: 'domcontentloaded' });
123:     await humanDelay(page, 1200, 2000);
124:     const navOk = await page.locator(SELECTORS.globalNav).count();
125:     return navOk > 0;
126: }
````

## File: src/config.ts
````typescript
  1: import path from 'path';
  2: import fs from 'fs';
  3: import dotenv from 'dotenv';
  4: 
  5: const envPath = path.resolve(process.cwd(), '.env');
  6: if (fs.existsSync(envPath)) {
  7:     dotenv.config({ path: envPath });
  8: }
  9: 
 10: function parseIntEnv(name: string, fallback: number): number {
 11:     const raw = process.env[name];
 12:     if (!raw) return fallback;
 13:     const parsed = Number.parseInt(raw, 10);
 14:     return Number.isFinite(parsed) ? parsed : fallback;
 15: }
 16: 
 17: function parseFloatEnv(name: string, fallback: number): number {
 18:     const raw = process.env[name];
 19:     if (!raw) return fallback;
 20:     const parsed = Number.parseFloat(raw);
 21:     return Number.isFinite(parsed) ? parsed : fallback;
 22: }
 23: 
 24: function parseBoolEnv(name: string, fallback: boolean): boolean {
 25:     const raw = process.env[name];
 26:     if (raw === undefined) return fallback;
 27:     return raw.toLowerCase() === 'true';
 28: }
 29: 
 30: function parseStringEnv(name: string, fallback: string = ''): string {
 31:     const raw = process.env[name];
 32:     if (raw === undefined) return fallback;
 33:     return raw.trim();
 34: }
 35: 
 36: export type EventSyncSink = 'SUPABASE' | 'WEBHOOK' | 'NONE';
 37: 
 38: function parseEventSyncSinkEnv(name: string, fallback: EventSyncSink): EventSyncSink {
 39:     const raw = parseStringEnv(name, fallback).toUpperCase();
 40:     if (raw === 'SUPABASE' || raw === 'WEBHOOK' || raw === 'NONE') {
 41:         return raw;
 42:     }
 43:     return fallback;
 44: }
 45: 
 46: function resolvePathFromEnv(name: string, fallbackRelativePath: string): string {
 47:     const raw = process.env[name];
 48:     if (!raw) {
 49:         return path.resolve(process.cwd(), fallbackRelativePath);
 50:     }
 51:     return path.isAbsolute(raw) ? raw : path.resolve(process.cwd(), raw);
 52: }
 53: 
 54: export interface AppConfig {
 55:     timezone: string;
 56:     headless: boolean;
 57:     workingHoursStart: number;
 58:     workingHoursEnd: number;
 59:     maxConcurrentJobs: number;
 60:     jobStuckMinutes: number;
 61:     retryMaxAttempts: number;
 62:     retryBaseMs: number;
 63:     workflowLoopIntervalMs: number;
 64:     companyEnrichmentEnabled: boolean;
 65:     companyEnrichmentBatch: number;
 66:     companyEnrichmentMaxProfilesPerCompany: number;
 67:     maxConsecutiveJobFailures: number;
 68:     maxSelectorFailuresPerDay: number;
 69:     maxRunErrorsPerDay: number;
 70:     autoPauseMinutesOnFailureBurst: number;
 71:     retentionDays: number;
 72:     softInviteCap: number;
 73:     hardInviteCap: number;
 74:     weeklyInviteLimit: number;
 75:     softMsgCap: number;
 76:     hardMsgCap: number;
 77:     riskWarnThreshold: number;
 78:     riskStopThreshold: number;
 79:     pendingRatioWarn: number;
 80:     pendingRatioStop: number;
 81:     adaptiveCapsEnabled: boolean;
 82:     adaptiveCapsPendingWarn: number;
 83:     adaptiveCapsPendingStop: number;
 84:     adaptiveCapsBlockedWarn: number;
 85:     adaptiveCapsMinFactor: number;
 86:     adaptiveCapsWarnFactor: number;
 87:     cooldownEnabled: boolean;
 88:     cooldownWarnScore: number;
 89:     cooldownHighScore: number;
 90:     cooldownPendingThreshold: number;
 91:     cooldownPendingHighThreshold: number;
 92:     cooldownWarnMinutes: number;
 93:     cooldownHighMinutes: number;
 94:     noBurstEnabled: boolean;
 95:     noBurstMinDelaySec: number;
 96:     noBurstMaxDelaySec: number;
 97:     noBurstLongBreakEvery: number;
 98:     noBurstLongBreakMinSec: number;
 99:     noBurstLongBreakMaxSec: number;
100:     autoSiteCheckEnabled: boolean;
101:     autoSiteCheckLimit: number;
102:     autoSiteCheckFix: boolean;
103:     autoSiteCheckIntervalHours: number;
104:     postRunStateSyncEnabled: boolean;
105:     postRunStateSyncLimit: number;
106:     postRunStateSyncFix: boolean;
107:     selectorCanaryEnabled: boolean;
108:     outboxAlertBacklog: number;
109:     sessionDir: string;
110:     dbPath: string;
111:     eventSyncSink: EventSyncSink;
112:     supabaseSyncEnabled: boolean;
113:     supabaseUrl: string;
114:     supabaseServiceRoleKey: string;
115:     supabaseSyncBatchSize: number;
116:     supabaseSyncIntervalMs: number;
117:     supabaseSyncMaxRetries: number;
118:     webhookSyncEnabled: boolean;
119:     webhookSyncUrl: string;
120:     webhookSyncSecret: string;
121:     webhookSyncBatchSize: number;
122:     webhookSyncTimeoutMs: number;
123:     webhookSyncMaxRetries: number;
124:     openaiApiKey: string;
125:     openaiBaseUrl: string;
126:     aiModel: string;
127:     aiRequestTimeoutMs: number;
128:     aiPersonalizationEnabled: boolean;
129:     aiMessageMaxChars: number;
130:     aiGuardianEnabled: boolean;
131:     aiGuardianMinIntervalMinutes: number;
132:     aiGuardianPauseMinutes: number;
133:     telegramBotToken: string;
134:     telegramChatId: string;
135: }
136: 
137: export const config: AppConfig = {
138:     timezone: process.env.TIMEZONE ?? 'Europe/Rome',
139:     headless: parseBoolEnv('HEADLESS', false),
140:     workingHoursStart: parseIntEnv('HOUR_START', 9),
141:     workingHoursEnd: parseIntEnv('HOUR_END', 18),
142:     maxConcurrentJobs: Math.max(1, parseIntEnv('MAX_CONCURRENT_JOBS', 1)),
143:     jobStuckMinutes: Math.max(1, parseIntEnv('JOB_STUCK_MINUTES', 30)),
144:     retryMaxAttempts: Math.max(1, parseIntEnv('RETRY_MAX_ATTEMPTS', 3)),
145:     retryBaseMs: Math.max(100, parseIntEnv('RETRY_BASE_MS', 1200)),
146:     workflowLoopIntervalMs: Math.max(10_000, parseIntEnv('WORKFLOW_LOOP_INTERVAL_MS', 900000)),
147:     companyEnrichmentEnabled: parseBoolEnv('COMPANY_ENRICHMENT_ENABLED', true),
148:     companyEnrichmentBatch: Math.max(1, parseIntEnv('COMPANY_ENRICHMENT_BATCH', 5)),
149:     companyEnrichmentMaxProfilesPerCompany: Math.max(1, parseIntEnv('COMPANY_ENRICHMENT_MAX_PROFILES_PER_COMPANY', 3)),
150:     maxConsecutiveJobFailures: Math.max(1, parseIntEnv('MAX_CONSECUTIVE_JOB_FAILURES', 4)),
151:     maxSelectorFailuresPerDay: Math.max(1, parseIntEnv('MAX_SELECTOR_FAILURES_PER_DAY', 8)),
152:     maxRunErrorsPerDay: Math.max(1, parseIntEnv('MAX_RUN_ERRORS_PER_DAY', 20)),
153:     autoPauseMinutesOnFailureBurst: Math.max(1, parseIntEnv('AUTO_PAUSE_MINUTES_ON_FAILURE_BURST', 180)),
154:     retentionDays: Math.max(7, parseIntEnv('RETENTION_DAYS', 45)),
155:     softInviteCap: Math.max(1, parseIntEnv('SOFT_INVITE_CAP', 25)),
156:     hardInviteCap: Math.max(1, parseIntEnv('HARD_INVITE_CAP', 35)),
157:     weeklyInviteLimit: Math.max(1, parseIntEnv('WEEKLY_INVITE_LIMIT', 120)),
158:     softMsgCap: Math.max(1, parseIntEnv('SOFT_MSG_CAP', 40)),
159:     hardMsgCap: Math.max(1, parseIntEnv('HARD_MSG_CAP', 60)),
160:     riskWarnThreshold: parseIntEnv('RISK_WARN_THRESHOLD', 60),
161:     riskStopThreshold: parseIntEnv('RISK_STOP_THRESHOLD', 80),
162:     pendingRatioWarn: parseFloatEnv('PENDING_RATIO_WARN', 0.65),
163:     pendingRatioStop: parseFloatEnv('PENDING_RATIO_STOP', 0.8),
164:     adaptiveCapsEnabled: parseBoolEnv('ADAPTIVE_CAPS_ENABLED', true),
165:     adaptiveCapsPendingWarn: Math.min(1, Math.max(0, parseFloatEnv('ADAPTIVE_CAPS_PENDING_WARN', 0.55))),
166:     adaptiveCapsPendingStop: Math.min(1, Math.max(0, parseFloatEnv('ADAPTIVE_CAPS_PENDING_STOP', 0.72))),
167:     adaptiveCapsBlockedWarn: Math.min(1, Math.max(0, parseFloatEnv('ADAPTIVE_CAPS_BLOCKED_WARN', 0.25))),
168:     adaptiveCapsMinFactor: Math.min(1, Math.max(0.05, parseFloatEnv('ADAPTIVE_CAPS_MIN_FACTOR', 0.25))),
169:     adaptiveCapsWarnFactor: Math.min(1, Math.max(0.05, parseFloatEnv('ADAPTIVE_CAPS_WARN_FACTOR', 0.85))),
170:     cooldownEnabled: parseBoolEnv('COOLDOWN_ENABLED', true),
171:     cooldownWarnScore: Math.max(0, parseIntEnv('COOLDOWN_WARN_SCORE', 68)),
172:     cooldownHighScore: Math.max(0, parseIntEnv('COOLDOWN_HIGH_SCORE', 75)),
173:     cooldownPendingThreshold: Math.min(1, Math.max(0, parseFloatEnv('COOLDOWN_PENDING_THRESHOLD', 0.65))),
174:     cooldownPendingHighThreshold: Math.min(1, Math.max(0, parseFloatEnv('COOLDOWN_PENDING_HIGH_THRESHOLD', 0.75))),
175:     cooldownWarnMinutes: Math.max(10, parseIntEnv('COOLDOWN_WARN_MINUTES', 2880)),
176:     cooldownHighMinutes: Math.max(10, parseIntEnv('COOLDOWN_HIGH_MINUTES', 4320)),
177:     noBurstEnabled: parseBoolEnv('NO_BURST_ENABLED', true),
178:     noBurstMinDelaySec: Math.max(0, parseIntEnv('NO_BURST_MIN_DELAY_SEC', 8)),
179:     noBurstMaxDelaySec: Math.max(0, parseIntEnv('NO_BURST_MAX_DELAY_SEC', 25)),
180:     noBurstLongBreakEvery: Math.max(0, parseIntEnv('NO_BURST_LONG_BREAK_EVERY', 7)),
181:     noBurstLongBreakMinSec: Math.max(0, parseIntEnv('NO_BURST_LONG_BREAK_MIN_SEC', 120)),
182:     noBurstLongBreakMaxSec: Math.max(0, parseIntEnv('NO_BURST_LONG_BREAK_MAX_SEC', 360)),
183:     autoSiteCheckEnabled: parseBoolEnv('AUTO_SITE_CHECK_ENABLED', true),
184:     autoSiteCheckLimit: Math.max(1, parseIntEnv('AUTO_SITE_CHECK_LIMIT', 20)),
185:     autoSiteCheckFix: parseBoolEnv('AUTO_SITE_CHECK_FIX', true),
186:     autoSiteCheckIntervalHours: Math.max(1, parseIntEnv('AUTO_SITE_CHECK_INTERVAL_HOURS', 24)),
187:     postRunStateSyncEnabled: parseBoolEnv('POST_RUN_STATE_SYNC_ENABLED', true),
188:     postRunStateSyncLimit: Math.max(1, parseIntEnv('POST_RUN_STATE_SYNC_LIMIT', 8)),
189:     postRunStateSyncFix: parseBoolEnv('POST_RUN_STATE_SYNC_FIX', true),
190:     selectorCanaryEnabled: parseBoolEnv('SELECTOR_CANARY_ENABLED', true),
191:     outboxAlertBacklog: Math.max(1, parseIntEnv('OUTBOX_ALERT_BACKLOG', 1000)),
192:     sessionDir: resolvePathFromEnv('SESSION_DIR', path.join('data', 'session')),
193:     dbPath: resolvePathFromEnv('DB_PATH', path.join('data', 'linkedin_bot.sqlite')),
194:     eventSyncSink: parseEventSyncSinkEnv('EVENT_SYNC_SINK', 'SUPABASE'),
195:     supabaseSyncEnabled: parseBoolEnv('SUPABASE_SYNC_ENABLED', true),
196:     supabaseUrl: parseStringEnv('SUPABASE_URL'),
197:     supabaseServiceRoleKey: parseStringEnv('SUPABASE_SERVICE_ROLE_KEY'),
198:     supabaseSyncBatchSize: Math.max(1, parseIntEnv('SUPABASE_SYNC_BATCH_SIZE', 100)),
199:     supabaseSyncIntervalMs: Math.max(1000, parseIntEnv('SUPABASE_SYNC_INTERVAL_MS', 15000)),
200:     supabaseSyncMaxRetries: Math.max(1, parseIntEnv('SUPABASE_SYNC_MAX_RETRIES', 8)),
201:     webhookSyncEnabled: parseBoolEnv('WEBHOOK_SYNC_ENABLED', false),
202:     webhookSyncUrl: parseStringEnv('WEBHOOK_SYNC_URL'),
203:     webhookSyncSecret: parseStringEnv('WEBHOOK_SYNC_SECRET'),
204:     webhookSyncBatchSize: Math.max(1, parseIntEnv('WEBHOOK_SYNC_BATCH_SIZE', 100)),
205:     webhookSyncTimeoutMs: Math.max(1000, parseIntEnv('WEBHOOK_SYNC_TIMEOUT_MS', 10000)),
206:     webhookSyncMaxRetries: Math.max(1, parseIntEnv('WEBHOOK_SYNC_MAX_RETRIES', 8)),
207:     openaiApiKey: parseStringEnv('OPENAI_API_KEY'),
208:     openaiBaseUrl: parseStringEnv('OPENAI_BASE_URL', 'https://api.openai.com/v1'),
209:     aiModel: parseStringEnv('AI_MODEL', 'gpt-4.1-mini'),
210:     aiRequestTimeoutMs: Math.max(1000, parseIntEnv('AI_REQUEST_TIMEOUT_MS', 12000)),
211:     aiPersonalizationEnabled: parseBoolEnv('AI_PERSONALIZATION_ENABLED', false),
212:     aiMessageMaxChars: Math.max(120, parseIntEnv('AI_MESSAGE_MAX_CHARS', 450)),
213:     aiGuardianEnabled: parseBoolEnv('AI_GUARDIAN_ENABLED', false),
214:     aiGuardianMinIntervalMinutes: Math.max(1, parseIntEnv('AI_GUARDIAN_MIN_INTERVAL_MINUTES', 60)),
215:     aiGuardianPauseMinutes: Math.max(10, parseIntEnv('AI_GUARDIAN_PAUSE_MINUTES', 180)),
216:     telegramBotToken: parseStringEnv('TELEGRAM_BOT_TOKEN'),
217:     telegramChatId: parseStringEnv('TELEGRAM_CHAT_ID'),
218: };
219: 
220: // Retrocompatibilità con vecchi moduli ancora presenti nel repository.
221: export const legacyLimits = {
222:     dailyInviteLimit: config.hardInviteCap,
223:     weeklyInviteLimit: config.weeklyInviteLimit,
224:     dailyMsgLimit: config.hardMsgCap,
225: };
226: 
227: export function isWorkingHour(now: Date = new Date()): boolean {
228:     const hour = getHourInTimezone(now, config.timezone);
229:     return hour >= config.workingHoursStart && hour < config.workingHoursEnd;
230: }
231: 
232: export function getLocalDateString(now: Date = new Date(), timezone: string = config.timezone): string {
233:     const formatter = new Intl.DateTimeFormat('en-CA', {
234:         timeZone: timezone,
235:         year: 'numeric',
236:         month: '2-digit',
237:         day: '2-digit',
238:     });
239:     return formatter.format(now);
240: }
241: 
242: export function getHourInTimezone(now: Date, timezone: string): number {
243:     const formatter = new Intl.DateTimeFormat('en-GB', {
244:         timeZone: timezone,
245:         hour: '2-digit',
246:         hour12: false,
247:     });
248:     const formatted = formatter.format(now);
249:     return Number.parseInt(formatted, 10);
250: }
251: 
252: export function getWeekStartDate(now: Date = new Date(), timezone: string = config.timezone): string {
253:     const localDate = getLocalDateString(now, timezone);
254:     const [year, month, day] = localDate.split('-').map((value) => Number.parseInt(value, 10));
255:     const anchor = new Date(Date.UTC(year, month - 1, day));
256:     const weekday = anchor.getUTCDay();
257:     const delta = weekday === 0 ? -6 : 1 - weekday;
258:     anchor.setUTCDate(anchor.getUTCDate() + delta);
259:     const anchorYear = anchor.getUTCFullYear();
260:     const anchorMonth = String(anchor.getUTCMonth() + 1).padStart(2, '0');
261:     const anchorDay = String(anchor.getUTCDate()).padStart(2, '0');
262:     return `${anchorYear}-${anchorMonth}-${anchorDay}`;
263: }
````

## File: src/connectWorkflow.ts
````typescript
1: import { runWorkflow } from './core/orchestrator';
2: 
3: export async function runConnectionWorkflow(): Promise<void> {
4:     await runWorkflow({
5:         workflow: 'invite',
6:         dryRun: false,
7:     });
8: }
````

## File: src/core/audit.ts
````typescript
  1: import { checkLogin, closeBrowser, detectChallenge, humanDelay, launchBrowser } from '../browser';
  2: import { quarantineAccount } from '../risk/incidentManager';
  3: import { SELECTORS } from '../selectors';
  4: import { LeadRecord } from '../types/domain';
  5: import { reconcileLeadStatus, transitionLead } from './leadStateService';
  6: import {
  7:     countCompanyTargets,
  8:     countCompanyTargetsByStatuses,
  9:     countLeadsByStatuses,
 10:     countPendingOutboxEvents,
 11:     getJobStatusCounts,
 12:     getLeadsByStatus,
 13:     JobStatusCounts,
 14: } from './repositories';
 15: import { Page } from 'playwright';
 16: 
 17: export interface FunnelReport {
 18:     totals: {
 19:         leads: number;
 20:         companyTargets: number;
 21:         queuedJobs: number;
 22:         pendingOutbox: number;
 23:     };
 24:     connections: {
 25:         toSend: number;
 26:         invitedPendingAcceptance: number;
 27:         acceptedReadyMessage: number;
 28:         completed: number;
 29:     };
 30:     messages: {
 31:         toSend: number;
 32:         sent: number;
 33:         blockedOrSkipped: number;
 34:     };
 35:     companyTargetStatuses: {
 36:         NEW: number;
 37:         ENRICHED: number;
 38:         NO_MATCH: number;
 39:         ERROR: number;
 40:     };
 41:     leadStatuses: Record<string, number>;
 42:     jobs: JobStatusCounts;
 43: }
 44: 
 45: export interface SiteCheckItem {
 46:     leadId: number;
 47:     status: string;
 48:     linkedinUrl: string;
 49:     siteSignals: {
 50:         pendingInvite: boolean;
 51:         connected: boolean;
 52:         messageButton: boolean;
 53:         canConnect: boolean;
 54:     };
 55:     mismatch: string;
 56:     fixed: boolean;
 57: }
 58: 
 59: export interface SiteCheckReport {
 60:     scanned: number;
 61:     mismatches: number;
 62:     fixed: number;
 63:     items: SiteCheckItem[];
 64: }
 65: 
 66: export interface SiteCheckOptions {
 67:     limitPerStatus: number;
 68:     autoFix: boolean;
 69: }
 70: 
 71: function isFirstDegreeBadge(text: string | null): boolean {
 72:     if (!text) return true;
 73:     return /1st|1°|1\b/i.test(text);
 74: }
 75: 
 76: async function inspectLeadOnSite(lead: LeadRecord, sessionPage: Page): Promise<{
 77:     pendingInvite: boolean;
 78:     connected: boolean;
 79:     messageButton: boolean;
 80:     canConnect: boolean;
 81: }> {
 82:     await sessionPage.goto(lead.linkedin_url, { waitUntil: 'domcontentloaded' });
 83:     await humanDelay(sessionPage, 1200, 2200);
 84: 
 85:     const messageButton = (await sessionPage.locator(SELECTORS.messageButton).count()) > 0;
 86:     const badgeText = await sessionPage.locator(SELECTORS.distanceBadge).first().textContent().catch(() => '');
 87:     const connected = messageButton && isFirstDegreeBadge(badgeText);
 88:     const pendingInvite = (await sessionPage.locator(SELECTORS.invitePendingIndicators).count()) > 0;
 89:     const canConnect = (await sessionPage.locator(SELECTORS.connectButtonPrimary).count()) > 0;
 90: 
 91:     return {
 92:         pendingInvite,
 93:         connected,
 94:         messageButton,
 95:         canConnect,
 96:     };
 97: }
 98: 
 99: async function tryAutoFix(lead: LeadRecord, mismatch: string): Promise<boolean> {
100:     if (mismatch === 'invited_but_connected') {
101:         await transitionLead(lead.id, 'ACCEPTED', 'site_check_autofix_connected');
102:         await transitionLead(lead.id, 'READY_MESSAGE', 'site_check_autofix_ready_message');
103:         return true;
104:     }
105: 
106:     if (mismatch === 'ready_invite_but_pending') {
107:         await transitionLead(lead.id, 'INVITED', 'site_check_autofix_pending');
108:         return true;
109:     }
110: 
111:     if (mismatch === 'ready_invite_but_connected') {
112:         await transitionLead(lead.id, 'INVITED', 'site_check_autofix_connected_promote_invited');
113:         await transitionLead(lead.id, 'ACCEPTED', 'site_check_autofix_connected_promote_accepted');
114:         await transitionLead(lead.id, 'READY_MESSAGE', 'site_check_autofix_connected_promote_ready_message');
115:         return true;
116:     }
117: 
118:     if (mismatch === 'ready_message_but_pending_invite') {
119:         await reconcileLeadStatus(lead.id, 'INVITED', 'site_check_reconcile_ready_message_to_invited_pending');
120:         return true;
121:     }
122: 
123:     if (mismatch === 'messaged_but_pending_invite') {
124:         await reconcileLeadStatus(lead.id, 'INVITED', 'site_check_reconcile_messaged_to_invited_pending');
125:         return true;
126:     }
127: 
128:     if (mismatch === 'invited_but_connect_available') {
129:         await reconcileLeadStatus(lead.id, 'READY_INVITE', 'site_check_reconcile_invited_to_ready_invite_connect_available');
130:         return true;
131:     }
132: 
133:     return false;
134: }
135: 
136: export async function buildFunnelReport(): Promise<FunnelReport> {
137:     const [
138:         newCount,
139:         readyInviteCount,
140:         invitedCount,
141:         acceptedCount,
142:         readyMessageCount,
143:         messagedCount,
144:         blockedCount,
145:         skippedCount,
146:         pendingOutbox,
147:         companyTargets,
148:         companyTargetsNew,
149:         companyTargetsEnriched,
150:         companyTargetsNoMatch,
151:         companyTargetsError,
152:         jobs,
153:     ] = await Promise.all([
154:         countLeadsByStatuses(['NEW']),
155:         countLeadsByStatuses(['READY_INVITE', 'PENDING']),
156:         countLeadsByStatuses(['INVITED']),
157:         countLeadsByStatuses(['ACCEPTED']),
158:         countLeadsByStatuses(['READY_MESSAGE']),
159:         countLeadsByStatuses(['MESSAGED']),
160:         countLeadsByStatuses(['BLOCKED']),
161:         countLeadsByStatuses(['SKIPPED']),
162:         countPendingOutboxEvents(),
163:         countCompanyTargets(),
164:         countCompanyTargetsByStatuses(['NEW']),
165:         countCompanyTargetsByStatuses(['ENRICHED']),
166:         countCompanyTargetsByStatuses(['NO_MATCH']),
167:         countCompanyTargetsByStatuses(['ERROR']),
168:         getJobStatusCounts(),
169:     ]);
170: 
171:     const totalLeads = newCount + readyInviteCount + invitedCount + acceptedCount + readyMessageCount + messagedCount + blockedCount + skippedCount;
172:     const queuedJobs = Object.values(jobs).reduce((acc, value) => acc + value, 0);
173: 
174:     return {
175:         totals: {
176:             leads: totalLeads,
177:             companyTargets,
178:             queuedJobs,
179:             pendingOutbox,
180:         },
181:         connections: {
182:             toSend: newCount + readyInviteCount,
183:             invitedPendingAcceptance: invitedCount,
184:             acceptedReadyMessage: acceptedCount + readyMessageCount,
185:             completed: messagedCount,
186:         },
187:         messages: {
188:             toSend: readyMessageCount,
189:             sent: messagedCount,
190:             blockedOrSkipped: blockedCount + skippedCount,
191:         },
192:         companyTargetStatuses: {
193:             NEW: companyTargetsNew,
194:             ENRICHED: companyTargetsEnriched,
195:             NO_MATCH: companyTargetsNoMatch,
196:             ERROR: companyTargetsError,
197:         },
198:         leadStatuses: {
199:             NEW: newCount,
200:             READY_INVITE: readyInviteCount,
201:             INVITED: invitedCount,
202:             ACCEPTED: acceptedCount,
203:             READY_MESSAGE: readyMessageCount,
204:             MESSAGED: messagedCount,
205:             BLOCKED: blockedCount,
206:             SKIPPED: skippedCount,
207:         },
208:         jobs,
209:     };
210: }
211: 
212: export async function runSiteCheck(options: SiteCheckOptions): Promise<SiteCheckReport> {
213:     const limit = Math.max(1, options.limitPerStatus);
214:     const [readyInviteLeads, invitedLeads, readyMessageLeads, messagedLeads] = await Promise.all([
215:         getLeadsByStatus('READY_INVITE', limit),
216:         getLeadsByStatus('INVITED', limit),
217:         getLeadsByStatus('READY_MESSAGE', limit),
218:         getLeadsByStatus('MESSAGED', Math.max(5, Math.floor(limit / 2))),
219:     ]);
220: 
221:     const candidates = [...readyInviteLeads, ...invitedLeads, ...readyMessageLeads, ...messagedLeads];
222:     if (candidates.length === 0) {
223:         return {
224:             scanned: 0,
225:             mismatches: 0,
226:             fixed: 0,
227:             items: [],
228:         };
229:     }
230: 
231:     const report: SiteCheckReport = {
232:         scanned: 0,
233:         mismatches: 0,
234:         fixed: 0,
235:         items: [],
236:     };
237: 
238:     const session = await launchBrowser();
239:     try {
240:         const loggedIn = await checkLogin(session.page);
241:         if (!loggedIn) {
242:             await quarantineAccount('SITE_CHECK_LOGIN_MISSING', {
243:                 reason: 'Sessione non autenticata durante site-check',
244:             });
245:             return report;
246:         }
247: 
248:         for (const lead of candidates) {
249:             report.scanned += 1;
250:             const signals = await inspectLeadOnSite(lead, session.page);
251: 
252:             if (await detectChallenge(session.page)) {
253:                 await quarantineAccount('SITE_CHECK_CHALLENGE_DETECTED', {
254:                     leadId: lead.id,
255:                     status: lead.status,
256:                     linkedinUrl: lead.linkedin_url,
257:                 });
258:                 break;
259:             }
260: 
261:             let mismatch: string | null = null;
262:             if (lead.status === 'INVITED' && signals.connected) {
263:                 mismatch = 'invited_but_connected';
264:             } else if (lead.status === 'INVITED' && !signals.pendingInvite && signals.canConnect) {
265:                 mismatch = 'invited_but_connect_available';
266:             } else if (lead.status === 'READY_INVITE' && signals.pendingInvite) {
267:                 mismatch = 'ready_invite_but_pending';
268:             } else if (lead.status === 'READY_INVITE' && signals.connected) {
269:                 mismatch = 'ready_invite_but_connected';
270:             } else if (lead.status === 'READY_MESSAGE' && signals.pendingInvite) {
271:                 mismatch = 'ready_message_but_pending_invite';
272:             } else if (lead.status === 'READY_MESSAGE' && !signals.connected) {
273:                 mismatch = 'ready_message_but_not_connected';
274:             } else if (lead.status === 'MESSAGED' && signals.pendingInvite) {
275:                 mismatch = 'messaged_but_pending_invite';
276:             } else if (lead.status === 'MESSAGED' && !signals.connected) {
277:                 mismatch = 'messaged_but_not_connected';
278:             }
279: 
280:             if (!mismatch) {
281:                 continue;
282:             }
283: 
284:             report.mismatches += 1;
285:             let fixed = false;
286:             if (options.autoFix) {
287:                 fixed = await tryAutoFix(lead, mismatch);
288:                 if (fixed) {
289:                     report.fixed += 1;
290:                 }
291:             }
292: 
293:             report.items.push({
294:                 leadId: lead.id,
295:                 status: lead.status,
296:                 linkedinUrl: lead.linkedin_url,
297:                 siteSignals: signals,
298:                 mismatch,
299:                 fixed,
300:             });
301:         }
302:     } finally {
303:         await closeBrowser(session);
304:     }
305: 
306:     return report;
307: }
````

## File: src/core/companyEnrichment.ts
````typescript
  1: import { checkLogin, closeBrowser, detectChallenge, humanDelay, launchBrowser } from '../browser';
  2: import { config } from '../config';
  3: import { quarantineAccount } from '../risk/incidentManager';
  4: import { logInfo, logWarn } from '../telemetry/logger';
  5: import {
  6:     addLead,
  7:     CompanyTargetRecord,
  8:     getCompanyTargetsForEnrichment,
  9:     setCompanyTargetStatus,
 10: } from './repositories';
 11: 
 12: export interface CompanyEnrichmentOptions {
 13:     limit?: number;
 14:     maxProfilesPerCompany?: number;
 15:     dryRun?: boolean;
 16: }
 17: 
 18: export interface CompanyEnrichmentReport {
 19:     scanned: number;
 20:     matched: number;
 21:     createdLeads: number;
 22:     noMatch: number;
 23:     errors: number;
 24:     dryRun: boolean;
 25: }
 26: 
 27: function normalizeProfileUrl(raw: string): string | null {
 28:     try {
 29:         const parsed = new URL(raw);
 30:         if (!parsed.hostname.toLowerCase().includes('linkedin.com')) return null;
 31:         const path = parsed.pathname.replace(/\/+$/, '');
 32:         if (!path.startsWith('/in/')) return null;
 33:         return `https://www.linkedin.com${path}/`;
 34:     } catch {
 35:         return null;
 36:     }
 37: }
 38: 
 39: function toTitleCase(input: string): string {
 40:     if (!input) return '';
 41:     return input.charAt(0).toUpperCase() + input.slice(1).toLowerCase();
 42: }
 43: 
 44: function parseNamesFromProfileUrl(profileUrl: string): { firstName: string; lastName: string } {
 45:     try {
 46:         const parsed = new URL(profileUrl);
 47:         const slug = parsed.pathname.replace('/in/', '').replace(/\/+$/, '');
 48:         const clean = slug.replace(/[-_]/g, ' ').replace(/\d+/g, ' ').replace(/\s+/g, ' ').trim();
 49:         if (!clean) return { firstName: '', lastName: '' };
 50: 
 51:         const parts = clean.split(' ').filter((part) => /^[A-Za-zÀ-ÿ]{2,}$/.test(part));
 52:         if (parts.length === 0) return { firstName: '', lastName: '' };
 53:         if (parts.length === 1) return { firstName: toTitleCase(parts[0]), lastName: '' };
 54: 
 55:         return {
 56:             firstName: toTitleCase(parts[0]),
 57:             lastName: parts.slice(1).map(toTitleCase).join(' '),
 58:         };
 59:     } catch {
 60:         return { firstName: '', lastName: '' };
 61:     }
 62: }
 63: 
 64: function extractDomain(website: string): string {
 65:     const raw = (website ?? '').trim();
 66:     if (!raw) return '';
 67:     try {
 68:         const parsed = raw.startsWith('http://') || raw.startsWith('https://')
 69:             ? new URL(raw)
 70:             : new URL(`https://${raw}`);
 71:         return parsed.hostname.replace(/^www\./i, '');
 72:     } catch {
 73:         return raw.replace(/^https?:\/\//i, '').replace(/^www\./i, '').split('/')[0];
 74:     }
 75: }
 76: 
 77: function buildSearchQuery(target: CompanyTargetRecord): string {
 78:     const company = (target.account_name ?? '').trim();
 79:     const domain = extractDomain(target.website);
 80:     const terms = [company, domain].filter((v) => v.length > 0);
 81:     return terms.join(' ').trim();
 82: }
 83: 
 84: function buildSearchQueries(target: CompanyTargetRecord): string[] {
 85:     const company = (target.account_name ?? '').trim();
 86:     const domain = extractDomain(target.website);
 87:     const candidates = [
 88:         buildSearchQuery(target),
 89:         company,
 90:         domain,
 91:     ].filter((value) => value.length > 0);
 92: 
 93:     const unique = new Set<string>();
 94:     for (const value of candidates) {
 95:         unique.add(value);
 96:     }
 97:     return Array.from(unique);
 98: }
 99: 
100: async function extractProfileUrls(page: Parameters<typeof detectChallenge>[0], maxProfiles: number): Promise<string[]> {
101:     const rawUrls = await page.$$eval('a[href*="/in/"]', (anchors) =>
102:         anchors.map((anchor) => (anchor as HTMLAnchorElement).href).filter((href) => !!href)
103:     );
104: 
105:     const unique = new Set<string>();
106:     for (const rawUrl of rawUrls) {
107:         const normalized = normalizeProfileUrl(rawUrl);
108:         if (!normalized) continue;
109:         unique.add(normalized);
110:         if (unique.size >= maxProfiles) break;
111:     }
112: 
113:     return Array.from(unique);
114: }
115: 
116: async function processCompanyTarget(
117:     target: CompanyTargetRecord,
118:     options: Required<CompanyEnrichmentOptions>,
119:     page: Parameters<typeof checkLogin>[0]
120: ): Promise<{ matched: boolean; createdLeads: number; noMatch: boolean; error: string | null }> {
121:     const queries = buildSearchQueries(target);
122:     if (queries.length === 0) {
123:         return { matched: false, createdLeads: 0, noMatch: true, error: null };
124:     }
125: 
126:     let profileUrls: string[] = [];
127:     for (const query of queries) {
128:         const searchUrl = `https://www.linkedin.com/search/results/people/?keywords=${encodeURIComponent(query)}`;
129:         await page.goto(searchUrl, { waitUntil: 'domcontentloaded' });
130:         await humanDelay(page, 1700, 3000);
131: 
132:         if (await detectChallenge(page)) {
133:             await quarantineAccount('COMPANY_ENRICHMENT_CHALLENGE', {
134:                 targetId: target.id,
135:                 listName: target.list_name,
136:                 accountName: target.account_name,
137:             });
138:             throw new Error('Challenge rilevato durante enrichment');
139:         }
140: 
141:         profileUrls = await extractProfileUrls(page, options.maxProfilesPerCompany);
142:         if (profileUrls.length > 0) {
143:             break;
144:         }
145:     }
146:     if (profileUrls.length === 0) {
147:         return { matched: false, createdLeads: 0, noMatch: true, error: null };
148:     }
149: 
150:     let createdLeads = 0;
151:     if (!options.dryRun) {
152:         for (const profileUrl of profileUrls) {
153:             const names = parseNamesFromProfileUrl(profileUrl);
154:             const inserted = await addLead({
155:                 accountName: target.account_name,
156:                 firstName: names.firstName,
157:                 lastName: names.lastName,
158:                 jobTitle: '',
159:                 website: target.website,
160:                 linkedinUrl: profileUrl,
161:                 listName: target.list_name,
162:             });
163:             if (inserted) {
164:                 createdLeads += 1;
165:             }
166:         }
167:     } else {
168:         createdLeads = profileUrls.length;
169:     }
170: 
171:     return { matched: true, createdLeads, noMatch: false, error: null };
172: }
173: 
174: export async function runCompanyEnrichmentBatch(options: CompanyEnrichmentOptions = {}): Promise<CompanyEnrichmentReport> {
175:     const resolved: Required<CompanyEnrichmentOptions> = {
176:         limit: Math.max(1, options.limit ?? config.companyEnrichmentBatch),
177:         maxProfilesPerCompany: Math.max(1, options.maxProfilesPerCompany ?? config.companyEnrichmentMaxProfilesPerCompany),
178:         dryRun: options.dryRun ?? false,
179:     };
180: 
181:     const targets = await getCompanyTargetsForEnrichment(resolved.limit);
182:     const report: CompanyEnrichmentReport = {
183:         scanned: 0,
184:         matched: 0,
185:         createdLeads: 0,
186:         noMatch: 0,
187:         errors: 0,
188:         dryRun: resolved.dryRun,
189:     };
190: 
191:     if (targets.length === 0) {
192:         return report;
193:     }
194: 
195:     const session = await launchBrowser();
196:     try {
197:         const loggedIn = await checkLogin(session.page);
198:         if (!loggedIn) {
199:             await quarantineAccount('COMPANY_ENRICHMENT_LOGIN_MISSING', {
200:                 reason: 'Sessione non autenticata durante enrichment automatico',
201:             });
202:             await logWarn('company_enrichment.skipped.login_missing', { targets: targets.length });
203:             return report;
204:         }
205: 
206:         for (const target of targets) {
207:             report.scanned += 1;
208:             try {
209:                 const result = await processCompanyTarget(target, resolved, session.page);
210:                 if (result.matched) {
211:                     report.matched += 1;
212:                     report.createdLeads += result.createdLeads;
213:                     if (!resolved.dryRun) {
214:                         await setCompanyTargetStatus(target.id, 'ENRICHED', null);
215:                     }
216:                 } else if (result.noMatch) {
217:                     report.noMatch += 1;
218:                     if (!resolved.dryRun) {
219:                         await setCompanyTargetStatus(target.id, 'NO_MATCH', null);
220:                     }
221:                 }
222:             } catch (error) {
223:                 const message = error instanceof Error ? error.message : String(error);
224:                 report.errors += 1;
225:                 if (!resolved.dryRun) {
226:                     await setCompanyTargetStatus(target.id, 'ERROR', message);
227:                 }
228:                 await logWarn('company_enrichment.target_failed', {
229:                     targetId: target.id,
230:                     listName: target.list_name,
231:                     accountName: target.account_name,
232:                     error: message,
233:                 });
234:                 if (/challenge/i.test(message)) {
235:                     break;
236:                 }
237:             }
238:         }
239:     } finally {
240:         await closeBrowser(session);
241:     }
242: 
243:     await logInfo('company_enrichment.batch', {
244:         scanned: report.scanned,
245:         matched: report.matched,
246:         createdLeads: report.createdLeads,
247:         noMatch: report.noMatch,
248:         errors: report.errors,
249:         dryRun: report.dryRun,
250:     });
251:     return report;
252: }
````

## File: src/core/doctor.ts
````typescript
 1: import { config, isWorkingHour } from '../config';
 2: import { checkLogin, closeBrowser, launchBrowser } from '../browser';
 3: import { getEventSyncStatus } from '../sync/eventSync';
 4: import { getRuntimeFlag, listOpenIncidents } from './repositories';
 5: 
 6: export interface DoctorReport {
 7:     dbPath: string;
 8:     workingHoursOk: boolean;
 9:     sessionLoginOk: boolean;
10:     quarantine: boolean;
11:     sync: {
12:         activeSink: 'SUPABASE' | 'WEBHOOK' | 'NONE';
13:         enabled: boolean;
14:         configured: boolean;
15:         pendingOutbox: number;
16:         warning: string | null;
17:     };
18:     openIncidents: number;
19: }
20: 
21: export async function runDoctor(): Promise<DoctorReport> {
22:     const quarantine = (await getRuntimeFlag('account_quarantine')) === 'true';
23:     const sync = await getEventSyncStatus();
24:     const incidents = await listOpenIncidents();
25: 
26:     let sessionLoginOk = false;
27:     const session = await launchBrowser();
28:     try {
29:         sessionLoginOk = await checkLogin(session.page);
30:     } finally {
31:         await closeBrowser(session);
32:     }
33: 
34:     return {
35:         dbPath: config.dbPath,
36:         workingHoursOk: isWorkingHour(),
37:         sessionLoginOk,
38:         quarantine,
39:         sync: {
40:             activeSink: sync.activeSink,
41:             enabled: sync.enabled,
42:             configured: sync.configured,
43:             pendingOutbox: sync.pendingOutbox,
44:             warning: sync.warning,
45:         },
46:         openIncidents: incidents.length,
47:     };
48: }
````

## File: src/core/jobRunner.ts
````typescript
  1: import { closeBrowser, interJobDelay, launchBrowser, checkLogin } from '../browser';
  2: import { config } from '../config';
  3: import { pauseAutomation, quarantineAccount } from '../risk/incidentManager';
  4: import { logError, logInfo, logWarn } from '../telemetry/logger';
  5: import { JobType } from '../types/domain';
  6: import { WorkerContext } from '../workers/context';
  7: import { processAcceptanceJob } from '../workers/acceptanceWorker';
  8: import { processInviteJob } from '../workers/inviteWorker';
  9: import { processMessageJob } from '../workers/messageWorker';
 10: import { ChallengeDetectedError } from '../workers/errors';
 11: import {
 12:     createJobAttempt,
 13:     getRuntimeFlag,
 14:     incrementDailyStat,
 15:     lockNextQueuedJob,
 16:     markJobRetryOrDeadLetter,
 17:     markJobSucceeded,
 18:     parseJobPayload,
 19:     pushOutboxEvent,
 20: } from './repositories';
 21: 
 22: export interface RunJobsOptions {
 23:     localDate: string;
 24:     allowedTypes: JobType[];
 25:     dryRun: boolean;
 26: }
 27: 
 28: function retryDelayMs(attempt: number): number {
 29:     const jitter = Math.floor(Math.random() * 250);
 30:     return config.retryBaseMs * Math.pow(2, Math.max(0, attempt - 1)) + jitter;
 31: }
 32: 
 33: export async function runQueuedJobs(options: RunJobsOptions): Promise<void> {
 34:     const quarantineFlag = await getRuntimeFlag('account_quarantine');
 35:     if (quarantineFlag === 'true') {
 36:         await logWarn('job_runner.skipped_quarantine', { reason: 'account_quarantine=true' });
 37:         return;
 38:     }
 39: 
 40:     const session = await launchBrowser();
 41:     try {
 42:         const loggedIn = await checkLogin(session.page);
 43:         if (!loggedIn) {
 44:             await quarantineAccount('LOGIN_MISSING', { message: 'Sessione non autenticata su LinkedIn' });
 45:             return;
 46:         }
 47: 
 48:         const workerContext: WorkerContext = {
 49:             session,
 50:             dryRun: options.dryRun,
 51:             localDate: options.localDate,
 52:         };
 53:         let consecutiveFailures = 0;
 54: 
 55:         while (true) {
 56:             const job = await lockNextQueuedJob(options.allowedTypes);
 57:             if (!job) break;
 58: 
 59:             await logInfo('job.started', {
 60:                 jobId: job.id,
 61:                 type: job.type,
 62:                 attempt: job.attempts + 1,
 63:             });
 64: 
 65:             try {
 66:                 if (job.type === 'INVITE') {
 67:                     const parsed = parseJobPayload<{ leadId: number; localDate: string }>(job);
 68:                     await processInviteJob(parsed.payload, workerContext);
 69:                 } else if (job.type === 'ACCEPTANCE_CHECK') {
 70:                     const parsed = parseJobPayload<{ leadId: number }>(job);
 71:                     await processAcceptanceJob(parsed.payload, workerContext);
 72:                 } else if (job.type === 'MESSAGE') {
 73:                     const parsed = parseJobPayload<{ leadId: number; acceptedAtDate: string }>(job);
 74:                     await processMessageJob(parsed.payload, workerContext);
 75:                 }
 76: 
 77:                 await markJobSucceeded(job.id);
 78:                 await createJobAttempt(job.id, true, null, null, null);
 79:                 await pushOutboxEvent(
 80:                     'job.succeeded',
 81:                     { jobId: job.id, type: job.type, dryRun: options.dryRun },
 82:                     `job.succeeded:${job.id}:${job.type}`
 83:                 );
 84:                 consecutiveFailures = 0;
 85: 
 86:                 // Pausa umana tra un job e il successivo (anti-burst)
 87:                 await interJobDelay(session.page);
 88:             } catch (error) {
 89:                 const message = error instanceof Error ? error.message : String(error);
 90:                 const attempts = job.attempts + 1;
 91: 
 92:                 await createJobAttempt(job.id, false, error instanceof Error ? error.name : 'UNKNOWN_ERROR', message, null);
 93:                 await incrementDailyStat(options.localDate, 'run_errors');
 94: 
 95:                 if (error instanceof ChallengeDetectedError) {
 96:                     await incrementDailyStat(options.localDate, 'challenges_count');
 97:                     await quarantineAccount('CHALLENGE_DETECTED', {
 98:                         jobId: job.id,
 99:                         jobType: job.type,
100:                         message,
101:                     });
102:                     await markJobRetryOrDeadLetter(job.id, attempts, attempts, 0, message);
103:                     await logError('job.challenge_detected', { jobId: job.id, type: job.type, message });
104:                     break;
105:                 }
106: 
107:                 const nextDelay = retryDelayMs(attempts);
108:                 const status = await markJobRetryOrDeadLetter(job.id, attempts, job.max_attempts, nextDelay, message);
109:                 await pushOutboxEvent(
110:                     'job.failed',
111:                     {
112:                         jobId: job.id,
113:                         type: job.type,
114:                         attempts,
115:                         status,
116:                         error: message,
117:                     },
118:                     `job.failed:${job.id}:${attempts}`
119:                 );
120: 
121:                 await logWarn('job.failed', {
122:                     jobId: job.id,
123:                     type: job.type,
124:                     status,
125:                     attempts,
126:                     message,
127:                 });
128: 
129:                 consecutiveFailures += 1;
130:                 if (consecutiveFailures >= config.maxConsecutiveJobFailures) {
131:                     await pauseAutomation(
132:                         'CONSECUTIVE_JOB_FAILURES',
133:                         {
134:                             threshold: config.maxConsecutiveJobFailures,
135:                             consecutiveFailures,
136:                             lastJobId: job.id,
137:                             lastJobType: job.type,
138:                             lastError: message,
139:                         },
140:                         config.autoPauseMinutesOnFailureBurst
141:                     );
142:                     await logWarn('job_runner.paused.failure_burst', {
143:                         threshold: config.maxConsecutiveJobFailures,
144:                         consecutiveFailures,
145:                         pauseMinutes: config.autoPauseMinutesOnFailureBurst,
146:                     });
147:                     break;
148:                 }
149:             }
150:         }
151:     } finally {
152:         await closeBrowser(session);
153:     }
154: }
````

## File: src/core/leadStateService.ts
````typescript
 1: import { appendLeadEvent, getLeadById, pushOutboxEvent, setLeadStatus } from './repositories';
 2: import { LeadStatus } from '../types/domain';
 3: 
 4: const allowedTransitions: Record<Exclude<LeadStatus, 'PENDING'>, LeadStatus[]> = {
 5:     NEW: ['READY_INVITE', 'BLOCKED'],
 6:     READY_INVITE: ['INVITED', 'SKIPPED', 'BLOCKED'],
 7:     INVITED: ['ACCEPTED', 'BLOCKED'],
 8:     ACCEPTED: ['READY_MESSAGE', 'BLOCKED'],
 9:     READY_MESSAGE: ['MESSAGED', 'BLOCKED'],
10:     MESSAGED: [],
11:     SKIPPED: [],
12:     BLOCKED: [],
13: };
14: 
15: function normalize(status: LeadStatus): Exclude<LeadStatus, 'PENDING'> {
16:     if (status === 'PENDING') {
17:         return 'READY_INVITE';
18:     }
19:     return status;
20: }
21: 
22: export function isValidLeadTransition(fromStatus: LeadStatus, toStatus: LeadStatus): boolean {
23:     const normalizedFrom = normalize(fromStatus);
24:     const normalizedTo = normalize(toStatus);
25:     const nextAllowed = allowedTransitions[normalizedFrom];
26:     return nextAllowed.includes(normalizedTo);
27: }
28: 
29: export async function transitionLead(
30:     leadId: number,
31:     toStatus: LeadStatus,
32:     reason: string,
33:     metadata: Record<string, unknown> = {}
34: ): Promise<void> {
35:     const lead = await getLeadById(leadId);
36:     if (!lead) {
37:         throw new Error(`Lead ${leadId} non trovato.`);
38:     }
39: 
40:     const fromStatus = normalize(lead.status);
41:     const targetStatus = normalize(toStatus);
42:     if (!isValidLeadTransition(fromStatus, targetStatus)) {
43:         throw new Error(`Transizione non consentita: ${fromStatus} -> ${targetStatus}.`);
44:     }
45: 
46:     const blockedReason = targetStatus === 'BLOCKED' ? reason : undefined;
47:     await setLeadStatus(leadId, targetStatus, undefined, blockedReason);
48:     await appendLeadEvent(leadId, fromStatus, targetStatus, reason, metadata);
49:     await pushOutboxEvent(
50:         'lead.transition',
51:         {
52:             leadId,
53:             fromStatus,
54:             toStatus: targetStatus,
55:             reason,
56:             metadata,
57:         },
58:         `lead.transition:${leadId}:${fromStatus}:${targetStatus}:${reason}`
59:     );
60: }
61: 
62: export async function reconcileLeadStatus(
63:     leadId: number,
64:     toStatus: LeadStatus,
65:     reason: string,
66:     metadata: Record<string, unknown> = {}
67: ): Promise<void> {
68:     const lead = await getLeadById(leadId);
69:     if (!lead) {
70:         throw new Error(`Lead ${leadId} non trovato.`);
71:     }
72: 
73:     const fromStatus = normalize(lead.status);
74:     const targetStatus = normalize(toStatus);
75:     if (fromStatus === targetStatus) {
76:         return;
77:     }
78: 
79:     await setLeadStatus(leadId, targetStatus);
80:     await appendLeadEvent(leadId, fromStatus, targetStatus, reason, {
81:         ...metadata,
82:         reconcile: true,
83:     });
84:     await pushOutboxEvent(
85:         'lead.reconciled',
86:         {
87:             leadId,
88:             fromStatus,
89:             toStatus: targetStatus,
90:             reason,
91:             metadata,
92:         },
93:         `lead.reconciled:${leadId}:${fromStatus}:${targetStatus}:${reason}`
94:     );
95: }
````

## File: src/core/orchestrator.ts
````typescript
  1: import { checkLogin, closeBrowser, launchBrowser, runSelectorCanary } from '../browser';
  2: import { config, getLocalDateString, isWorkingHour } from '../config';
  3: import { pauseAutomation, quarantineAccount } from '../risk/incidentManager';
  4: import { evaluateCooldownDecision } from '../risk/riskEngine';
  5: import { logInfo, logWarn } from '../telemetry/logger';
  6: import { runEventSyncOnce } from '../sync/eventSync';
  7: import { workflowToJobTypes, scheduleJobs, WorkflowSelection } from './scheduler';
  8: import { runSiteCheck } from './audit';
  9: 
 10: import { runQueuedJobs } from './jobRunner';
 11: import { getAutomationPauseState, getDailyStat, getRuntimeFlag, pushOutboxEvent } from './repositories';
 12: import { evaluateAiGuardian } from '../ai/guardian';
 13: 
 14: export interface RunWorkflowOptions {
 15:     workflow: WorkflowSelection;
 16:     dryRun: boolean;
 17: }
 18: 
 19: async function runCanaryIfNeeded(workflow: WorkflowSelection): Promise<boolean> {
 20:     const touchesUi = workflow === 'all' || workflow === 'invite' || workflow === 'message' || workflow === 'check';
 21:     if (!config.selectorCanaryEnabled || !touchesUi) {
 22:         return true;
 23:     }
 24: 
 25:     const session = await launchBrowser();
 26:     try {
 27:         const loggedIn = await checkLogin(session.page);
 28:         if (!loggedIn) {
 29:             return false;
 30:         }
 31:         return runSelectorCanary(session.page);
 32:     } finally {
 33:         await closeBrowser(session);
 34:     }
 35: }
 36: 
 37: export async function runWorkflow(options: RunWorkflowOptions): Promise<void> {
 38:     if (!options.dryRun) {
 39:         const quarantine = (await getRuntimeFlag('account_quarantine')) === 'true';
 40:         if (quarantine) {
 41:             await logWarn('workflow.skipped.quarantine', { workflow: options.workflow });
 42:             return;
 43:         }
 44: 
 45:         const pauseState = await getAutomationPauseState();
 46:         if (pauseState.paused) {
 47:             await logWarn('workflow.skipped.paused', {
 48:                 workflow: options.workflow,
 49:                 reason: pauseState.reason,
 50:                 pausedUntil: pauseState.pausedUntil,
 51:                 remainingSeconds: pauseState.remainingSeconds,
 52:             });
 53:             return;
 54:         }
 55:     }
 56: 
 57:     if (!options.dryRun && !isWorkingHour()) {
 58:         await logInfo('workflow.skipped.out_of_hours', {
 59:             startHour: config.workingHoursStart,
 60:             endHour: config.workingHoursEnd,
 61:         });
 62:         return;
 63:     }
 64: 
 65:     if (!options.dryRun) {
 66:         const localDate = getLocalDateString();
 67:         const selectorFailures = await getDailyStat(localDate, 'selector_failures');
 68:         if (selectorFailures >= config.maxSelectorFailuresPerDay) {
 69:             await quarantineAccount('SELECTOR_FAILURE_BURST', {
 70:                 workflow: options.workflow,
 71:                 localDate,
 72:                 selectorFailures,
 73:                 threshold: config.maxSelectorFailuresPerDay,
 74:             });
 75:             return;
 76:         }
 77: 
 78:         const runErrors = await getDailyStat(localDate, 'run_errors');
 79:         if (runErrors >= config.maxRunErrorsPerDay) {
 80:             await pauseAutomation(
 81:                 'RUN_ERRORS_BURST',
 82:                 {
 83:                     workflow: options.workflow,
 84:                     localDate,
 85:                     runErrors,
 86:                     threshold: config.maxRunErrorsPerDay,
 87:                 },
 88:                 config.autoPauseMinutesOnFailureBurst
 89:             );
 90:             await logWarn('workflow.skipped.run_error_burst', {
 91:                 workflow: options.workflow,
 92:                 localDate,
 93:                 runErrors,
 94:                 threshold: config.maxRunErrorsPerDay,
 95:                 pauseMinutes: config.autoPauseMinutesOnFailureBurst,
 96:             });
 97:             return;
 98:         }
 99: 
100:         const canaryOk = await runCanaryIfNeeded(options.workflow);
101:         if (!canaryOk) {
102:             await quarantineAccount('SELECTOR_CANARY_FAILED', { workflow: options.workflow });
103:             return;
104:         }
105:     }
106: 
107:     const schedule = await scheduleJobs(options.workflow, { dryRun: options.dryRun });
108: 
109:     if (options.dryRun) {
110:         console.log('[DRY_RUN] workflow.preview', {
111:             workflow: options.workflow,
112:             localDate: schedule.localDate,
113:             risk: schedule.riskSnapshot,
114:             queuedInviteJobs: schedule.queuedInviteJobs,
115:             queuedCheckJobs: schedule.queuedCheckJobs,
116:             queuedMessageJobs: schedule.queuedMessageJobs,
117:             inviteBudget: schedule.inviteBudget,
118:             messageBudget: schedule.messageBudget,
119:             listBreakdown: schedule.listBreakdown,
120:         });
121:         return;
122:     }
123: 
124:     await pushOutboxEvent(
125:         'scheduler.snapshot',
126:         {
127:             workflow: options.workflow,
128:             localDate: schedule.localDate,
129:             risk: schedule.riskSnapshot,
130:             queuedInviteJobs: schedule.queuedInviteJobs,
131:             queuedCheckJobs: schedule.queuedCheckJobs,
132:             queuedMessageJobs: schedule.queuedMessageJobs,
133:             inviteBudget: schedule.inviteBudget,
134:             messageBudget: schedule.messageBudget,
135:             listBreakdown: schedule.listBreakdown,
136:         },
137:         `scheduler.snapshot:${schedule.localDate}:${options.workflow}`
138:     );
139: 
140:     if (schedule.riskSnapshot.action === 'STOP') {
141:         await quarantineAccount('RISK_STOP_THRESHOLD', {
142:             workflow: options.workflow,
143:             riskSnapshot: schedule.riskSnapshot,
144:         });
145:         return;
146:     }
147: 
148:     const guardian = await evaluateAiGuardian(options.workflow, schedule);
149:     if (guardian.decision) {
150:         await pushOutboxEvent(
151:             'ai.guardian.decision',
152:             {
153:                 workflow: options.workflow,
154:                 localDate: schedule.localDate,
155:                 executed: guardian.executed,
156:                 reason: guardian.reason,
157:                 decision: guardian.decision,
158:             },
159:             `ai.guardian.decision:${schedule.localDate}:${options.workflow}:${Date.now()}`
160:         );
161:         if (guardian.decision.severity === 'critical' && guardian.decision.pauseMinutes > 0) {
162:             await pauseAutomation(
163:                 'AI_GUARDIAN_PREEMPTIVE',
164:                 {
165:                     workflow: options.workflow,
166:                     localDate: schedule.localDate,
167:                     reason: guardian.reason,
168:                     decision: guardian.decision,
169:                 },
170:                 guardian.decision.pauseMinutes
171:             );
172:             await logWarn('ai.guardian.preemptive_pause', {
173:                 workflow: options.workflow,
174:                 localDate: schedule.localDate,
175:                 reason: guardian.reason,
176:                 pauseMinutes: guardian.decision.pauseMinutes,
177:                 summary: guardian.decision.summary,
178:             });
179:             return;
180:         }
181:         if (guardian.decision.severity === 'watch') {
182:             await logWarn('ai.guardian.watch', {
183:                 workflow: options.workflow,
184:                 localDate: schedule.localDate,
185:                 reason: guardian.reason,
186:                 summary: guardian.decision.summary,
187:                 recommendations: guardian.decision.recommendations,
188:             });
189:         } else {
190:             await logInfo('ai.guardian.normal', {
191:                 workflow: options.workflow,
192:                 localDate: schedule.localDate,
193:                 reason: guardian.reason,
194:                 summary: guardian.decision.summary,
195:             });
196:         }
197:     }
198: 
199:     const cooldown = evaluateCooldownDecision(schedule.riskSnapshot);
200:     if (cooldown.activate) {
201:         await pauseAutomation(
202:             'RISK_COOLDOWN',
203:             {
204:                 workflow: options.workflow,
205:                 localDate: schedule.localDate,
206:                 riskSnapshot: schedule.riskSnapshot,
207:                 tier: cooldown.tier,
208:                 reason: cooldown.reason,
209:                 listBreakdown: schedule.listBreakdown,
210:             },
211:             cooldown.minutes
212:         );
213:         await logWarn('risk.cooldown.activated', {
214:             workflow: options.workflow,
215:             localDate: schedule.localDate,
216:             tier: cooldown.tier,
217:             reason: cooldown.reason,
218:             pauseMinutes: cooldown.minutes,
219:             score: schedule.riskSnapshot.score,
220:             pendingRatio: schedule.riskSnapshot.pendingRatio,
221:         });
222:         return;
223:     }
224: 
225:     if (schedule.riskSnapshot.action === 'WARN') {
226:         await logWarn('risk.warn', {
227:             workflow: options.workflow,
228:             score: schedule.riskSnapshot.score,
229:             pendingRatio: schedule.riskSnapshot.pendingRatio,
230:         });
231:     }
232: 
233:     await runQueuedJobs({
234:         localDate: schedule.localDate,
235:         allowedTypes: workflowToJobTypes(options.workflow),
236:         dryRun: options.dryRun,
237:     });
238: 
239:     if (config.postRunStateSyncEnabled) {
240:         const stateSyncReport = await runSiteCheck({
241:             limitPerStatus: config.postRunStateSyncLimit,
242:             autoFix: config.postRunStateSyncFix,
243:         });
244:         await logInfo('state.sync.post_run', {
245:             workflow: options.workflow,
246:             localDate: schedule.localDate,
247:             limitPerStatus: config.postRunStateSyncLimit,
248:             autoFix: config.postRunStateSyncFix,
249:             report: stateSyncReport,
250:         });
251:         await pushOutboxEvent(
252:             'state.sync.post_run',
253:             {
254:                 workflow: options.workflow,
255:                 localDate: schedule.localDate,
256:                 limitPerStatus: config.postRunStateSyncLimit,
257:                 autoFix: config.postRunStateSyncFix,
258:                 report: stateSyncReport,
259:             },
260:             `state.sync.post_run:${schedule.localDate}:${options.workflow}:${Date.now()}`
261:         );
262:     }
263: 
264:     await runEventSyncOnce();
265: }
````

## File: src/core/repositories.ts
````typescript
   1: import { Database } from 'sqlite';
   2: import { getDatabase } from '../db';
   3: import {
   4:     JobRecord,
   5:     JobStatus,
   6:     JobType,
   7:     LeadRecord,
   8:     LeadStatus,
   9:     OutboxEventRecord,
  10:     RiskInputs,
  11: } from '../types/domain';
  12: import { normalizeLinkedInUrl } from '../linkedinUrl';
  13: 
  14: function parsePayload<T>(raw: string): T {
  15:     try {
  16:         return JSON.parse(raw) as T;
  17:     } catch {
  18:         return {} as T;
  19:     }
  20: }
  21: 
  22: async function withTransaction<T>(database: Database, callback: () => Promise<T>): Promise<T> {
  23:     await database.exec('BEGIN IMMEDIATE');
  24:     try {
  25:         const result = await callback();
  26:         await database.exec('COMMIT');
  27:         return result;
  28:     } catch (error) {
  29:         await database.exec('ROLLBACK');
  30:         throw error;
  31:     }
  32: }
  33: 
  34: function normalizeLegacyStatus(status: LeadStatus): LeadStatus {
  35:     if (status === 'PENDING') {
  36:         return 'READY_INVITE';
  37:     }
  38:     return status;
  39: }
  40: 
  41: export async function ensureLeadList(listName: string): Promise<void> {
  42:     const db = await getDatabase();
  43:     await db.run(`INSERT OR IGNORE INTO lead_lists (name, source) VALUES (?, 'import')`, [listName]);
  44: }
  45: 
  46: export async function syncLeadListsFromLeads(): Promise<void> {
  47:     const db = await getDatabase();
  48:     await db.run(
  49:         `
  50:         INSERT OR IGNORE INTO lead_lists (name, source)
  51:         SELECT DISTINCT list_name, 'legacy'
  52:         FROM leads
  53:         WHERE TRIM(COALESCE(list_name, '')) <> ''
  54:     `
  55:     );
  56: }
  57: 
  58: export async function listLeadCampaignConfigs(onlyActive: boolean = false): Promise<LeadListCampaignConfig[]> {
  59:     const db = await getDatabase();
  60:     const rows = onlyActive
  61:         ? await db.all<LeadListRow[]>(
  62:             `
  63:             SELECT name, source, is_active, priority, daily_invite_cap, daily_message_cap, created_at
  64:             FROM lead_lists
  65:             WHERE is_active = 1
  66:             ORDER BY priority ASC, created_at ASC, name ASC
  67:         `
  68:         )
  69:         : await db.all<LeadListRow[]>(
  70:             `
  71:             SELECT name, source, is_active, priority, daily_invite_cap, daily_message_cap, created_at
  72:             FROM lead_lists
  73:             ORDER BY is_active DESC, priority ASC, created_at ASC, name ASC
  74:         `
  75:         );
  76: 
  77:     return rows.map(normalizeLeadListRow);
  78: }
  79: 
  80: export async function updateLeadCampaignConfig(listName: string, patch: UpdateLeadListCampaignInput): Promise<LeadListCampaignConfig> {
  81:     await ensureLeadList(listName);
  82: 
  83:     const setParts: string[] = [];
  84:     const params: unknown[] = [];
  85: 
  86:     if (Object.prototype.hasOwnProperty.call(patch, 'isActive')) {
  87:         setParts.push('is_active = ?');
  88:         params.push(patch.isActive ? 1 : 0);
  89:     }
  90:     if (Object.prototype.hasOwnProperty.call(patch, 'priority')) {
  91:         setParts.push('priority = ?');
  92:         params.push(Math.max(1, patch.priority ?? 100));
  93:     }
  94:     if (Object.prototype.hasOwnProperty.call(patch, 'dailyInviteCap')) {
  95:         setParts.push('daily_invite_cap = ?');
  96:         params.push(patch.dailyInviteCap === null ? null : Math.max(0, patch.dailyInviteCap ?? 0));
  97:     }
  98:     if (Object.prototype.hasOwnProperty.call(patch, 'dailyMessageCap')) {
  99:         setParts.push('daily_message_cap = ?');
 100:         params.push(patch.dailyMessageCap === null ? null : Math.max(0, patch.dailyMessageCap ?? 0));
 101:     }
 102: 
 103:     if (setParts.length > 0) {
 104:         const db = await getDatabase();
 105:         await db.run(
 106:             `
 107:             UPDATE lead_lists
 108:             SET ${setParts.join(', ')}
 109:             WHERE name = ?
 110:         `,
 111:             [...params, listName]
 112:         );
 113:     }
 114: 
 115:     const configs = await listLeadCampaignConfigs(false);
 116:     const updated = configs.find((config) => config.name === listName);
 117:     if (!updated) {
 118:         throw new Error(`Configurazione lista ${listName} non trovata dopo update.`);
 119:     }
 120:     return updated;
 121: }
 122: 
 123: export interface AddLeadInput {
 124:     accountName: string;
 125:     firstName: string;
 126:     lastName: string;
 127:     jobTitle: string;
 128:     website: string;
 129:     linkedinUrl: string;
 130:     listName: string;
 131: }
 132: 
 133: interface LeadListRow {
 134:     name: string;
 135:     source: string;
 136:     is_active: number;
 137:     priority: number;
 138:     daily_invite_cap: number | null;
 139:     daily_message_cap: number | null;
 140:     created_at: string;
 141: }
 142: 
 143: export interface LeadListCampaignConfig {
 144:     name: string;
 145:     source: string;
 146:     isActive: boolean;
 147:     priority: number;
 148:     dailyInviteCap: number | null;
 149:     dailyMessageCap: number | null;
 150:     createdAt: string;
 151: }
 152: 
 153: export interface UpdateLeadListCampaignInput {
 154:     isActive?: boolean;
 155:     priority?: number;
 156:     dailyInviteCap?: number | null;
 157:     dailyMessageCap?: number | null;
 158: }
 159: 
 160: export interface AddCompanyTargetInput {
 161:     listName: string;
 162:     accountName: string;
 163:     website: string;
 164:     sourceFile?: string | null;
 165: }
 166: 
 167: export type CompanyTargetStatus = 'NEW' | 'ENRICHED' | 'NO_MATCH' | 'ERROR';
 168: 
 169: export interface CompanyTargetRecord {
 170:     id: number;
 171:     list_name: string;
 172:     account_name: string;
 173:     website: string;
 174:     source_file: string | null;
 175:     status: CompanyTargetStatus;
 176:     attempts: number;
 177:     last_error: string | null;
 178:     processed_at: string | null;
 179:     created_at: string;
 180:     updated_at: string;
 181: }
 182: 
 183: export interface DailyStatsSnapshot {
 184:     date: string;
 185:     invitesSent: number;
 186:     messagesSent: number;
 187:     challengesCount: number;
 188:     selectorFailures: number;
 189:     runErrors: number;
 190: }
 191: 
 192: export interface JobStatusCounts {
 193:     QUEUED: number;
 194:     RUNNING: number;
 195:     SUCCEEDED: number;
 196:     FAILED: number;
 197:     DEAD_LETTER: number;
 198:     PAUSED: number;
 199: }
 200: 
 201: export interface AutomationPauseState {
 202:     paused: boolean;
 203:     pausedUntil: string | null;
 204:     reason: string | null;
 205:     remainingSeconds: number | null;
 206: }
 207: 
 208: export interface PrivacyCleanupStats {
 209:     runLogs: number;
 210:     jobAttempts: number;
 211:     leadEvents: number;
 212:     messageHistory: number;
 213:     deliveredOutboxEvents: number;
 214:     resolvedIncidents: number;
 215: }
 216: 
 217: export interface ListLeadStatusCount {
 218:     list_name: string;
 219:     status: LeadStatus;
 220:     total: number;
 221: }
 222: 
 223: export interface RuntimeLockRecord {
 224:     lock_key: string;
 225:     owner_id: string;
 226:     acquired_at: string;
 227:     heartbeat_at: string;
 228:     expires_at: string;
 229:     metadata_json: string;
 230:     updated_at: string;
 231: }
 232: 
 233: export interface AcquireRuntimeLockResult {
 234:     acquired: boolean;
 235:     lock: RuntimeLockRecord | null;
 236: }
 237: 
 238: function normalizeLeadListRow(row: LeadListRow): LeadListCampaignConfig {
 239:     return {
 240:         name: row.name,
 241:         source: row.source,
 242:         isActive: row.is_active === 1,
 243:         priority: row.priority,
 244:         dailyInviteCap: row.daily_invite_cap,
 245:         dailyMessageCap: row.daily_message_cap,
 246:         createdAt: row.created_at,
 247:     };
 248: }
 249: 
 250: export async function addLead(input: AddLeadInput): Promise<boolean> {
 251:     const db = await getDatabase();
 252:     await ensureLeadList(input.listName);
 253: 
 254:     const result = await db.run(
 255:         `
 256:         INSERT OR IGNORE INTO leads
 257:             (account_name, first_name, last_name, job_title, website, linkedin_url, status, list_name)
 258:         VALUES (?, ?, ?, ?, ?, ?, 'NEW', ?)
 259:     `,
 260:         [
 261:             input.accountName,
 262:             input.firstName,
 263:             input.lastName,
 264:             input.jobTitle,
 265:             input.website,
 266:             input.linkedinUrl,
 267:             input.listName,
 268:         ]
 269:     );
 270: 
 271:     // Mantiene la relazione lista<->lead anche quando il lead esiste già.
 272:     const leadRow = await db.get<{ id: number }>(`SELECT id FROM leads WHERE linkedin_url = ?`, [input.linkedinUrl]);
 273:     const listRow = await db.get<{ id: number }>(`SELECT id FROM lead_lists WHERE name = ?`, [input.listName]);
 274:     if (leadRow?.id && listRow?.id) {
 275:         await db.run(`INSERT OR IGNORE INTO list_leads (list_id, lead_id) VALUES (?, ?)`, [listRow.id, leadRow.id]);
 276:     }
 277: 
 278:     return (result.changes ?? 0) > 0;
 279: }
 280: 
 281: export async function addCompanyTarget(input: AddCompanyTargetInput): Promise<boolean> {
 282:     const db = await getDatabase();
 283:     await ensureLeadList(input.listName);
 284: 
 285:     const normalizedAccountName = (input.accountName ?? '').trim();
 286:     const normalizedWebsite = (input.website ?? '').trim();
 287:     if (!normalizedAccountName && !normalizedWebsite) {
 288:         return false;
 289:     }
 290: 
 291:     const result = await db.run(
 292:         `
 293:         INSERT OR IGNORE INTO company_targets (list_name, account_name, website, source_file, status)
 294:         VALUES (?, ?, ?, ?, 'NEW')
 295:     `,
 296:         [input.listName, normalizedAccountName, normalizedWebsite, input.sourceFile ?? null]
 297:     );
 298:     return (result.changes ?? 0) > 0;
 299: }
 300: 
 301: export async function countCompanyTargets(listName?: string): Promise<number> {
 302:     const db = await getDatabase();
 303:     const row = listName
 304:         ? await db.get<{ total: number }>(
 305:             `SELECT COUNT(*) as total FROM company_targets WHERE list_name = ?`,
 306:             [listName]
 307:         )
 308:         : await db.get<{ total: number }>(
 309:             `SELECT COUNT(*) as total FROM company_targets`
 310:         );
 311:     return row?.total ?? 0;
 312: }
 313: 
 314: export async function listCompanyTargets(listName: string | null, limit: number): Promise<CompanyTargetRecord[]> {
 315:     const db = await getDatabase();
 316:     const safeLimit = Math.max(1, limit);
 317:     if (listName) {
 318:         return db.all<CompanyTargetRecord[]>(
 319:             `
 320:             SELECT id, list_name, account_name, website, source_file, status, attempts, last_error, processed_at, created_at, updated_at
 321:             FROM company_targets
 322:             WHERE list_name = ?
 323:             ORDER BY updated_at DESC, created_at DESC
 324:             LIMIT ?
 325:         `,
 326:             [listName, safeLimit]
 327:         );
 328:     }
 329: 
 330:     return db.all<CompanyTargetRecord[]>(
 331:         `
 332:         SELECT id, list_name, account_name, website, source_file, status, attempts, last_error, processed_at, created_at, updated_at
 333:         FROM company_targets
 334:         ORDER BY updated_at DESC, created_at DESC
 335:         LIMIT ?
 336:     `,
 337:         [safeLimit]
 338:     );
 339: }
 340: 
 341: export async function getCompanyTargetsForEnrichment(limit: number): Promise<CompanyTargetRecord[]> {
 342:     const db = await getDatabase();
 343:     const safeLimit = Math.max(1, limit);
 344:     return db.all<CompanyTargetRecord[]>(
 345:         `
 346:         SELECT id, list_name, account_name, website, source_file, status, attempts, last_error, processed_at, created_at, updated_at
 347:         FROM company_targets
 348:         WHERE status IN ('NEW', 'ERROR')
 349:         ORDER BY status DESC, created_at ASC
 350:         LIMIT ?
 351:     `,
 352:         [safeLimit]
 353:     );
 354: }
 355: 
 356: export async function setCompanyTargetStatus(
 357:     targetId: number,
 358:     status: CompanyTargetStatus,
 359:     lastError: string | null = null
 360: ): Promise<void> {
 361:     const db = await getDatabase();
 362:     await db.run(
 363:         `
 364:         UPDATE company_targets
 365:         SET status = ?,
 366:             attempts = attempts + 1,
 367:             last_error = ?,
 368:             processed_at = CURRENT_TIMESTAMP,
 369:             updated_at = CURRENT_TIMESTAMP
 370:         WHERE id = ?
 371:     `,
 372:         [status, lastError, targetId]
 373:     );
 374: }
 375: 
 376: export async function countCompanyTargetsByStatuses(statuses: CompanyTargetStatus[]): Promise<number> {
 377:     if (statuses.length === 0) return 0;
 378:     const db = await getDatabase();
 379:     const placeholders = statuses.map(() => '?').join(', ');
 380:     const row = await db.get<{ total: number }>(
 381:         `SELECT COUNT(*) as total FROM company_targets WHERE status IN (${placeholders})`,
 382:         statuses
 383:     );
 384:     return row?.total ?? 0;
 385: }
 386: 
 387: export async function promoteNewLeadsToReadyInvite(limit: number): Promise<number> {
 388:     const db = await getDatabase();
 389:     const leads = await db.all<{ id: number }[]>(
 390:         `SELECT id FROM leads WHERE status = 'NEW' ORDER BY created_at ASC LIMIT ?`,
 391:         [limit]
 392:     );
 393:     if (leads.length === 0) return 0;
 394: 
 395:     const ids = leads.map((lead) => lead.id);
 396:     const placeholders = ids.map(() => '?').join(', ');
 397:     const result = await db.run(
 398:         `UPDATE leads SET status = 'READY_INVITE', updated_at = CURRENT_TIMESTAMP WHERE id IN (${placeholders})`,
 399:         ids
 400:     );
 401:     return result.changes ?? 0;
 402: }
 403: 
 404: export async function getLeadById(leadId: number): Promise<LeadRecord | null> {
 405:     const db = await getDatabase();
 406:     const lead = await db.get<LeadRecord>(`SELECT * FROM leads WHERE id = ?`, [leadId]);
 407:     if (!lead) return null;
 408:     lead.status = normalizeLegacyStatus(lead.status);
 409:     return lead;
 410: }
 411: 
 412: export async function getLeadsWithSalesNavigatorUrls(limit: number): Promise<LeadRecord[]> {
 413:     const db = await getDatabase();
 414:     const safeLimit = Math.max(1, limit);
 415:     const leads = await db.all<LeadRecord[]>(
 416:         `
 417:         SELECT *
 418:         FROM leads
 419:         WHERE linkedin_url LIKE '%linkedin.com/sales/%'
 420:           AND status IN ('NEW', 'READY_INVITE', 'INVITED', 'ACCEPTED', 'READY_MESSAGE', 'BLOCKED', 'PENDING')
 421:         ORDER BY updated_at DESC, created_at ASC
 422:         LIMIT ?
 423:     `,
 424:         [safeLimit]
 425:     );
 426:     return leads.map((lead) => ({ ...lead, status: normalizeLegacyStatus(lead.status) }));
 427: }
 428: 
 429: export interface UpdateLeadLinkedinUrlResult {
 430:     updated: boolean;
 431:     conflictLeadId: number | null;
 432: }
 433: 
 434: export async function updateLeadLinkedinUrl(leadId: number, nextLinkedinUrl: string): Promise<UpdateLeadLinkedinUrlResult> {
 435:     const db = await getDatabase();
 436:     const normalizedUrl = normalizeLinkedInUrl(nextLinkedinUrl);
 437: 
 438:     try {
 439:         const result = await db.run(
 440:             `
 441:             UPDATE leads
 442:             SET linkedin_url = ?,
 443:                 updated_at = CURRENT_TIMESTAMP
 444:             WHERE id = ?
 445:         `,
 446:             [normalizedUrl, leadId]
 447:         );
 448:         return {
 449:             updated: (result.changes ?? 0) > 0,
 450:             conflictLeadId: null,
 451:         };
 452:     } catch (error) {
 453:         const message = error instanceof Error ? error.message : String(error);
 454:         if (!/UNIQUE constraint failed:\s*leads\.linkedin_url/i.test(message)) {
 455:             throw error;
 456:         }
 457:         const conflict = await db.get<{ id: number }>(
 458:             `SELECT id FROM leads WHERE linkedin_url = ? LIMIT 1`,
 459:             [normalizedUrl]
 460:         );
 461:         return {
 462:             updated: false,
 463:             conflictLeadId: conflict?.id ?? null,
 464:         };
 465:     }
 466: }
 467: 
 468: export async function getLeadsByStatus(status: LeadStatus, limit: number): Promise<LeadRecord[]> {
 469:     const db = await getDatabase();
 470:     const normalized = normalizeLegacyStatus(status);
 471:     const leads = await db.all<LeadRecord[]>(
 472:         `SELECT * FROM leads WHERE status = ? ORDER BY created_at ASC LIMIT ?`,
 473:         [normalized, limit]
 474:     );
 475:     return leads.map((lead) => ({ ...lead, status: normalizeLegacyStatus(lead.status) }));
 476: }
 477: 
 478: export async function getLeadsByStatusForList(status: LeadStatus, listName: string, limit: number): Promise<LeadRecord[]> {
 479:     const db = await getDatabase();
 480:     const normalized = normalizeLegacyStatus(status);
 481:     const leads = await db.all<LeadRecord[]>(
 482:         `
 483:         SELECT *
 484:         FROM leads
 485:         WHERE status = ?
 486:           AND list_name = ?
 487:         ORDER BY created_at ASC
 488:         LIMIT ?
 489:     `,
 490:         [normalized, listName, limit]
 491:     );
 492:     return leads.map((lead) => ({ ...lead, status: normalizeLegacyStatus(lead.status) }));
 493: }
 494: 
 495: export async function countLeadsByStatuses(statuses: LeadStatus[]): Promise<number> {
 496:     if (statuses.length === 0) return 0;
 497:     const db = await getDatabase();
 498:     const normalized = statuses.map((status) => normalizeLegacyStatus(status));
 499:     const placeholders = normalized.map(() => '?').join(', ');
 500:     const row = await db.get<{ total: number }>(
 501:         `SELECT COUNT(*) as total FROM leads WHERE status IN (${placeholders})`,
 502:         normalized
 503:     );
 504:     return row?.total ?? 0;
 505: }
 506: 
 507: export async function getLeadStatusCountsForLists(listNames: string[]): Promise<ListLeadStatusCount[]> {
 508:     if (listNames.length === 0) {
 509:         return [];
 510:     }
 511: 
 512:     const db = await getDatabase();
 513:     const placeholders = listNames.map(() => '?').join(', ');
 514:     return db.all<ListLeadStatusCount[]>(
 515:         `
 516:         SELECT list_name, status, COUNT(*) as total
 517:         FROM leads
 518:         WHERE list_name IN (${placeholders})
 519:         GROUP BY list_name, status
 520:     `,
 521:         listNames
 522:     );
 523: }
 524: 
 525: export async function setLeadStatus(leadId: number, status: LeadStatus, errorMessage?: string, blockedReason?: string): Promise<void> {
 526:     const db = await getDatabase();
 527:     const normalized = normalizeLegacyStatus(status);
 528:     const timestampColumn = normalized === 'INVITED' ? 'invited_at' : normalized === 'ACCEPTED' ? 'accepted_at' : normalized === 'MESSAGED' ? 'messaged_at' : null;
 529: 
 530:     if (timestampColumn) {
 531:         await db.run(
 532:             `
 533:             UPDATE leads
 534:             SET status = ?, ${timestampColumn} = CURRENT_TIMESTAMP, last_error = ?, blocked_reason = ?, updated_at = CURRENT_TIMESTAMP
 535:             WHERE id = ?
 536:         `,
 537:             [normalized, errorMessage ?? null, blockedReason ?? null, leadId]
 538:         );
 539:         return;
 540:     }
 541: 
 542:     await db.run(
 543:         `
 544:         UPDATE leads
 545:         SET status = ?, last_error = ?, blocked_reason = ?, updated_at = CURRENT_TIMESTAMP
 546:         WHERE id = ?
 547:     `,
 548:         [normalized, errorMessage ?? null, blockedReason ?? null, leadId]
 549:     );
 550: }
 551: 
 552: export async function appendLeadEvent(
 553:     leadId: number,
 554:     fromStatus: LeadStatus,
 555:     toStatus: LeadStatus,
 556:     reason: string,
 557:     metadata: Record<string, unknown>
 558: ): Promise<void> {
 559:     const db = await getDatabase();
 560:     await db.run(
 561:         `
 562:         INSERT INTO lead_events (lead_id, from_status, to_status, reason, metadata_json)
 563:         VALUES (?, ?, ?, ?, ?)
 564:     `,
 565:         [leadId, normalizeLegacyStatus(fromStatus), normalizeLegacyStatus(toStatus), reason, JSON.stringify(metadata)]
 566:     );
 567: }
 568: 
 569: export async function getDailyStat(dateString: string, field: 'invites_sent' | 'messages_sent' | 'challenges_count' | 'selector_failures' | 'run_errors'): Promise<number> {
 570:     const db = await getDatabase();
 571:     const row = await db.get<Record<string, number>>(
 572:         `SELECT ${field} FROM daily_stats WHERE date = ?`,
 573:         [dateString]
 574:     );
 575:     return row?.[field] ?? 0;
 576: }
 577: 
 578: export async function getDailyStatsSnapshot(dateString: string): Promise<DailyStatsSnapshot> {
 579:     const db = await getDatabase();
 580:     const row = await db.get<{
 581:         invites_sent: number;
 582:         messages_sent: number;
 583:         challenges_count: number;
 584:         selector_failures: number;
 585:         run_errors: number;
 586:     }>(
 587:         `SELECT invites_sent, messages_sent, challenges_count, selector_failures, run_errors FROM daily_stats WHERE date = ?`,
 588:         [dateString]
 589:     );
 590: 
 591:     return {
 592:         date: dateString,
 593:         invitesSent: row?.invites_sent ?? 0,
 594:         messagesSent: row?.messages_sent ?? 0,
 595:         challengesCount: row?.challenges_count ?? 0,
 596:         selectorFailures: row?.selector_failures ?? 0,
 597:         runErrors: row?.run_errors ?? 0,
 598:     };
 599: }
 600: 
 601: export async function getListDailyStat(
 602:     dateString: string,
 603:     listName: string,
 604:     field: 'invites_sent' | 'messages_sent'
 605: ): Promise<number> {
 606:     const db = await getDatabase();
 607:     const row = await db.get<Record<string, number>>(
 608:         `SELECT ${field} FROM list_daily_stats WHERE date = ? AND list_name = ?`,
 609:         [dateString, listName]
 610:     );
 611:     return row?.[field] ?? 0;
 612: }
 613: 
 614: export async function incrementDailyStat(
 615:     dateString: string,
 616:     field: 'invites_sent' | 'messages_sent' | 'challenges_count' | 'selector_failures' | 'run_errors',
 617:     amount: number = 1
 618: ): Promise<void> {
 619:     const db = await getDatabase();
 620:     await db.run(
 621:         `
 622:         INSERT INTO daily_stats (date, ${field}) VALUES (?, ?)
 623:         ON CONFLICT(date) DO UPDATE SET ${field} = ${field} + ?
 624:     `,
 625:         [dateString, amount, amount]
 626:     );
 627: }
 628: 
 629: export async function incrementListDailyStat(
 630:     dateString: string,
 631:     listName: string,
 632:     field: 'invites_sent' | 'messages_sent',
 633:     amount: number = 1
 634: ): Promise<void> {
 635:     const db = await getDatabase();
 636:     await db.run(
 637:         `
 638:         INSERT INTO list_daily_stats (date, list_name, ${field}) VALUES (?, ?, ?)
 639:         ON CONFLICT(date, list_name) DO UPDATE SET ${field} = ${field} + ?
 640:     `,
 641:         [dateString, listName, amount, amount]
 642:     );
 643: }
 644: 
 645: export async function countWeeklyInvites(weekStartDate: string): Promise<number> {
 646:     const db = await getDatabase();
 647:     const row = await db.get<{ total: number }>(
 648:         `SELECT COALESCE(SUM(invites_sent), 0) as total FROM daily_stats WHERE date >= ?`,
 649:         [weekStartDate]
 650:     );
 651:     return row?.total ?? 0;
 652: }
 653: 
 654: export async function enqueueJob(
 655:     type: JobType,
 656:     payload: Record<string, unknown>,
 657:     idempotencyKey: string,
 658:     priority: number,
 659:     maxAttempts: number,
 660:     initialDelaySeconds: number = 0
 661: ): Promise<boolean> {
 662:     const db = await getDatabase();
 663:     const safeDelay = Math.max(0, Math.floor(initialDelaySeconds));
 664:     const result = await db.run(
 665:         `
 666:         INSERT OR IGNORE INTO jobs (type, status, payload_json, idempotency_key, priority, max_attempts, next_run_at)
 667:         VALUES (?, 'QUEUED', ?, ?, ?, ?, DATETIME('now', '+' || ? || ' seconds'))
 668:     `,
 669:         [type, JSON.stringify(payload), idempotencyKey, priority, maxAttempts, safeDelay]
 670:     );
 671:     return (result.changes ?? 0) > 0;
 672: }
 673: 
 674: export async function lockNextQueuedJob(allowedTypes: JobType[]): Promise<JobRecord | null> {
 675:     const db = await getDatabase();
 676:     return withTransaction(db, async () => {
 677:         const placeholders = allowedTypes.map(() => '?').join(', ');
 678:         const job = await db.get<JobRecord>(
 679:             `
 680:             SELECT * FROM jobs
 681:             WHERE status = 'QUEUED'
 682:               AND next_run_at <= CURRENT_TIMESTAMP
 683:               AND type IN (${placeholders})
 684:             ORDER BY priority ASC, created_at ASC
 685:             LIMIT 1
 686:         `,
 687:             allowedTypes
 688:         );
 689: 
 690:         if (!job) return null;
 691: 
 692:         const updateResult = await db.run(
 693:             `
 694:             UPDATE jobs
 695:             SET status = 'RUNNING', locked_at = CURRENT_TIMESTAMP, updated_at = CURRENT_TIMESTAMP
 696:             WHERE id = ? AND status = 'QUEUED'
 697:         `,
 698:             [job.id]
 699:         );
 700:         if ((updateResult.changes ?? 0) === 0) {
 701:             return null;
 702:         }
 703: 
 704:         return {
 705:             ...job,
 706:             status: 'RUNNING',
 707:             payload_json: job.payload_json,
 708:         };
 709:     });
 710: }
 711: 
 712: export async function markJobSucceeded(jobId: number): Promise<void> {
 713:     const db = await getDatabase();
 714:     await db.run(
 715:         `
 716:         UPDATE jobs
 717:         SET status = 'SUCCEEDED', locked_at = NULL, updated_at = CURRENT_TIMESTAMP
 718:         WHERE id = ?
 719:     `,
 720:         [jobId]
 721:     );
 722: }
 723: 
 724: export async function markJobRetryOrDeadLetter(
 725:     jobId: number,
 726:     attempts: number,
 727:     maxAttempts: number,
 728:     nextRetryDelayMs: number,
 729:     errorMessage: string
 730: ): Promise<JobStatus> {
 731:     const db = await getDatabase();
 732:     if (attempts >= maxAttempts) {
 733:         await db.run(
 734:             `
 735:             UPDATE jobs
 736:             SET status = 'DEAD_LETTER',
 737:                 attempts = ?,
 738:                 last_error = ?,
 739:                 locked_at = NULL,
 740:                 updated_at = CURRENT_TIMESTAMP
 741:             WHERE id = ?
 742:         `,
 743:             [attempts, errorMessage, jobId]
 744:         );
 745:         return 'DEAD_LETTER';
 746:     }
 747: 
 748:     const seconds = Math.max(1, Math.ceil(nextRetryDelayMs / 1000));
 749:     await db.run(
 750:         `
 751:         UPDATE jobs
 752:         SET status = 'QUEUED',
 753:             attempts = ?,
 754:             last_error = ?,
 755:             next_run_at = DATETIME('now', '+' || ? || ' seconds'),
 756:             locked_at = NULL,
 757:             updated_at = CURRENT_TIMESTAMP
 758:         WHERE id = ?
 759:     `,
 760:         [attempts, errorMessage, seconds, jobId]
 761:     );
 762:     return 'QUEUED';
 763: }
 764: 
 765: export async function createJobAttempt(
 766:     jobId: number,
 767:     success: boolean,
 768:     errorCode: string | null,
 769:     errorMessage: string | null,
 770:     evidencePath: string | null
 771: ): Promise<void> {
 772:     const db = await getDatabase();
 773:     await db.run(
 774:         `
 775:         INSERT INTO job_attempts (job_id, finished_at, success, error_code, error_message, evidence_path)
 776:         VALUES (?, CURRENT_TIMESTAMP, ?, ?, ?, ?)
 777:     `,
 778:         [jobId, success ? 1 : 0, errorCode, errorMessage, evidencePath]
 779:     );
 780: }
 781: 
 782: export async function createIncident(
 783:     type: string,
 784:     severity: 'INFO' | 'WARN' | 'CRITICAL',
 785:     details: Record<string, unknown>
 786: ): Promise<number> {
 787:     const db = await getDatabase();
 788:     const result = await db.run(
 789:         `
 790:         INSERT INTO account_incidents (type, severity, status, details_json)
 791:         VALUES (?, ?, 'OPEN', ?)
 792:     `,
 793:         [type, severity, JSON.stringify(details)]
 794:     );
 795:     return result.lastID ?? 0;
 796: }
 797: 
 798: export async function listOpenIncidents(): Promise<Array<{ id: number; type: string; severity: string; opened_at: string }>> {
 799:     const db = await getDatabase();
 800:     return db.all(`SELECT id, type, severity, opened_at FROM account_incidents WHERE status = 'OPEN' ORDER BY opened_at DESC`);
 801: }
 802: 
 803: export async function resolveIncident(incidentId: number): Promise<void> {
 804:     const db = await getDatabase();
 805:     await db.run(
 806:         `
 807:         UPDATE account_incidents
 808:         SET status = 'RESOLVED', resolved_at = CURRENT_TIMESTAMP
 809:         WHERE id = ?
 810:     `,
 811:         [incidentId]
 812:     );
 813: }
 814: 
 815: export async function pushOutboxEvent(topic: string, payload: Record<string, unknown>, idempotencyKey: string): Promise<void> {
 816:     const db = await getDatabase();
 817:     await db.run(
 818:         `
 819:         INSERT OR IGNORE INTO outbox_events (topic, payload_json, idempotency_key)
 820:         VALUES (?, ?, ?)
 821:     `,
 822:         [topic, JSON.stringify(payload), idempotencyKey]
 823:     );
 824: }
 825: 
 826: export async function getPendingOutboxEvents(limit: number): Promise<OutboxEventRecord[]> {
 827:     const db = await getDatabase();
 828:     return db.all<OutboxEventRecord[]>(
 829:         `
 830:         SELECT * FROM outbox_events
 831:         WHERE delivered_at IS NULL
 832:           AND next_retry_at <= CURRENT_TIMESTAMP
 833:         ORDER BY created_at ASC
 834:         LIMIT ?
 835:     `,
 836:         [limit]
 837:     );
 838: }
 839: 
 840: export async function markOutboxDelivered(eventId: number): Promise<void> {
 841:     const db = await getDatabase();
 842:     await db.run(
 843:         `
 844:         UPDATE outbox_events
 845:         SET delivered_at = CURRENT_TIMESTAMP,
 846:             last_error = NULL
 847:         WHERE id = ?
 848:     `,
 849:         [eventId]
 850:     );
 851: }
 852: 
 853: export async function markOutboxRetry(eventId: number, attempts: number, retryDelayMs: number, errorMessage: string): Promise<void> {
 854:     const db = await getDatabase();
 855:     const seconds = Math.max(1, Math.ceil(retryDelayMs / 1000));
 856:     await db.run(
 857:         `
 858:         UPDATE outbox_events
 859:         SET attempts = ?,
 860:             next_retry_at = DATETIME('now', '+' || ? || ' seconds'),
 861:             last_error = ?
 862:         WHERE id = ?
 863:     `,
 864:         [attempts, seconds, errorMessage, eventId]
 865:     );
 866: }
 867: 
 868: export async function markOutboxPermanentFailure(eventId: number, attempts: number, errorMessage: string): Promise<void> {
 869:     const db = await getDatabase();
 870:     await db.run(
 871:         `
 872:         UPDATE outbox_events
 873:         SET attempts = ?,
 874:             delivered_at = CURRENT_TIMESTAMP,
 875:             last_error = ?
 876:         WHERE id = ?
 877:     `,
 878:         [attempts, `PERMANENT_FAILURE: ${errorMessage}`, eventId]
 879:     );
 880: }
 881: 
 882: export async function countPendingOutboxEvents(): Promise<number> {
 883:     const db = await getDatabase();
 884:     const row = await db.get<{ total: number }>(`SELECT COUNT(*) as total FROM outbox_events WHERE delivered_at IS NULL`);
 885:     return row?.total ?? 0;
 886: }
 887: 
 888: export async function getJobStatusCounts(): Promise<JobStatusCounts> {
 889:     const db = await getDatabase();
 890:     const rows = await db.all<{ status: JobStatus; total: number }[]>(
 891:         `SELECT status, COUNT(*) as total FROM jobs GROUP BY status`
 892:     );
 893: 
 894:     const counts: JobStatusCounts = {
 895:         QUEUED: 0,
 896:         RUNNING: 0,
 897:         SUCCEEDED: 0,
 898:         FAILED: 0,
 899:         DEAD_LETTER: 0,
 900:         PAUSED: 0,
 901:     };
 902: 
 903:     for (const row of rows) {
 904:         if (row.status in counts) {
 905:             counts[row.status] = row.total;
 906:         }
 907:     }
 908: 
 909:     return counts;
 910: }
 911: 
 912: export async function getRuntimeLock(lockKey: string): Promise<RuntimeLockRecord | null> {
 913:     const db = await getDatabase();
 914:     const row = await db.get<RuntimeLockRecord>(`SELECT * FROM runtime_locks WHERE lock_key = ?`, [lockKey]);
 915:     return row ?? null;
 916: }
 917: 
 918: export async function acquireRuntimeLock(
 919:     lockKey: string,
 920:     ownerId: string,
 921:     ttlSeconds: number,
 922:     metadata: Record<string, unknown> = {}
 923: ): Promise<AcquireRuntimeLockResult> {
 924:     const db = await getDatabase();
 925:     const safeTtl = Math.max(1, ttlSeconds);
 926:     const metadataJson = JSON.stringify(metadata);
 927: 
 928:     return withTransaction(db, async () => {
 929:         const existing = await db.get<RuntimeLockRecord>(
 930:             `SELECT * FROM runtime_locks WHERE lock_key = ?`,
 931:             [lockKey]
 932:         );
 933: 
 934:         if (!existing) {
 935:             await db.run(
 936:                 `
 937:                 INSERT INTO runtime_locks (lock_key, owner_id, metadata_json, expires_at)
 938:                 VALUES (?, ?, ?, DATETIME('now', '+' || ? || ' seconds'))
 939:             `,
 940:                 [lockKey, ownerId, metadataJson, safeTtl]
 941:             );
 942:             const inserted = await db.get<RuntimeLockRecord>(`SELECT * FROM runtime_locks WHERE lock_key = ?`, [lockKey]);
 943:             return {
 944:                 acquired: true,
 945:                 lock: inserted ?? null,
 946:             };
 947:         }
 948: 
 949:         if (existing.owner_id === ownerId) {
 950:             await db.run(
 951:                 `
 952:                 UPDATE runtime_locks
 953:                 SET heartbeat_at = CURRENT_TIMESTAMP,
 954:                     expires_at = DATETIME('now', '+' || ? || ' seconds'),
 955:                     metadata_json = ?,
 956:                     updated_at = CURRENT_TIMESTAMP
 957:                 WHERE lock_key = ?
 958:             `,
 959:                 [safeTtl, metadataJson, lockKey]
 960:             );
 961:             const renewed = await db.get<RuntimeLockRecord>(`SELECT * FROM runtime_locks WHERE lock_key = ?`, [lockKey]);
 962:             return {
 963:                 acquired: true,
 964:                 lock: renewed ?? null,
 965:             };
 966:         }
 967: 
 968:         const isStaleRow = await db.get<{ stale: number }>(
 969:             `
 970:             SELECT CASE WHEN expires_at <= CURRENT_TIMESTAMP THEN 1 ELSE 0 END AS stale
 971:             FROM runtime_locks
 972:             WHERE lock_key = ?
 973:         `,
 974:             [lockKey]
 975:         );
 976: 
 977:         if ((isStaleRow?.stale ?? 0) === 1) {
 978:             await db.run(
 979:                 `
 980:                 UPDATE runtime_locks
 981:                 SET owner_id = ?,
 982:                     acquired_at = CURRENT_TIMESTAMP,
 983:                     heartbeat_at = CURRENT_TIMESTAMP,
 984:                     expires_at = DATETIME('now', '+' || ? || ' seconds'),
 985:                     metadata_json = ?,
 986:                     updated_at = CURRENT_TIMESTAMP
 987:                 WHERE lock_key = ?
 988:             `,
 989:                 [ownerId, safeTtl, metadataJson, lockKey]
 990:             );
 991:             const takenOver = await db.get<RuntimeLockRecord>(`SELECT * FROM runtime_locks WHERE lock_key = ?`, [lockKey]);
 992:             return {
 993:                 acquired: true,
 994:                 lock: takenOver ?? null,
 995:             };
 996:         }
 997: 
 998:         return {
 999:             acquired: false,
1000:             lock: existing,
1001:         };
1002:     });
1003: }
1004: 
1005: export async function heartbeatRuntimeLock(lockKey: string, ownerId: string, ttlSeconds: number): Promise<boolean> {
1006:     const db = await getDatabase();
1007:     const safeTtl = Math.max(1, ttlSeconds);
1008:     const result = await db.run(
1009:         `
1010:         UPDATE runtime_locks
1011:         SET heartbeat_at = CURRENT_TIMESTAMP,
1012:             expires_at = DATETIME('now', '+' || ? || ' seconds'),
1013:             updated_at = CURRENT_TIMESTAMP
1014:         WHERE lock_key = ?
1015:           AND owner_id = ?
1016:     `,
1017:         [safeTtl, lockKey, ownerId]
1018:     );
1019:     return (result.changes ?? 0) > 0;
1020: }
1021: 
1022: export async function releaseRuntimeLock(lockKey: string, ownerId: string): Promise<boolean> {
1023:     const db = await getDatabase();
1024:     const result = await db.run(
1025:         `
1026:         DELETE FROM runtime_locks
1027:         WHERE lock_key = ?
1028:           AND owner_id = ?
1029:     `,
1030:         [lockKey, ownerId]
1031:     );
1032:     return (result.changes ?? 0) > 0;
1033: }
1034: 
1035: export async function setRuntimeFlag(key: string, value: string): Promise<void> {
1036:     const db = await getDatabase();
1037:     await db.run(
1038:         `
1039:         INSERT INTO sync_state (key, value, updated_at) VALUES (?, ?, CURRENT_TIMESTAMP)
1040:         ON CONFLICT(key) DO UPDATE SET value = excluded.value, updated_at = CURRENT_TIMESTAMP
1041:     `,
1042:         [key, value]
1043:     );
1044: }
1045: 
1046: export async function getRuntimeFlag(key: string): Promise<string | null> {
1047:     const db = await getDatabase();
1048:     const row = await db.get<{ value: string }>(`SELECT value FROM sync_state WHERE key = ?`, [key]);
1049:     return row?.value ?? null;
1050: }
1051: 
1052: export async function setAutomationPause(minutes: number | null, reason: string): Promise<string | null> {
1053:     await setRuntimeFlag('automation_paused', 'true');
1054:     await setRuntimeFlag('automation_pause_reason', reason.trim() || 'manual_pause');
1055: 
1056:     if (minutes === null) {
1057:         await setRuntimeFlag('automation_paused_until', '');
1058:         return null;
1059:     }
1060: 
1061:     const safeMinutes = Math.max(1, minutes);
1062:     const until = new Date(Date.now() + safeMinutes * 60_000).toISOString();
1063:     await setRuntimeFlag('automation_paused_until', until);
1064:     return until;
1065: }
1066: 
1067: export async function clearAutomationPause(): Promise<void> {
1068:     await setRuntimeFlag('automation_paused', 'false');
1069:     await setRuntimeFlag('automation_paused_until', '');
1070:     await setRuntimeFlag('automation_pause_reason', '');
1071: }
1072: 
1073: export async function getAutomationPauseState(now: Date = new Date()): Promise<AutomationPauseState> {
1074:     const paused = (await getRuntimeFlag('automation_paused')) === 'true';
1075:     if (!paused) {
1076:         return {
1077:             paused: false,
1078:             pausedUntil: null,
1079:             reason: null,
1080:             remainingSeconds: null,
1081:         };
1082:     }
1083: 
1084:     const reasonRaw = await getRuntimeFlag('automation_pause_reason');
1085:     const untilRaw = await getRuntimeFlag('automation_paused_until');
1086:     const parsedUntil = untilRaw && Number.isFinite(Date.parse(untilRaw))
1087:         ? new Date(untilRaw).toISOString()
1088:         : null;
1089: 
1090:     if (parsedUntil && Date.parse(parsedUntil) <= now.getTime()) {
1091:         await clearAutomationPause();
1092:         return {
1093:             paused: false,
1094:             pausedUntil: null,
1095:             reason: null,
1096:             remainingSeconds: null,
1097:         };
1098:     }
1099: 
1100:     const remainingSeconds = parsedUntil
1101:         ? Math.max(0, Math.ceil((Date.parse(parsedUntil) - now.getTime()) / 1000))
1102:         : null;
1103: 
1104:     return {
1105:         paused: true,
1106:         pausedUntil: parsedUntil,
1107:         reason: reasonRaw && reasonRaw.trim() ? reasonRaw : null,
1108:         remainingSeconds,
1109:     };
1110: }
1111: 
1112: export async function recordRunLog(level: 'INFO' | 'WARN' | 'ERROR', event: string, payload: Record<string, unknown>): Promise<void> {
1113:     const db = await getDatabase();
1114:     await db.run(
1115:         `
1116:         INSERT INTO run_logs (level, event, payload_json)
1117:         VALUES (?, ?, ?)
1118:     `,
1119:         [level, event, JSON.stringify(payload)]
1120:     );
1121: }
1122: 
1123: export async function getLastRunLogs(limit: number): Promise<Array<{ level: string; event: string; payload_json: string; created_at: string }>> {
1124:     const db = await getDatabase();
1125:     return db.all(
1126:         `SELECT level, event, payload_json, created_at FROM run_logs ORDER BY created_at DESC LIMIT ?`,
1127:         [limit]
1128:     );
1129: }
1130: 
1131: export async function cleanupPrivacyData(retentionDays: number): Promise<PrivacyCleanupStats> {
1132:     const db = await getDatabase();
1133:     const safeDays = Math.max(7, retentionDays);
1134:     const daysParam = String(safeDays);
1135: 
1136:     const runLogs = await db.run(
1137:         `DELETE FROM run_logs WHERE created_at < DATETIME('now', '-' || ? || ' days')`,
1138:         [daysParam]
1139:     );
1140:     const jobAttempts = await db.run(
1141:         `DELETE FROM job_attempts WHERE started_at < DATETIME('now', '-' || ? || ' days')`,
1142:         [daysParam]
1143:     );
1144:     const leadEvents = await db.run(
1145:         `DELETE FROM lead_events WHERE created_at < DATETIME('now', '-' || ? || ' days')`,
1146:         [daysParam]
1147:     );
1148:     const messageHistory = await db.run(
1149:         `DELETE FROM message_history WHERE sent_at < DATETIME('now', '-' || ? || ' days')`,
1150:         [daysParam]
1151:     );
1152:     const deliveredOutboxEvents = await db.run(
1153:         `DELETE FROM outbox_events
1154:          WHERE delivered_at IS NOT NULL
1155:            AND created_at < DATETIME('now', '-' || ? || ' days')`,
1156:         [daysParam]
1157:     );
1158:     const resolvedIncidents = await db.run(
1159:         `DELETE FROM account_incidents
1160:          WHERE status = 'RESOLVED'
1161:            AND resolved_at < DATETIME('now', '-' || ? || ' days')`,
1162:         [daysParam]
1163:     );
1164: 
1165:     return {
1166:         runLogs: runLogs.changes ?? 0,
1167:         jobAttempts: jobAttempts.changes ?? 0,
1168:         leadEvents: leadEvents.changes ?? 0,
1169:         messageHistory: messageHistory.changes ?? 0,
1170:         deliveredOutboxEvents: deliveredOutboxEvents.changes ?? 0,
1171:         resolvedIncidents: resolvedIncidents.changes ?? 0,
1172:     };
1173: }
1174: 
1175: export async function storeMessageHash(leadId: number, contentHash: string): Promise<void> {
1176:     const db = await getDatabase();
1177:     await db.run(
1178:         `
1179:         INSERT INTO message_history (lead_id, content_hash)
1180:         VALUES (?, ?)
1181:     `,
1182:         [leadId, contentHash]
1183:     );
1184: }
1185: 
1186: export async function countRecentMessageHash(contentHash: string, hoursWindow: number): Promise<number> {
1187:     const db = await getDatabase();
1188:     const row = await db.get<{ total: number }>(
1189:         `
1190:         SELECT COUNT(*) as total
1191:         FROM message_history
1192:         WHERE content_hash = ?
1193:           AND sent_at >= DATETIME('now', '-' || ? || ' hours')
1194:     `,
1195:         [contentHash, hoursWindow]
1196:     );
1197:     return row?.total ?? 0;
1198: }
1199: 
1200: export async function getRiskInputs(localDate: string, hardInviteCap: number): Promise<RiskInputs> {
1201:     const db = await getDatabase();
1202:     const pendingInvites = await countLeadsByStatuses(['INVITED']);
1203:     const invitedTotalRow = await db.get<{ total: number }>(
1204:         `SELECT COUNT(*) as total FROM leads WHERE invited_at IS NOT NULL`
1205:     );
1206:     const invitedTotal = invitedTotalRow?.total ?? 0;
1207:     const pendingRatio = invitedTotal > 0 ? pendingInvites / invitedTotal : 0;
1208: 
1209:     const attemptsRow = await db.get<{ total: number }>(
1210:         `
1211:         SELECT COUNT(*) as total
1212:         FROM job_attempts
1213:         WHERE started_at >= DATETIME('now', '-24 hours')
1214:     `
1215:     );
1216:     const failedRow = await db.get<{ total: number }>(
1217:         `
1218:         SELECT COUNT(*) as total
1219:         FROM job_attempts
1220:         WHERE started_at >= DATETIME('now', '-24 hours')
1221:           AND success = 0
1222:     `
1223:     );
1224:     const totalAttempts = attemptsRow?.total ?? 0;
1225:     const failedAttempts = failedRow?.total ?? 0;
1226:     const errorRate = totalAttempts > 0 ? failedAttempts / totalAttempts : 0;
1227: 
1228:     const selectorFailures = await getDailyStat(localDate, 'selector_failures');
1229:     const denominator = Math.max(1, totalAttempts);
1230:     const selectorFailureRate = selectorFailures / denominator;
1231: 
1232:     const challengeCount = await getDailyStat(localDate, 'challenges_count');
1233:     const invitesSent = await getDailyStat(localDate, 'invites_sent');
1234:     const inviteVelocityRatio = hardInviteCap > 0 ? invitesSent / hardInviteCap : 0;
1235: 
1236:     return {
1237:         pendingRatio,
1238:         errorRate,
1239:         selectorFailureRate,
1240:         challengeCount,
1241:         inviteVelocityRatio,
1242:     };
1243: }
1244: 
1245: export interface JobWithPayload<T extends Record<string, unknown>> extends JobRecord {
1246:     payload: T;
1247: }
1248: 
1249: export function parseJobPayload<T extends Record<string, unknown>>(job: JobRecord): JobWithPayload<T> {
1250:     return {
1251:         ...job,
1252:         payload: parsePayload<T>(job.payload_json),
1253:     };
1254: }
1255: 
1256: 
1257: /**
1258:  * Al boot, resetta i job RUNNING bloccati da troppo tempo.
1259:  * Un job resta RUNNING se il processo viene killato durante l'esecuzione.
1260:  */
1261: export async function recoverStuckJobs(staleAfterMinutes: number = 30): Promise<number> {
1262:     const db = await getDatabase();
1263:     const result = await db.run(
1264:         `UPDATE jobs
1265:          SET status = 'QUEUED',
1266:              locked_at = NULL,
1267:              updated_at = CURRENT_TIMESTAMP,
1268:              last_error = 'Recovered from RUNNING on startup'
1269:          WHERE status = 'RUNNING'
1270:            AND (
1271:              locked_at IS NULL
1272:              OR locked_at <= DATETIME('now', '-' || ? || ' minutes')
1273:            )`,
1274:         [Math.max(1, staleAfterMinutes)]
1275:     );
1276:     return result.changes ?? 0;
1277: }
````

## File: src/core/scheduler.ts
````typescript
  1: import { config, getLocalDateString, getWeekStartDate } from '../config';
  2: import { evaluateRisk, calculateDynamicBudget } from '../risk/riskEngine';
  3: import { JobType, RiskSnapshot } from '../types/domain';
  4: import {
  5:     countWeeklyInvites,
  6:     ensureLeadList,
  7:     enqueueJob,
  8:     getDailyStat,
  9:     getLeadStatusCountsForLists,
 10:     getLeadsByStatusForList,
 11:     getListDailyStat,
 12:     getRiskInputs,
 13:     listLeadCampaignConfigs,
 14:     promoteNewLeadsToReadyInvite,
 15:     syncLeadListsFromLeads,
 16: } from './repositories';
 17: import { transitionLead } from './leadStateService';
 18: 
 19: export type WorkflowSelection = 'invite' | 'check' | 'message' | 'all';
 20: 
 21: export interface ScheduleResult {
 22:     localDate: string;
 23:     riskSnapshot: RiskSnapshot;
 24:     inviteBudget: number;
 25:     messageBudget: number;
 26:     queuedInviteJobs: number;
 27:     queuedCheckJobs: number;
 28:     queuedMessageJobs: number;
 29:     listBreakdown: ListScheduleBreakdown[];
 30:     dryRun: boolean;
 31: }
 32: 
 33: export interface ScheduleOptions {
 34:     dryRun?: boolean;
 35: }
 36: 
 37: export interface ListScheduleBreakdown {
 38:     listName: string;
 39:     inviteBudget: number;
 40:     messageBudget: number;
 41:     queuedInviteJobs: number;
 42:     queuedCheckJobs: number;
 43:     queuedMessageJobs: number;
 44:     adaptiveFactor: number;
 45:     adaptiveReasons: string[];
 46:     pendingRatio: number;
 47:     blockedRatio: number;
 48:     maxScheduledDelaySec: number;
 49: }
 50: 
 51: export function workflowToJobTypes(workflow: WorkflowSelection): JobType[] {
 52:     if (workflow === 'all') return ['INVITE', 'ACCEPTANCE_CHECK', 'MESSAGE'];
 53:     if (workflow === 'invite') return ['INVITE'];
 54:     if (workflow === 'check') return ['ACCEPTANCE_CHECK'];
 55:     return ['MESSAGE'];
 56: }
 57: 
 58: function buildInviteKey(leadId: number, localDate: string): string {
 59:     return `invite:${leadId}:${localDate}`;
 60: }
 61: 
 62: function buildMessageKey(leadId: number, acceptedAtDate: string): string {
 63:     return `message:${leadId}:${acceptedAtDate}`;
 64: }
 65: 
 66: function buildCheckKey(leadId: number, localDate: string): string {
 67:     return `check:${leadId}:${localDate}`;
 68: }
 69: 
 70: function computeListBudget(globalRemaining: number, listCap: number | null, alreadyConsumed: number): number {
 71:     const listRemaining = listCap === null
 72:         ? globalRemaining
 73:         : Math.max(0, listCap - alreadyConsumed);
 74:     return Math.max(0, Math.min(globalRemaining, listRemaining));
 75: }
 76: 
 77: interface AdaptiveBudgetContext {
 78:     factor: number;
 79:     reasons: string[];
 80:     pendingRatio: number;
 81:     blockedRatio: number;
 82: }
 83: 
 84: interface NoBurstPlanner {
 85:     nextDelaySec: () => number;
 86: }
 87: 
 88: function toNonNegativeInt(value: number): number {
 89:     return Math.max(0, Math.floor(value));
 90: }
 91: 
 92: function clamp01(value: number): number {
 93:     return Math.min(1, Math.max(0, value));
 94: }
 95: 
 96: function pickRandomInt(min: number, max: number): number {
 97:     const low = Math.min(min, max);
 98:     const high = Math.max(min, max);
 99:     if (high <= low) return low;
100:     return Math.floor(Math.random() * (high - low + 1)) + low;
101: }
102: 
103: function applyAdaptiveFactor(rawBudget: number, factor: number): number {
104:     if (rawBudget <= 0 || factor <= 0) {
105:         return 0;
106:     }
107:     const computed = Math.floor(rawBudget * factor);
108:     if (computed <= 0) {
109:         return 1;
110:     }
111:     return Math.min(rawBudget, computed);
112: }
113: 
114: function evaluateAdaptiveBudgetContext(
115:     statusCounts: Record<string, number>,
116:     riskAction: RiskSnapshot['action']
117: ): AdaptiveBudgetContext {
118:     if (!config.adaptiveCapsEnabled) {
119:         return {
120:             factor: riskAction === 'STOP' ? 0 : 1,
121:             reasons: riskAction === 'STOP' ? ['global_risk_stop'] : [],
122:             pendingRatio: 0,
123:             blockedRatio: 0,
124:         };
125:     }
126: 
127:     const invited = statusCounts.INVITED ?? 0;
128:     const acceptedLike = (statusCounts.ACCEPTED ?? 0) + (statusCounts.READY_MESSAGE ?? 0) + (statusCounts.MESSAGED ?? 0);
129:     const blockedSkipped = (statusCounts.BLOCKED ?? 0) + (statusCounts.SKIPPED ?? 0);
130: 
131:     const pendingRatioDenominator = Math.max(1, invited + acceptedLike);
132:     const pendingRatio = invited / pendingRatioDenominator;
133: 
134:     const blockedRatioDenominator = Math.max(1, invited + acceptedLike + blockedSkipped);
135:     const blockedRatio = blockedSkipped / blockedRatioDenominator;
136: 
137:     let factor = 1;
138:     const reasons: string[] = [];
139: 
140:     if (riskAction === 'STOP') {
141:         factor = 0;
142:         reasons.push('global_risk_stop');
143:     } else if (riskAction === 'WARN') {
144:         factor = Math.min(factor, clamp01(config.adaptiveCapsWarnFactor));
145:         reasons.push('global_risk_warn');
146:     }
147: 
148:     if (pendingRatio >= config.adaptiveCapsPendingStop) {
149:         factor = Math.min(factor, clamp01(config.adaptiveCapsMinFactor));
150:         reasons.push('list_pending_high');
151:     } else if (pendingRatio >= config.adaptiveCapsPendingWarn) {
152:         factor = Math.min(factor, 0.5);
153:         reasons.push('list_pending_warn');
154:     }
155: 
156:     if (blockedRatio >= config.adaptiveCapsBlockedWarn) {
157:         factor = Math.min(factor, 0.6);
158:         reasons.push('list_blocked_warn');
159:     }
160: 
161:     return {
162:         factor: clamp01(factor),
163:         reasons,
164:         pendingRatio: Number.parseFloat(pendingRatio.toFixed(4)),
165:         blockedRatio: Number.parseFloat(blockedRatio.toFixed(4)),
166:     };
167: }
168: 
169: function createNoBurstPlanner(): NoBurstPlanner {
170:     const minDelay = toNonNegativeInt(config.noBurstMinDelaySec);
171:     const maxDelay = toNonNegativeInt(config.noBurstMaxDelaySec);
172:     const longBreakEvery = toNonNegativeInt(config.noBurstLongBreakEvery);
173:     const longBreakMin = toNonNegativeInt(config.noBurstLongBreakMinSec);
174:     const longBreakMax = toNonNegativeInt(config.noBurstLongBreakMaxSec);
175: 
176:     let totalDelaySec = 0;
177:     let queuedJobs = 0;
178: 
179:     return {
180:         nextDelaySec: () => {
181:             queuedJobs += 1;
182:             totalDelaySec += pickRandomInt(minDelay, maxDelay);
183: 
184:             if (longBreakEvery > 0 && queuedJobs % longBreakEvery === 0) {
185:                 totalDelaySec += pickRandomInt(longBreakMin, longBreakMax);
186:             }
187: 
188:             return totalDelaySec;
189:         },
190:     };
191: }
192: 
193: async function resolveActiveLists(): Promise<string[]> {
194:     await syncLeadListsFromLeads();
195:     let lists = await listLeadCampaignConfigs(true);
196:     if (lists.length === 0) {
197:         await ensureLeadList('default');
198:         lists = await listLeadCampaignConfigs(true);
199:     }
200:     return lists.map((list) => list.name);
201: }
202: 
203: function initListBreakdown(listNames: string[]): Map<string, ListScheduleBreakdown> {
204:     const map = new Map<string, ListScheduleBreakdown>();
205:     for (const listName of listNames) {
206:         map.set(listName, {
207:             listName,
208:             inviteBudget: 0,
209:             messageBudget: 0,
210:             queuedInviteJobs: 0,
211:             queuedCheckJobs: 0,
212:             queuedMessageJobs: 0,
213:             adaptiveFactor: 1,
214:             adaptiveReasons: [],
215:             pendingRatio: 0,
216:             blockedRatio: 0,
217:             maxScheduledDelaySec: 0,
218:         });
219:     }
220:     return map;
221: }
222: 
223: export async function scheduleJobs(workflow: WorkflowSelection, options: ScheduleOptions = {}): Promise<ScheduleResult> {
224:     const dryRun = options.dryRun ?? false;
225:     const localDate = getLocalDateString();
226:     const riskInputs = await getRiskInputs(localDate, config.hardInviteCap);
227:     const riskSnapshot = evaluateRisk(riskInputs);
228: 
229:     const dailyInvitesSent = await getDailyStat(localDate, 'invites_sent');
230:     const dailyMessagesSent = await getDailyStat(localDate, 'messages_sent');
231:     const weekStartDate = getWeekStartDate();
232:     const weeklyInvitesSent = await countWeeklyInvites(weekStartDate);
233:     const weeklyRemaining = Math.max(0, config.weeklyInviteLimit - weeklyInvitesSent);
234: 
235:     const inviteBudget = Math.min(
236:         calculateDynamicBudget(config.softInviteCap, config.hardInviteCap, dailyInvitesSent, riskSnapshot.action),
237:         weeklyRemaining
238:     );
239:     const messageBudget = calculateDynamicBudget(config.softMsgCap, config.hardMsgCap, dailyMessagesSent, riskSnapshot.action);
240: 
241:     let queuedInviteJobs = 0;
242:     let queuedCheckJobs = 0;
243:     let queuedMessageJobs = 0;
244:     await syncLeadListsFromLeads();
245:     let listConfigs = await listLeadCampaignConfigs(true);
246:     if (listConfigs.length === 0) {
247:         await ensureLeadList('default');
248:         listConfigs = await listLeadCampaignConfigs(true);
249:     }
250:     const activeListNames = listConfigs.length > 0
251:         ? listConfigs.map((list) => list.name)
252:         : await resolveActiveLists();
253:     const listBreakdown = initListBreakdown(activeListNames);
254:     const listConfigMap = new Map(listConfigs.map((list) => [list.name, list]));
255:     const statusRows = await getLeadStatusCountsForLists(activeListNames);
256:     const listStatusCounts = new Map<string, Record<string, number>>();
257:     for (const row of statusRows) {
258:         const statusName = row.status === 'PENDING' ? 'READY_INVITE' : row.status;
259:         if (!listStatusCounts.has(row.list_name)) {
260:             listStatusCounts.set(row.list_name, {});
261:         }
262:         const target = listStatusCounts.get(row.list_name);
263:         if (!target) continue;
264:         target[statusName] = (target[statusName] ?? 0) + row.total;
265:     }
266:     const adaptiveContextMap = new Map<string, AdaptiveBudgetContext>();
267:     for (const listName of activeListNames) {
268:         const statusCounts = listStatusCounts.get(listName) ?? {};
269:         const context = evaluateAdaptiveBudgetContext(statusCounts, riskSnapshot.action);
270:         adaptiveContextMap.set(listName, context);
271:         const breakdown = listBreakdown.get(listName);
272:         if (breakdown) {
273:             breakdown.adaptiveFactor = context.factor;
274:             breakdown.adaptiveReasons = context.reasons;
275:             breakdown.pendingRatio = context.pendingRatio;
276:             breakdown.blockedRatio = context.blockedRatio;
277:         }
278:     }
279:     const noBurstPlanner = !dryRun && config.noBurstEnabled ? createNoBurstPlanner() : null;
280: 
281:     if (!dryRun && riskSnapshot.action !== 'STOP') {
282:         await promoteNewLeadsToReadyInvite(config.hardInviteCap * 4);
283:     }
284: 
285:     if (workflow === 'all' || workflow === 'invite') {
286:         let remainingInviteBudget = inviteBudget;
287:         for (const listName of activeListNames) {
288:             if (remainingInviteBudget <= 0) break;
289:             const breakdown = listBreakdown.get(listName);
290:             if (!breakdown) continue;
291: 
292:             const listConfig = listConfigMap.get(listName);
293:             const listInvitesSent = await getListDailyStat(localDate, listName, 'invites_sent');
294:             const rawListBudget = computeListBudget(remainingInviteBudget, listConfig?.dailyInviteCap ?? null, listInvitesSent);
295:             const adaptive = adaptiveContextMap.get(listName);
296:             const listBudget = applyAdaptiveFactor(rawListBudget, adaptive?.factor ?? 1);
297:             breakdown.inviteBudget = listBudget;
298:             if (listBudget <= 0) continue;
299: 
300:             if (dryRun) {
301:                 const readyCandidates = await getLeadsByStatusForList('READY_INVITE', listName, listBudget);
302:                 const newCandidates = await getLeadsByStatusForList('NEW', listName, listBudget);
303:                 const candidateIds = new Set<number>();
304:                 for (const lead of readyCandidates) candidateIds.add(lead.id);
305:                 for (const lead of newCandidates) candidateIds.add(lead.id);
306:                 const planned = Math.min(listBudget, candidateIds.size);
307:                 breakdown.queuedInviteJobs += planned;
308:                 queuedInviteJobs += planned;
309:                 remainingInviteBudget -= planned;
310:                 continue;
311:             }
312: 
313:             const inviteCandidates = await getLeadsByStatusForList('READY_INVITE', listName, listBudget);
314: 
315:             let insertedForList = 0;
316:             for (const lead of inviteCandidates) {
317:                 const initialDelaySec = noBurstPlanner ? noBurstPlanner.nextDelaySec() : 0;
318:                 const inserted = await enqueueJob(
319:                     'INVITE',
320:                     { leadId: lead.id, localDate },
321:                     buildInviteKey(lead.id, localDate),
322:                     10,
323:                     config.retryMaxAttempts,
324:                     initialDelaySec
325:                 );
326:                 if (inserted) {
327:                     insertedForList += 1;
328:                     queuedInviteJobs += 1;
329:                     breakdown.maxScheduledDelaySec = Math.max(breakdown.maxScheduledDelaySec, initialDelaySec);
330:                 }
331:             }
332:             breakdown.queuedInviteJobs += insertedForList;
333:             remainingInviteBudget -= insertedForList;
334:         }
335:     }
336: 
337:     if (workflow === 'all' || workflow === 'check') {
338:         const checkLimitPerList = Math.max(25, config.hardInviteCap * 3);
339:         for (const listName of activeListNames) {
340:             const breakdown = listBreakdown.get(listName);
341:             if (!breakdown) continue;
342:             const invitedLeads = await getLeadsByStatusForList('INVITED', listName, checkLimitPerList);
343:             if (dryRun) {
344:                 breakdown.queuedCheckJobs += invitedLeads.length;
345:                 queuedCheckJobs += invitedLeads.length;
346:                 continue;
347:             }
348: 
349:             let insertedForList = 0;
350:             for (const lead of invitedLeads) {
351:                 const initialDelaySec = noBurstPlanner ? noBurstPlanner.nextDelaySec() : 0;
352:                 const inserted = await enqueueJob(
353:                     'ACCEPTANCE_CHECK',
354:                     { leadId: lead.id },
355:                     buildCheckKey(lead.id, localDate),
356:                     30,
357:                     config.retryMaxAttempts,
358:                     initialDelaySec
359:                 );
360:                 if (inserted) {
361:                     insertedForList += 1;
362:                     queuedCheckJobs += 1;
363:                     breakdown.maxScheduledDelaySec = Math.max(breakdown.maxScheduledDelaySec, initialDelaySec);
364:                 }
365:             }
366:             breakdown.queuedCheckJobs += insertedForList;
367:         }
368:     }
369: 
370:     if (workflow === 'all' || workflow === 'message') {
371:         let remainingMessageBudget = messageBudget;
372:         for (const listName of activeListNames) {
373:             if (remainingMessageBudget <= 0) break;
374:             const breakdown = listBreakdown.get(listName);
375:             if (!breakdown) continue;
376: 
377:             const listConfig = listConfigMap.get(listName);
378:             const listMessagesSent = await getListDailyStat(localDate, listName, 'messages_sent');
379:             const rawListBudget = computeListBudget(remainingMessageBudget, listConfig?.dailyMessageCap ?? null, listMessagesSent);
380:             const adaptive = adaptiveContextMap.get(listName);
381:             const listBudget = applyAdaptiveFactor(rawListBudget, adaptive?.factor ?? 1);
382:             breakdown.messageBudget = listBudget;
383:             if (listBudget <= 0) continue;
384: 
385:             if (dryRun) {
386:                 const accepted = await getLeadsByStatusForList('ACCEPTED', listName, listBudget);
387:                 const readyToMessage = await getLeadsByStatusForList('READY_MESSAGE', listName, listBudget);
388:                 const uniqueLeadIds = new Set<number>();
389:                 for (const lead of accepted) uniqueLeadIds.add(lead.id);
390:                 for (const lead of readyToMessage) uniqueLeadIds.add(lead.id);
391:                 const planned = Math.min(listBudget, uniqueLeadIds.size);
392:                 breakdown.queuedMessageJobs += planned;
393:                 queuedMessageJobs += planned;
394:                 remainingMessageBudget -= planned;
395:                 continue;
396:             }
397: 
398:             const accepted = await getLeadsByStatusForList('ACCEPTED', listName, Math.max(50, listBudget));
399:             for (const lead of accepted) {
400:                 await transitionLead(lead.id, 'READY_MESSAGE', 'scheduler_promote_to_ready_message');
401:             }
402:             const readyToMessage = await getLeadsByStatusForList('READY_MESSAGE', listName, listBudget);
403: 
404:             let insertedForList = 0;
405:             for (const lead of readyToMessage) {
406:                 const acceptedAtDate = lead.accepted_at ? lead.accepted_at.slice(0, 10) : localDate;
407:                 const initialDelaySec = noBurstPlanner ? noBurstPlanner.nextDelaySec() : 0;
408:                 const inserted = await enqueueJob(
409:                     'MESSAGE',
410:                     { leadId: lead.id, acceptedAtDate },
411:                     buildMessageKey(lead.id, acceptedAtDate),
412:                     20,
413:                     config.retryMaxAttempts,
414:                     initialDelaySec
415:                 );
416:                 if (inserted) {
417:                     insertedForList += 1;
418:                     queuedMessageJobs += 1;
419:                     breakdown.maxScheduledDelaySec = Math.max(breakdown.maxScheduledDelaySec, initialDelaySec);
420:                 }
421:             }
422:             breakdown.queuedMessageJobs += insertedForList;
423:             remainingMessageBudget -= insertedForList;
424:         }
425:     }
426: 
427:     return {
428:         localDate,
429:         riskSnapshot,
430:         inviteBudget,
431:         messageBudget,
432:         queuedInviteJobs,
433:         queuedCheckJobs,
434:         queuedMessageJobs,
435:         listBreakdown: Array.from(listBreakdown.values()),
436:         dryRun,
437:     };
438: }
````

## File: src/csvImporter.ts
````typescript
  1: import fs from 'fs';
  2: import csv from 'csv-parser';
  3: import { addCompanyTarget, addLead } from './core/repositories';
  4: import { isLinkedInUrl, normalizeLinkedInUrl } from './linkedinUrl';
  5: 
  6: export interface ImportResult {
  7:     inserted: number;
  8:     companyTargetsInserted: number;
  9:     skipped: number;
 10: }
 11: 
 12: /**
 13:  * Legge un valore da un record CSV provando più possibili nomi di colonna in ordine.
 14:  */
 15: function pickField(row: Record<string, string>, ...keys: string[]): string {
 16:     for (const key of keys) {
 17:         const val = row[key];
 18:         if (val && val.trim()) {
 19:             return val.trim();
 20:         }
 21:     }
 22:     return '';
 23: }
 24: 
 25: function normalizeWebsite(raw: string): string {
 26:     const trimmed = raw.trim();
 27:     if (!trimmed) return '';
 28:     if (/^https?:\/\//i.test(trimmed)) return trimmed;
 29:     if (trimmed.includes('.') && !trimmed.includes(' ')) {
 30:         return `https://${trimmed}`;
 31:     }
 32:     return trimmed;
 33: }
 34: 
 35: export async function importLeadsFromCSV(filePath: string, listName: string): Promise<ImportResult> {
 36:     const rows: Array<Record<string, string>> = [];
 37: 
 38:     await new Promise<void>((resolve, reject) => {
 39:         fs.createReadStream(filePath)
 40:             .pipe(csv())
 41:             .on('data', (row: Record<string, string>) => rows.push(row))
 42:             .on('end', resolve)
 43:             .on('error', reject);
 44:     });
 45: 
 46:     let inserted = 0;
 47:     let companyTargetsInserted = 0;
 48:     let skipped = 0;
 49: 
 50:     for (const row of rows) {
 51:         // LinkedIn URL — Sales Navigator e formati alternativi
 52:         const lnUrlRaw = pickField(
 53:             row,
 54:             'linkedin_url',
 55:             'LinkedIn URL',
 56:             'linkedinUrl',
 57:             'LinkedIn Profile URL',
 58:             'Profile URL',
 59:             'Linkedin',
 60:             'Person Linkedin Url',
 61:             'Contact LinkedIn URL'
 62:         );
 63: 
 64:         const linkedinUrl = normalizeLinkedInUrl(lnUrlRaw.trim());
 65: 
 66:         // Sales Navigator: "First Name" e "Last Name" separati
 67:         const firstName = pickField(row, 'First Name', 'first_name', 'FirstName');
 68:         const lastName = pickField(row, 'Last Name', 'last_name', 'LastName');
 69: 
 70:         // Nome account / azienda
 71:         const accountName = pickField(
 72:             row,
 73:             'Account Name', 'account_name', 'Company', 'Company Name', 'company_name',
 74:             'companyName', 'Organization'
 75:         );
 76: 
 77:         // Se non abbiamo accountName esplicito, lo costruiamo da first+last
 78:         const resolvedAccountName = accountName || [firstName, lastName].filter(Boolean).join(' ');
 79: 
 80:         const jobTitle = pickField(row, 'Title', 'Job Title', 'job_title', 'Position');
 81:         const website = normalizeWebsite(
 82:             pickField(
 83:                 row,
 84:                 'Website',
 85:                 'website',
 86:                 'Company Website',
 87:                 'Company Domain',
 88:                 'domain'
 89:             )
 90:         );
 91: 
 92:         if (!linkedinUrl || !isLinkedInUrl(linkedinUrl)) {
 93:             const insertedCompanyTarget = await addCompanyTarget({
 94:                 listName,
 95:                 accountName: resolvedAccountName,
 96:                 website,
 97:                 sourceFile: filePath,
 98:             });
 99:             if (insertedCompanyTarget) {
100:                 companyTargetsInserted += 1;
101:             } else {
102:                 skipped += 1;
103:             }
104:             continue;
105:         }
106: 
107:         const isNew = await addLead({
108:             accountName: resolvedAccountName,
109:             firstName,
110:             lastName,
111:             jobTitle,
112:             website,
113:             linkedinUrl,
114:             listName,
115:         });
116: 
117:         if (isNew) {
118:             inserted += 1;
119:         } else {
120:             skipped += 1;
121:         }
122:     }
123: 
124:     return { inserted, companyTargetsInserted, skipped };
125: }
````

## File: src/db.ts
````typescript
  1: import sqlite3 from 'sqlite3';
  2: import { open, Database } from 'sqlite';
  3: import path from 'path';
  4: import fs from 'fs';
  5: import { config } from './config';
  6: import { ensureFilePrivate, ensureParentDirectoryPrivate } from './security/filesystem';
  7: 
  8: let db: Database | null = null;
  9: 
 10: function resolveMigrationDirectory(): string {
 11:     const cwdMigrations = path.resolve(process.cwd(), 'src', 'db', 'migrations');
 12:     if (fs.existsSync(cwdMigrations)) {
 13:         return cwdMigrations;
 14:     }
 15:     const compiledMigrations = path.resolve(__dirname, 'db', 'migrations');
 16:     if (fs.existsSync(compiledMigrations)) {
 17:         return compiledMigrations;
 18:     }
 19:     throw new Error('Cartella migrazioni non trovata.');
 20: }
 21: 
 22: async function ensureColumn(database: Database, tableName: string, columnName: string, definition: string): Promise<void> {
 23:     const columns = await database.all<{ name: string }[]>(`PRAGMA table_info(${tableName})`);
 24:     const exists = columns.some((column) => column.name === columnName);
 25:     if (!exists) {
 26:         await database.exec(`ALTER TABLE ${tableName} ADD COLUMN ${columnName} ${definition}`);
 27:     }
 28: }
 29: 
 30: async function applyMigrations(database: Database): Promise<void> {
 31:     await database.exec(`
 32:         CREATE TABLE IF NOT EXISTS _migrations (
 33:             id INTEGER PRIMARY KEY AUTOINCREMENT,
 34:             name TEXT NOT NULL UNIQUE,
 35:             applied_at DATETIME DEFAULT CURRENT_TIMESTAMP
 36:         );
 37:     `);
 38: 
 39:     const migrationDir = resolveMigrationDirectory();
 40:     const files = fs
 41:         .readdirSync(migrationDir)
 42:         .filter((file) => file.endsWith('.sql'))
 43:         .sort((a, b) => a.localeCompare(b));
 44: 
 45:     for (const fileName of files) {
 46:         const alreadyApplied = await database.get<{ count: number }>(
 47:             `SELECT COUNT(*) as count FROM _migrations WHERE name = ?`,
 48:             [fileName]
 49:         );
 50:         if ((alreadyApplied?.count ?? 0) > 0) {
 51:             continue;
 52:         }
 53: 
 54:         const sql = fs.readFileSync(path.join(migrationDir, fileName), 'utf8');
 55:         await database.exec('BEGIN');
 56:         try {
 57:             await database.exec(sql);
 58:             await database.run(`INSERT INTO _migrations (name) VALUES (?)`, [fileName]);
 59:             await database.exec('COMMIT');
 60:         } catch (error) {
 61:             await database.exec('ROLLBACK');
 62:             throw error;
 63:         }
 64:     }
 65: 
 66:     // Hardening per DB già esistenti creati prima del sistema migrazioni.
 67:     await ensureColumn(database, 'leads', 'list_name', `TEXT NOT NULL DEFAULT 'default'`);
 68:     await ensureColumn(database, 'leads', 'last_error', 'TEXT');
 69:     await ensureColumn(database, 'leads', 'blocked_reason', 'TEXT');
 70:     await ensureColumn(database, 'leads', 'updated_at', 'DATETIME DEFAULT CURRENT_TIMESTAMP');
 71:     await ensureColumn(database, 'lead_lists', 'is_active', 'INTEGER NOT NULL DEFAULT 1');
 72:     await ensureColumn(database, 'lead_lists', 'priority', 'INTEGER NOT NULL DEFAULT 100');
 73:     await ensureColumn(database, 'lead_lists', 'daily_invite_cap', 'INTEGER');
 74:     await ensureColumn(database, 'lead_lists', 'daily_message_cap', 'INTEGER');
 75:     await ensureColumn(database, 'daily_stats', 'messages_sent', 'INTEGER NOT NULL DEFAULT 0');
 76:     await ensureColumn(database, 'daily_stats', 'challenges_count', 'INTEGER NOT NULL DEFAULT 0');
 77:     await ensureColumn(database, 'daily_stats', 'selector_failures', 'INTEGER NOT NULL DEFAULT 0');
 78:     await ensureColumn(database, 'daily_stats', 'run_errors', 'INTEGER NOT NULL DEFAULT 0');
 79:     await database.exec(`
 80:         CREATE TABLE IF NOT EXISTS list_daily_stats (
 81:             date TEXT NOT NULL,
 82:             list_name TEXT NOT NULL,
 83:             invites_sent INTEGER NOT NULL DEFAULT 0,
 84:             messages_sent INTEGER NOT NULL DEFAULT 0,
 85:             PRIMARY KEY (date, list_name)
 86:         );
 87:     `);
 88:     await database.exec(`CREATE INDEX IF NOT EXISTS idx_list_daily_stats_list_date ON list_daily_stats(list_name, date);`);
 89:     await database.exec(`CREATE INDEX IF NOT EXISTS idx_leads_status_list_created ON leads(status, list_name, created_at);`);
 90:     await database.exec(`CREATE INDEX IF NOT EXISTS idx_jobs_type_status_next_run ON jobs(type, status, next_run_at, priority, created_at);`);
 91:     await database.exec(`
 92:         CREATE TABLE IF NOT EXISTS company_targets (
 93:             id INTEGER PRIMARY KEY AUTOINCREMENT,
 94:             list_name TEXT NOT NULL,
 95:             account_name TEXT NOT NULL DEFAULT '',
 96:             website TEXT NOT NULL DEFAULT '',
 97:             source_file TEXT,
 98:             status TEXT NOT NULL DEFAULT 'NEW',
 99:             created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
100:             updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
101:         );
102:     `);
103:     await ensureColumn(database, 'company_targets', 'attempts', 'INTEGER NOT NULL DEFAULT 0');
104:     await ensureColumn(database, 'company_targets', 'last_error', 'TEXT');
105:     await ensureColumn(database, 'company_targets', 'processed_at', 'DATETIME');
106:     await database.exec(`
107:         CREATE UNIQUE INDEX IF NOT EXISTS uq_company_targets_list_account_website
108:             ON company_targets(list_name, account_name, website);
109:     `);
110:     await database.exec(`
111:         CREATE INDEX IF NOT EXISTS idx_company_targets_list_status
112:             ON company_targets(list_name, status, created_at);
113:     `);
114:     await database.exec(`
115:         CREATE TABLE IF NOT EXISTS runtime_locks (
116:             lock_key TEXT PRIMARY KEY,
117:             owner_id TEXT NOT NULL,
118:             acquired_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
119:             heartbeat_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
120:             expires_at DATETIME NOT NULL,
121:             metadata_json TEXT NOT NULL DEFAULT '{}',
122:             updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
123:         );
124:     `);
125:     await database.exec(`CREATE INDEX IF NOT EXISTS idx_runtime_locks_expires_at ON runtime_locks(expires_at);`);
126: }
127: 
128: export async function getDatabase(): Promise<Database> {
129:     if (db) return db;
130: 
131:     ensureParentDirectoryPrivate(config.dbPath);
132: 
133:     db = await open({
134:         filename: config.dbPath,
135:         driver: sqlite3.Database,
136:     });
137: 
138:     await db.exec(`PRAGMA journal_mode = WAL;`);
139:     await db.exec(`PRAGMA busy_timeout = 5000;`);
140:     await db.exec(`PRAGMA synchronous = NORMAL;`);
141:     ensureFilePrivate(config.dbPath);
142: 
143:     return db;
144: }
145: 
146: export async function initDatabase(): Promise<void> {
147:     const database = await getDatabase();
148:     await applyMigrations(database);
149: }
150: 
151: export async function closeDatabase(): Promise<void> {
152:     if (db) {
153:         await db.close();
154:         db = null;
155:     }
156: }
````

## File: src/db/migrations/001_core.sql
````sql
  1: CREATE TABLE IF NOT EXISTS _migrations (
  2:     id INTEGER PRIMARY KEY AUTOINCREMENT,
  3:     name TEXT NOT NULL UNIQUE,
  4:     applied_at DATETIME DEFAULT CURRENT_TIMESTAMP
  5: );
  6: 
  7: CREATE TABLE IF NOT EXISTS leads (
  8:     id INTEGER PRIMARY KEY AUTOINCREMENT,
  9:     account_name TEXT NOT NULL DEFAULT '',
 10:     website TEXT NOT NULL DEFAULT '',
 11:     linkedin_url TEXT NOT NULL UNIQUE,
 12:     status TEXT NOT NULL DEFAULT 'NEW',
 13:     list_name TEXT NOT NULL DEFAULT 'default',
 14:     invited_at DATETIME,
 15:     accepted_at DATETIME,
 16:     messaged_at DATETIME,
 17:     last_error TEXT,
 18:     blocked_reason TEXT,
 19:     created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
 20:     updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
 21: );
 22: 
 23: CREATE TABLE IF NOT EXISTS lead_lists (
 24:     id INTEGER PRIMARY KEY AUTOINCREMENT,
 25:     name TEXT NOT NULL UNIQUE,
 26:     source TEXT NOT NULL DEFAULT 'manual',
 27:     created_at DATETIME DEFAULT CURRENT_TIMESTAMP
 28: );
 29: 
 30: CREATE TABLE IF NOT EXISTS list_leads (
 31:     list_id INTEGER NOT NULL,
 32:     lead_id INTEGER NOT NULL,
 33:     created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
 34:     PRIMARY KEY (list_id, lead_id),
 35:     FOREIGN KEY (list_id) REFERENCES lead_lists(id),
 36:     FOREIGN KEY (lead_id) REFERENCES leads(id)
 37: );
 38: 
 39: CREATE TABLE IF NOT EXISTS daily_stats (
 40:     date TEXT PRIMARY KEY,
 41:     invites_sent INTEGER NOT NULL DEFAULT 0,
 42:     messages_sent INTEGER NOT NULL DEFAULT 0,
 43:     challenges_count INTEGER NOT NULL DEFAULT 0,
 44:     selector_failures INTEGER NOT NULL DEFAULT 0,
 45:     run_errors INTEGER NOT NULL DEFAULT 0
 46: );
 47: 
 48: CREATE TABLE IF NOT EXISTS jobs (
 49:     id INTEGER PRIMARY KEY AUTOINCREMENT,
 50:     type TEXT NOT NULL,
 51:     status TEXT NOT NULL DEFAULT 'QUEUED',
 52:     payload_json TEXT NOT NULL,
 53:     idempotency_key TEXT NOT NULL UNIQUE,
 54:     priority INTEGER NOT NULL DEFAULT 100,
 55:     attempts INTEGER NOT NULL DEFAULT 0,
 56:     max_attempts INTEGER NOT NULL DEFAULT 3,
 57:     next_run_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
 58:     locked_at DATETIME,
 59:     last_error TEXT,
 60:     created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
 61:     updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
 62: );
 63: 
 64: CREATE TABLE IF NOT EXISTS job_attempts (
 65:     id INTEGER PRIMARY KEY AUTOINCREMENT,
 66:     job_id INTEGER NOT NULL,
 67:     started_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
 68:     finished_at DATETIME,
 69:     success INTEGER NOT NULL DEFAULT 0,
 70:     error_code TEXT,
 71:     error_message TEXT,
 72:     evidence_path TEXT,
 73:     FOREIGN KEY (job_id) REFERENCES jobs(id)
 74: );
 75: 
 76: CREATE TABLE IF NOT EXISTS lead_events (
 77:     id INTEGER PRIMARY KEY AUTOINCREMENT,
 78:     lead_id INTEGER NOT NULL,
 79:     from_status TEXT NOT NULL,
 80:     to_status TEXT NOT NULL,
 81:     reason TEXT NOT NULL,
 82:     metadata_json TEXT NOT NULL DEFAULT '{}',
 83:     created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
 84:     FOREIGN KEY (lead_id) REFERENCES leads(id)
 85: );
 86: 
 87: CREATE TABLE IF NOT EXISTS account_incidents (
 88:     id INTEGER PRIMARY KEY AUTOINCREMENT,
 89:     type TEXT NOT NULL,
 90:     severity TEXT NOT NULL DEFAULT 'WARN',
 91:     status TEXT NOT NULL DEFAULT 'OPEN',
 92:     details_json TEXT NOT NULL DEFAULT '{}',
 93:     opened_at DATETIME DEFAULT CURRENT_TIMESTAMP,
 94:     acknowledged_at DATETIME,
 95:     resolved_at DATETIME
 96: );
 97: 
 98: CREATE TABLE IF NOT EXISTS outbox_events (
 99:     id INTEGER PRIMARY KEY AUTOINCREMENT,
100:     topic TEXT NOT NULL,
101:     payload_json TEXT NOT NULL,
102:     idempotency_key TEXT NOT NULL UNIQUE,
103:     attempts INTEGER NOT NULL DEFAULT 0,
104:     next_retry_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
105:     delivered_at DATETIME,
106:     last_error TEXT,
107:     created_at DATETIME DEFAULT CURRENT_TIMESTAMP
108: );
109: 
110: CREATE TABLE IF NOT EXISTS sync_state (
111:     key TEXT PRIMARY KEY,
112:     value TEXT NOT NULL,
113:     updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
114: );
115: 
116: CREATE TABLE IF NOT EXISTS message_history (
117:     id INTEGER PRIMARY KEY AUTOINCREMENT,
118:     lead_id INTEGER NOT NULL,
119:     content_hash TEXT NOT NULL,
120:     sent_at DATETIME DEFAULT CURRENT_TIMESTAMP,
121:     FOREIGN KEY (lead_id) REFERENCES leads(id)
122: );
123: 
124: CREATE TABLE IF NOT EXISTS run_logs (
125:     id INTEGER PRIMARY KEY AUTOINCREMENT,
126:     level TEXT NOT NULL,
127:     event TEXT NOT NULL,
128:     payload_json TEXT NOT NULL DEFAULT '{}',
129:     created_at DATETIME DEFAULT CURRENT_TIMESTAMP
130: );
131: 
132: CREATE INDEX IF NOT EXISTS idx_leads_status ON leads(status);
133: CREATE INDEX IF NOT EXISTS idx_jobs_status_next_run ON jobs(status, next_run_at);
134: CREATE INDEX IF NOT EXISTS idx_job_attempts_job_id ON job_attempts(job_id);
135: CREATE INDEX IF NOT EXISTS idx_outbox_pending ON outbox_events(delivered_at, next_retry_at);
136: CREATE INDEX IF NOT EXISTS idx_message_history_hash_sent_at ON message_history(content_hash, sent_at);
````

## File: src/db/migrations/002_legacy_status_backfill.sql
````sql
1: UPDATE leads
2: SET status = 'READY_INVITE',
3:     updated_at = CURRENT_TIMESTAMP
4: WHERE status = 'PENDING';
````

## File: src/db/migrations/003_add_person_fields.sql
````sql
1: -- Aggiunge campi persona (nome/cognome) alla tabella leads.
2: -- Sales Navigator esporta First Name e Last Name separatamente.
3: ALTER TABLE leads ADD COLUMN first_name TEXT NOT NULL DEFAULT '';
4: ALTER TABLE leads ADD COLUMN last_name  TEXT NOT NULL DEFAULT '';
5: ALTER TABLE leads ADD COLUMN job_title  TEXT NOT NULL DEFAULT '';
````

## File: src/db/migrations/004_list_campaign_controls.sql
````sql
 1: -- Controlli campagna per lista Sales Navigator.
 2: ALTER TABLE lead_lists ADD COLUMN is_active INTEGER NOT NULL DEFAULT 1;
 3: ALTER TABLE lead_lists ADD COLUMN priority INTEGER NOT NULL DEFAULT 100;
 4: ALTER TABLE lead_lists ADD COLUMN daily_invite_cap INTEGER;
 5: ALTER TABLE lead_lists ADD COLUMN daily_message_cap INTEGER;
 6: 
 7: CREATE TABLE IF NOT EXISTS list_daily_stats (
 8:     date TEXT NOT NULL,
 9:     list_name TEXT NOT NULL,
10:     invites_sent INTEGER NOT NULL DEFAULT 0,
11:     messages_sent INTEGER NOT NULL DEFAULT 0,
12:     PRIMARY KEY (date, list_name)
13: );
14: 
15: CREATE INDEX IF NOT EXISTS idx_list_daily_stats_list_date
16:     ON list_daily_stats(list_name, date);
````

## File: src/db/migrations/005_performance_indexes.sql
````sql
1: -- Indici per scheduler/worker su database con molti lead.
2: CREATE INDEX IF NOT EXISTS idx_leads_status_list_created
3:     ON leads(status, list_name, created_at);
4: 
5: CREATE INDEX IF NOT EXISTS idx_jobs_type_status_next_run
6:     ON jobs(type, status, next_run_at, priority, created_at);
````

## File: src/db/migrations/006_company_targets.sql
````sql
 1: CREATE TABLE IF NOT EXISTS company_targets (
 2:     id INTEGER PRIMARY KEY AUTOINCREMENT,
 3:     list_name TEXT NOT NULL,
 4:     account_name TEXT NOT NULL DEFAULT '',
 5:     website TEXT NOT NULL DEFAULT '',
 6:     source_file TEXT,
 7:     status TEXT NOT NULL DEFAULT 'NEW',
 8:     created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
 9:     updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
10: );
11: 
12: CREATE UNIQUE INDEX IF NOT EXISTS uq_company_targets_list_account_website
13:     ON company_targets(list_name, account_name, website);
14: 
15: CREATE INDEX IF NOT EXISTS idx_company_targets_list_status
16:     ON company_targets(list_name, status, created_at);
````

## File: src/db/migrations/007_company_target_tracking.sql
````sql
1: ALTER TABLE company_targets ADD COLUMN attempts INTEGER NOT NULL DEFAULT 0;
2: ALTER TABLE company_targets ADD COLUMN last_error TEXT;
3: ALTER TABLE company_targets ADD COLUMN processed_at DATETIME;
````

## File: src/db/migrations/008_runtime_locks.sql
````sql
 1: CREATE TABLE IF NOT EXISTS runtime_locks (
 2:     lock_key TEXT PRIMARY KEY,
 3:     owner_id TEXT NOT NULL,
 4:     acquired_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
 5:     heartbeat_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
 6:     expires_at DATETIME NOT NULL,
 7:     metadata_json TEXT NOT NULL DEFAULT '{}',
 8:     updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
 9: );
10: 
11: CREATE INDEX IF NOT EXISTS idx_runtime_locks_expires_at
12:     ON runtime_locks(expires_at);
````

## File: src/index.ts
````typescript
  1: import { closeDatabase, initDatabase } from './db';
  2: import { config, getLocalDateString } from './config';
  3: import { checkLogin, closeBrowser as closeBrowserSession, detectChallenge, humanDelay, isLoggedIn, launchBrowser } from './browser';
  4: import { randomUUID } from 'crypto';
  5: import { importLeadsFromCSV } from './csvImporter';
  6: import { buildFunnelReport, runSiteCheck } from './core/audit';
  7: import { runCompanyEnrichmentBatch } from './core/companyEnrichment';
  8: import { runWorkflow } from './core/orchestrator';
  9: import { runDoctor } from './core/doctor';
 10: import { reconcileLeadStatus } from './core/leadStateService';
 11: import {
 12:     acquireRuntimeLock,
 13:     cleanupPrivacyData,
 14:     countCompanyTargets,
 15:     getAutomationPauseState,
 16:     getDailyStatsSnapshot,
 17:     getJobStatusCounts,
 18:     getRuntimeLock,
 19:     getRuntimeFlag,
 20:     getLeadsWithSalesNavigatorUrls,
 21:     heartbeatRuntimeLock,
 22:     listCompanyTargets,
 23:     listLeadCampaignConfigs,
 24:     listOpenIncidents,
 25:     releaseRuntimeLock,
 26:     recoverStuckJobs,
 27:     resolveIncident,
 28:     clearAutomationPause as clearPauseState,
 29:     setAutomationPause,
 30:     setRuntimeFlag,
 31:     updateLeadLinkedinUrl,
 32:     updateLeadCampaignConfig,
 33: } from './core/repositories';
 34: import { setQuarantine } from './risk/incidentManager';
 35: import { getEventSyncStatus, runEventSyncOnce } from './sync/eventSync';
 36: import { WorkflowSelection } from './core/scheduler';
 37: import { isProfileUrl, isSalesNavigatorUrl, normalizeLinkedInUrl } from './linkedinUrl';
 38: import { Page } from 'playwright';
 39: 
 40: // Graceful shutdown: chiude DB prima di uscire per non lasciare job RUNNING.
 41: let shuttingDown = false;
 42: function setupGracefulShutdown(): void {
 43:     const handler = async (signal: string): Promise<void> => {
 44:         if (shuttingDown) return;
 45:         shuttingDown = true;
 46:         console.warn(`[SIGNAL] ${signal} ricevuto — chiusura in corso...`);
 47:         await closeDatabase();
 48:         process.exit(0);
 49:     };
 50:     process.on('SIGINT', () => { void handler('SIGINT'); });
 51:     process.on('SIGTERM', () => { void handler('SIGTERM'); });
 52: }
 53: 
 54: function getOptionValue(args: string[], optionName: string): string | undefined {
 55:     const index = args.findIndex((value) => value === optionName);
 56:     if (index === -1 || index + 1 >= args.length) {
 57:         return undefined;
 58:     }
 59:     return args[index + 1];
 60: }
 61: 
 62: function hasOption(args: string[], optionName: string): boolean {
 63:     return args.includes(optionName);
 64: }
 65: 
 66: function parseWorkflow(input: string | undefined): WorkflowSelection {
 67:     if (input === 'invite' || input === 'check' || input === 'message' || input === 'all') {
 68:         return input;
 69:     }
 70:     return 'all';
 71: }
 72: 
 73: function parseIntStrict(raw: string, optionName: string): number {
 74:     const parsed = Number.parseInt(raw, 10);
 75:     if (!Number.isFinite(parsed)) {
 76:         throw new Error(`Valore non valido per ${optionName}: ${raw}`);
 77:     }
 78:     return parsed;
 79: }
 80: 
 81: function parseNullableCap(raw: string, optionName: string): number | null {
 82:     const normalized = raw.trim().toLowerCase();
 83:     if (normalized === 'none' || normalized === 'null' || normalized === 'off' || normalized === '-1') {
 84:         return null;
 85:     }
 86:     const parsed = parseIntStrict(raw, optionName);
 87:     if (parsed < 0) {
 88:         throw new Error(`${optionName} deve essere >= 0 oppure none/null/off.`);
 89:     }
 90:     return parsed;
 91: }
 92: 
 93: function parsePauseMinutes(raw: string, optionName: string): number | null {
 94:     const normalized = raw.trim().toLowerCase();
 95:     if (normalized === 'none' || normalized === 'null' || normalized === 'off' || normalized === 'indefinite') {
 96:         return null;
 97:     }
 98:     const parsed = parseIntStrict(raw, optionName);
 99:     if (parsed < 1) {
100:         throw new Error(`${optionName} deve essere >= 1 oppure none/null/off/indefinite.`);
101:     }
102:     return parsed;
103: }
104: 
105: function parseBoolStrict(raw: string, optionName: string): boolean {
106:     const normalized = raw.trim().toLowerCase();
107:     if (normalized === 'true' || normalized === '1' || normalized === 'yes') return true;
108:     if (normalized === 'false' || normalized === '0' || normalized === 'no') return false;
109:     throw new Error(`Valore non valido per ${optionName}: ${raw} (usa true/false).`);
110: }
111: 
112: function getWorkflowValue(args: string[]): string | undefined {
113:     const explicit = getOptionValue(args, '--workflow');
114:     if (explicit) {
115:         return explicit;
116:     }
117:     const positional = args.find((value) => !value.startsWith('--'));
118:     return positional;
119: }
120: 
121: function getPositionalArgs(args: string[]): string[] {
122:     return args.filter((value) => !value.startsWith('--'));
123: }
124: 
125: function sleep(ms: number): Promise<void> {
126:     return new Promise((resolve) => setTimeout(resolve, ms));
127: }
128: 
129: interface SalesNavResolveItem {
130:     leadId: number;
131:     status: string;
132:     currentUrl: string;
133:     resolvedProfileUrl: string | null;
134:     action: 'resolved' | 'updated' | 'conflict' | 'unresolved' | 'challenge_detected' | 'error';
135:     conflictLeadId?: number | null;
136:     error?: string;
137: }
138: 
139: interface SalesNavResolveReport {
140:     scanned: number;
141:     resolvable: number;
142:     updated: number;
143:     conflicts: number;
144:     unresolved: number;
145:     challengeDetected: boolean;
146:     fix: boolean;
147:     dryRun: boolean;
148:     items: SalesNavResolveItem[];
149: }
150: 
151: async function collectProfileUrlCandidates(page: Page): Promise<string[]> {
152:     const candidates = new Set<string>();
153: 
154:     const currentUrl = page.url();
155:     if (currentUrl) candidates.add(currentUrl);
156: 
157:     const canonicalHref = await page.locator('link[rel="canonical"]').first().getAttribute('href').catch(() => null);
158:     if (canonicalHref) candidates.add(canonicalHref);
159: 
160:     const ogUrl = await page.locator('meta[property="og:url"]').first().getAttribute('content').catch(() => null);
161:     if (ogUrl) candidates.add(ogUrl);
162: 
163:     const anchors = await page.evaluate(() => {
164:         return Array.from(document.querySelectorAll('a[href]'))
165:             .map((node) => (node as HTMLAnchorElement).href)
166:             .filter((href) => typeof href === 'string' && href.length > 0);
167:     }).catch(() => [] as string[]);
168: 
169:     for (const href of anchors) {
170:         candidates.add(href);
171:     }
172: 
173:     return Array.from(candidates);
174: }
175: 
176: function pickResolvedProfileUrl(candidates: string[]): string | null {
177:     for (const candidate of candidates) {
178:         const normalized = normalizeLinkedInUrl(candidate);
179:         if (!isProfileUrl(normalized)) continue;
180:         if (isSalesNavigatorUrl(normalized)) continue;
181:         return normalized;
182:     }
183:     return null;
184: }
185: 
186: function getRecoveryStatusFromBlockedReason(reason: string | null): 'READY_INVITE' | 'INVITED' | 'READY_MESSAGE' | null {
187:     const normalized = (reason ?? '').toLowerCase();
188:     if (normalized.includes('salesnav_url_requires_profile_invite')) {
189:         return 'READY_INVITE';
190:     }
191:     if (normalized.includes('salesnav_url_requires_profile_check')) {
192:         return 'INVITED';
193:     }
194:     if (normalized.includes('salesnav_url_requires_profile_message')) {
195:         return 'READY_MESSAGE';
196:     }
197:     return null;
198: }
199: 
200: const WORKFLOW_RUNNER_LOCK_KEY = 'workflow.runner';
201: const WORKFLOW_RUNNER_MIN_TTL_SECONDS = 120;
202: const WORKFLOW_RUNNER_HEARTBEAT_MS = 30_000;
203: const AUTO_SITE_CHECK_LAST_RUN_KEY = 'site_check.last_run_at';
204: 
205: function createLockOwnerId(command: string): string {
206:     const suffix = randomUUID().split('-')[0];
207:     return `${command}:${process.pid}:${suffix}`;
208: }
209: 
210: function computeWorkflowLockTtlSeconds(intervalMs: number): number {
211:     return Math.max(WORKFLOW_RUNNER_MIN_TTL_SECONDS, Math.ceil(intervalMs / 1000) + 120);
212: }
213: 
214: async function acquireWorkflowRunnerLock(command: string, ttlSeconds: number, metadata: Record<string, unknown>): Promise<string> {
215:     const ownerId = createLockOwnerId(command);
216:     const result = await acquireRuntimeLock(WORKFLOW_RUNNER_LOCK_KEY, ownerId, ttlSeconds, metadata);
217:     if (!result.acquired) {
218:         const holder = result.lock;
219:         throw new Error(
220:             `[LOCK] Runner già attivo. owner=${holder?.owner_id ?? 'unknown'} heartbeat=${holder?.heartbeat_at ?? 'n/a'} expires=${holder?.expires_at ?? 'n/a'}`
221:         );
222:     }
223:     console.log(`[LOCK] acquired key=${WORKFLOW_RUNNER_LOCK_KEY} owner=${ownerId} ttl=${ttlSeconds}s`);
224:     return ownerId;
225: }
226: 
227: async function heartbeatWorkflowRunnerLock(ownerId: string, ttlSeconds: number): Promise<void> {
228:     const ok = await heartbeatRuntimeLock(WORKFLOW_RUNNER_LOCK_KEY, ownerId, ttlSeconds);
229:     if (!ok) {
230:         throw new Error('[LOCK] Runtime lock perso durante l\'esecuzione.');
231:     }
232: }
233: 
234: async function releaseWorkflowRunnerLock(ownerId: string): Promise<void> {
235:     const released = await releaseRuntimeLock(WORKFLOW_RUNNER_LOCK_KEY, ownerId);
236:     console.log(`[LOCK] released key=${WORKFLOW_RUNNER_LOCK_KEY} owner=${ownerId} released=${released}`);
237: }
238: 
239: async function sleepWithLockHeartbeat(totalMs: number, ownerId: string, ttlSeconds: number): Promise<void> {
240:     let remaining = Math.max(0, totalMs);
241:     while (remaining > 0) {
242:         const chunk = Math.min(WORKFLOW_RUNNER_HEARTBEAT_MS, remaining);
243:         await sleep(chunk);
244:         remaining -= chunk;
245:         if (remaining > 0) {
246:             await heartbeatWorkflowRunnerLock(ownerId, ttlSeconds);
247:         }
248:     }
249: }
250: 
251: interface LoopDoctorGate {
252:     proceed: boolean;
253:     reason: string;
254: }
255: 
256: interface AutoSiteCheckDecision {
257:     shouldRun: boolean;
258:     reason: string;
259:     hoursSinceLastRun: number | null;
260: }
261: 
262: async function evaluateAutoSiteCheckDecision(dryRun: boolean): Promise<AutoSiteCheckDecision> {
263:     if (dryRun) {
264:         return { shouldRun: false, reason: 'dry_run', hoursSinceLastRun: null };
265:     }
266:     if (!config.autoSiteCheckEnabled) {
267:         return { shouldRun: false, reason: 'auto_site_check_disabled', hoursSinceLastRun: null };
268:     }
269: 
270:     const lastRunRaw = await getRuntimeFlag(AUTO_SITE_CHECK_LAST_RUN_KEY);
271:     if (!lastRunRaw) {
272:         return { shouldRun: true, reason: 'never_run', hoursSinceLastRun: null };
273:     }
274: 
275:     const parsedMs = Date.parse(lastRunRaw);
276:     if (!Number.isFinite(parsedMs)) {
277:         return { shouldRun: true, reason: 'invalid_last_run', hoursSinceLastRun: null };
278:     }
279: 
280:     const elapsedHours = (Date.now() - parsedMs) / (1000 * 60 * 60);
281:     if (elapsedHours >= config.autoSiteCheckIntervalHours) {
282:         return {
283:             shouldRun: true,
284:             reason: 'interval_elapsed',
285:             hoursSinceLastRun: Number.parseFloat(elapsedHours.toFixed(2)),
286:         };
287:     }
288: 
289:     return {
290:         shouldRun: false,
291:         reason: 'interval_not_elapsed',
292:         hoursSinceLastRun: Number.parseFloat(elapsedHours.toFixed(2)),
293:     };
294: }
295: 
296: async function evaluateLoopDoctorGate(dryRun: boolean): Promise<LoopDoctorGate> {
297:     if (dryRun) {
298:         return { proceed: true, reason: 'dry_run' };
299:     }
300: 
301:     const report = await runDoctor();
302:     const syncOk = !report.sync.enabled || report.sync.configured;
303:     if (!report.sessionLoginOk) {
304:         return { proceed: false, reason: 'doctor_login_missing' };
305:     }
306:     if (report.quarantine) {
307:         return { proceed: false, reason: 'doctor_quarantine_active' };
308:     }
309:     if (!syncOk) {
310:         return { proceed: false, reason: 'doctor_sync_not_configured' };
311:     }
312:     return { proceed: true, reason: 'doctor_ok' };
313: }
314: 
315: function printHelp(): void {
316:     console.log('Utilizzo consigliato (Windows): .\\bot.ps1 <comando> [opzioni]');
317:     console.log('Alternativa: npx ts-node src/index.ts <comando> [opzioni]');
318:     console.log('Compatibilità: npm start -- <comando> [opzioni]');
319:     console.log('Comandi principali:');
320:     console.log('  import --file <file.csv> --list <nome_lista>');
321:     console.log('  run invite|check|message|all (oppure --workflow <valore>)');
322:     console.log('  dry-run invite|check|message|all (oppure --workflow <valore>)');
323:     console.log('  run-loop [workflow] [intervalSec] [--cycles <n>] [--dry-run]');
324:     console.log('  autopilot [intervalSec] [--cycles <n>] [--dry-run]');
325:     console.log('  login [timeoutSec]');
326:     console.log('  doctor');
327:     console.log('  status');
328:     console.log('  funnel');
329:     console.log('  site-check [limit] [--fix]');
330:     console.log('  state-sync [limit] [--fix]');
331:     console.log('  salesnav-resolve [limit] [--fix] [--dry-run]');
332:     console.log('  enrich-targets [limit] [--dry-run]');
333:     console.log('  pause [minutes|indefinite] [reason]');
334:     console.log('  resume');
335:     console.log('  unquarantine');
336:     console.log('  incidents [open]');
337:     console.log('  incident-resolve <id>');
338:     console.log('  privacy-cleanup [days]');
339:     console.log('  lists');
340:     console.log('  company-targets [list] [limit]');
341:     console.log('  list-config <nome_lista> [priority] [inviteCap|none] [messageCap|none] [active]');
342:     console.log('    (oppure con opzioni: --list, --priority, --invite-cap, --message-cap, --active)');
343:     console.log('  sync-status');
344:     console.log('  sync-run-once');
345:     console.log('Alias retrocompatibili: connect, check, message');
346: }
347: 
348: async function runImportCommand(args: string[]): Promise<void> {
349:     const legacyPath = args[0] && !args[0].startsWith('--') ? args[0] : undefined;
350:     const filePath = getOptionValue(args, '--file') ?? legacyPath;
351:     const listName = getOptionValue(args, '--list') ?? 'default';
352: 
353:     if (!filePath) {
354:         throw new Error('Specifica il CSV: npm start -- import --file path/to/file.csv --list nome_lista');
355:     }
356: 
357:     const result = await importLeadsFromCSV(filePath, listName);
358:     console.log(
359:         `Import completato. Lead inseriti=${result.inserted}, Company target inseriti=${result.companyTargetsInserted}, Skippati=${result.skipped}, Lista=${listName}`
360:     );
361: }
362: 
363: async function runLoginCommand(args: string[]): Promise<void> {
364:     const positional = getPositionalArgs(args);
365:     const timeoutRaw = getOptionValue(args, '--timeout') ?? positional[0];
366:     const timeoutSeconds = timeoutRaw ? Math.max(30, parseIntStrict(timeoutRaw, '--timeout')) : 300;
367:     const timeoutMs = timeoutSeconds * 1000;
368: 
369:     const session = await launchBrowser({ headless: false });
370:     try {
371:         await session.page.goto('https://www.linkedin.com/login', { waitUntil: 'load' });
372:         console.log(`Completa il login LinkedIn nella finestra aperta (timeout ${timeoutSeconds}s)...`);
373:         console.log('Il browser resta aperto finché il login non viene verificato o finché scade il timeout.');
374: 
375:         const startedAt = Date.now();
376:         let lastLogAt = 0;
377:         while (Date.now() - startedAt <= timeoutMs) {
378:             if (await isLoggedIn(session.page)) {
379:                 const confirmed = await checkLogin(session.page);
380:                 if (confirmed) {
381:                     console.log('Login sessione completato con successo.');
382:                     return;
383:                 }
384:             }
385:             const now = Date.now();
386:             if (now - lastLogAt >= 15_000) {
387:                 const remaining = Math.max(0, Math.ceil((timeoutMs - (now - startedAt)) / 1000));
388:                 console.log(`In attesa completamento login... (${remaining}s rimanenti)`);
389:                 lastLogAt = now;
390:             }
391:             await session.page.waitForTimeout(2500);
392:         }
393: 
394:         // Ultimo controllo esplicito sulla home LinkedIn.
395:         const loggedIn = await checkLogin(session.page);
396:         if (!loggedIn) {
397:             throw new Error(`Login non rilevato entro ${timeoutSeconds} secondi.`);
398:         }
399:         console.log('Login sessione completato con successo.');
400:     } finally {
401:         await closeBrowserSession(session);
402:     }
403: }
404: 
405: async function runLoopCommand(args: string[]): Promise<void> {
406:     const workflow = parseWorkflow(getWorkflowValue(args));
407:     const positional = getPositionalArgs(args);
408:     const workflowTokens = new Set(['invite', 'check', 'message', 'all']);
409:     const numericPositionals = positional.filter((value) => /^\d+$/.test(value));
410:     const intervalMsRaw = getOptionValue(args, '--interval-ms');
411:     const intervalSecRaw = getOptionValue(args, '--interval-sec');
412:     const cyclesRaw = getOptionValue(args, '--cycles') ?? numericPositionals[1];
413:     const dryRun = hasOption(args, '--dry-run') || positional.some((value) => value.toLowerCase() === 'dry' || value.toLowerCase() === 'dry-run');
414: 
415:     let intervalMs = config.workflowLoopIntervalMs;
416:     if (intervalMsRaw) {
417:         intervalMs = Math.max(10_000, parseIntStrict(intervalMsRaw, '--interval-ms'));
418:     } else if (intervalSecRaw) {
419:         intervalMs = Math.max(10, parseIntStrict(intervalSecRaw, '--interval-sec')) * 1000;
420:     } else {
421:         const numericPositional = positional.find((value) => !workflowTokens.has(value) && /^\d+$/.test(value));
422:         if (numericPositional) {
423:             intervalMs = Math.max(10, parseIntStrict(numericPositional, 'intervalSec')) * 1000;
424:         }
425:     }
426: 
427:     const maxCycles = cyclesRaw ? Math.max(1, parseIntStrict(cyclesRaw, '--cycles')) : null;
428:     console.log(`[LOOP] start workflow=${workflow} dryRun=${dryRun} intervalMs=${intervalMs} cycles=${maxCycles ?? 'infinite'}`);
429: 
430:     const lockTtlSeconds = computeWorkflowLockTtlSeconds(intervalMs);
431:     const lockOwnerId = dryRun
432:         ? null
433:         : await acquireWorkflowRunnerLock('run-loop', lockTtlSeconds, {
434:             workflow,
435:             dryRun,
436:             intervalMs,
437:             startedAt: new Date().toISOString(),
438:         });
439: 
440:     try {
441:         let cycle = 0;
442:         while (true) {
443:             cycle += 1;
444:             const started = new Date().toISOString();
445:             console.log(`[LOOP] cycle=${cycle} started_at=${started}`);
446:             try {
447:                 if (lockOwnerId) {
448:                     await heartbeatWorkflowRunnerLock(lockOwnerId, lockTtlSeconds);
449:                 }
450: 
451:                 const doctorGate = await evaluateLoopDoctorGate(dryRun);
452:                 if (!doctorGate.proceed) {
453:                     console.warn(`[LOOP] cycle=${cycle} skipped reason=${doctorGate.reason}`);
454:                 } else {
455:                     const autoSiteCheck = await evaluateAutoSiteCheckDecision(dryRun);
456:                     if (autoSiteCheck.shouldRun) {
457:                         const siteCheckReport = await runSiteCheck({
458:                             limitPerStatus: config.autoSiteCheckLimit,
459:                             autoFix: config.autoSiteCheckFix,
460:                         });
461:                         await setRuntimeFlag(AUTO_SITE_CHECK_LAST_RUN_KEY, new Date().toISOString());
462:                         console.log('[LOOP] auto-site-check', {
463:                             reason: autoSiteCheck.reason,
464:                             intervalHours: config.autoSiteCheckIntervalHours,
465:                             limitPerStatus: config.autoSiteCheckLimit,
466:                             autoFix: config.autoSiteCheckFix,
467:                             report: siteCheckReport,
468:                         });
469:                     } else {
470:                         console.log('[LOOP] auto-site-check skipped', autoSiteCheck);
471:                     }
472: 
473:                     if (config.companyEnrichmentEnabled && (workflow === 'all' || workflow === 'invite')) {
474:                         const enrichment = await runCompanyEnrichmentBatch({
475:                             limit: config.companyEnrichmentBatch,
476:                             maxProfilesPerCompany: config.companyEnrichmentMaxProfilesPerCompany,
477:                             dryRun,
478:                         });
479:                         console.log('[LOOP] enrichment', enrichment);
480:                     }
481:                     await runWorkflow({ workflow, dryRun });
482:                     console.log(`[LOOP] cycle=${cycle} completed`);
483:                 }
484:             } catch (error) {
485:                 console.error(`[LOOP] cycle=${cycle} failed`, error);
486:             }
487: 
488:             if (maxCycles !== null && cycle >= maxCycles) {
489:                 console.log(`[LOOP] completed ${cycle} cycle(s).`);
490:                 break;
491:             }
492: 
493:             console.log(`[LOOP] waiting ${Math.floor(intervalMs / 1000)}s before next cycle...`);
494:             if (lockOwnerId) {
495:                 await sleepWithLockHeartbeat(intervalMs, lockOwnerId, lockTtlSeconds);
496:             } else {
497:                 await sleep(intervalMs);
498:             }
499:         }
500:     } finally {
501:         if (lockOwnerId) {
502:             await releaseWorkflowRunnerLock(lockOwnerId);
503:         }
504:     }
505: }
506: 
507: async function runAutopilotCommand(args: string[]): Promise<void> {
508:     const positional = getPositionalArgs(args);
509:     const intervalRaw = getOptionValue(args, '--interval-sec') ?? positional[0];
510:     const cyclesRaw = getOptionValue(args, '--cycles') ?? positional[1];
511:     const intervalArg = intervalRaw ?? String(Math.floor(config.workflowLoopIntervalMs / 1000));
512:     const forwarded = ['all', intervalArg];
513:     if (cyclesRaw && /^\d+$/.test(cyclesRaw)) {
514:         forwarded.push('--cycles', cyclesRaw);
515:     }
516:     if (hasOption(args, '--dry-run') || positional.includes('dry') || positional.includes('dry-run')) {
517:         forwarded.push('--dry-run');
518:     }
519:     await runLoopCommand(forwarded);
520: }
521: 
522: async function runWorkflowCommand(workflow: WorkflowSelection, dryRun: boolean): Promise<void> {
523:     if (dryRun) {
524:         await runWorkflow({ workflow, dryRun: true });
525:         return;
526:     }
527: 
528:     const lockTtlSeconds = Math.max(300, config.jobStuckMinutes * 60 + 300);
529:     const lockOwnerId = await acquireWorkflowRunnerLock('run', lockTtlSeconds, {
530:         workflow,
531:         dryRun: false,
532:         startedAt: new Date().toISOString(),
533:     });
534:     try {
535:         await runWorkflow({ workflow, dryRun: false });
536:         await heartbeatWorkflowRunnerLock(lockOwnerId, lockTtlSeconds);
537:     } finally {
538:         await releaseWorkflowRunnerLock(lockOwnerId);
539:     }
540: }
541: 
542: async function runFunnelCommand(): Promise<void> {
543:     const report = await buildFunnelReport();
544:     console.log(JSON.stringify(report, null, 2));
545: }
546: 
547: async function runSiteCheckCommand(args: string[]): Promise<void> {
548:     const positional = getPositionalArgs(args);
549:     const limitRaw = getOptionValue(args, '--limit') ?? positional[0];
550:     const limit = limitRaw ? Math.max(1, parseIntStrict(limitRaw, '--limit')) : 25;
551:     const autoFix = hasOption(args, '--fix') || positional.includes('fix');
552:     const report = await runSiteCheck({ limitPerStatus: limit, autoFix });
553:     console.log(JSON.stringify(report, null, 2));
554: }
555: 
556: async function runStateSyncCommand(args: string[]): Promise<void> {
557:     const positional = getPositionalArgs(args);
558:     const limitRaw = getOptionValue(args, '--limit') ?? positional[0];
559:     const limit = limitRaw ? Math.max(1, parseIntStrict(limitRaw, '--limit')) : config.postRunStateSyncLimit;
560:     const autoFix = hasOption(args, '--fix') || positional.includes('fix') || config.postRunStateSyncFix;
561:     const report = await runSiteCheck({ limitPerStatus: limit, autoFix });
562:     console.log(JSON.stringify({
563:         mode: 'state_sync',
564:         limitPerStatus: limit,
565:         autoFix,
566:         report,
567:     }, null, 2));
568: }
569: 
570: async function runSalesNavResolveCommand(args: string[]): Promise<void> {
571:     const positional = getPositionalArgs(args);
572:     const limitRaw = getOptionValue(args, '--limit') ?? positional[0];
573:     const limit = limitRaw ? Math.max(1, parseIntStrict(limitRaw, '--limit')) : 25;
574:     const fix = hasOption(args, '--fix') || positional.includes('fix');
575:     const dryRun = hasOption(args, '--dry-run') || positional.includes('dry-run') || positional.includes('dry');
576: 
577:     const leads = await getLeadsWithSalesNavigatorUrls(limit);
578:     const report: SalesNavResolveReport = {
579:         scanned: 0,
580:         resolvable: 0,
581:         updated: 0,
582:         conflicts: 0,
583:         unresolved: 0,
584:         challengeDetected: false,
585:         fix,
586:         dryRun,
587:         items: [],
588:     };
589: 
590:     if (leads.length === 0) {
591:         console.log(JSON.stringify(report, null, 2));
592:         return;
593:     }
594: 
595:     const session = await launchBrowser({ headless: config.headless });
596:     try {
597:         const loggedIn = await checkLogin(session.page);
598:         if (!loggedIn) {
599:             throw new Error('Sessione LinkedIn non autenticata. Esegui prima: .\\bot.ps1 login');
600:         }
601: 
602:         for (const lead of leads) {
603:             report.scanned += 1;
604:             try {
605:                 await session.page.goto(lead.linkedin_url, { waitUntil: 'domcontentloaded' });
606:                 await humanDelay(session.page, 1000, 2000);
607: 
608:                 if (await detectChallenge(session.page)) {
609:                     report.challengeDetected = true;
610:                     report.items.push({
611:                         leadId: lead.id,
612:                         status: lead.status,
613:                         currentUrl: lead.linkedin_url,
614:                         resolvedProfileUrl: null,
615:                         action: 'challenge_detected',
616:                     });
617:                     break;
618:                 }
619: 
620:                 const candidates = await collectProfileUrlCandidates(session.page);
621:                 const resolvedProfileUrl = pickResolvedProfileUrl(candidates);
622:                 if (!resolvedProfileUrl) {
623:                     report.unresolved += 1;
624:                     report.items.push({
625:                         leadId: lead.id,
626:                         status: lead.status,
627:                         currentUrl: lead.linkedin_url,
628:                         resolvedProfileUrl: null,
629:                         action: 'unresolved',
630:                     });
631:                     continue;
632:                 }
633: 
634:                 report.resolvable += 1;
635:                 if (!fix || dryRun) {
636:                     report.items.push({
637:                         leadId: lead.id,
638:                         status: lead.status,
639:                         currentUrl: lead.linkedin_url,
640:                         resolvedProfileUrl,
641:                         action: 'resolved',
642:                     });
643:                     continue;
644:                 }
645: 
646:                 const updated = await updateLeadLinkedinUrl(lead.id, resolvedProfileUrl);
647:                 if (updated.updated) {
648:                     const recoveryStatus = lead.status === 'BLOCKED'
649:                         ? getRecoveryStatusFromBlockedReason(lead.blocked_reason)
650:                         : null;
651:                     if (recoveryStatus) {
652:                         await reconcileLeadStatus(lead.id, recoveryStatus, 'salesnav_profile_url_resolved', {
653:                             previousStatus: lead.status,
654:                             blockedReason: lead.blocked_reason,
655:                         });
656:                     }
657:                     report.updated += 1;
658:                     report.items.push({
659:                         leadId: lead.id,
660:                         status: lead.status,
661:                         currentUrl: lead.linkedin_url,
662:                         resolvedProfileUrl,
663:                         action: 'updated',
664:                     });
665:                 } else {
666:                     report.conflicts += 1;
667:                     report.items.push({
668:                         leadId: lead.id,
669:                         status: lead.status,
670:                         currentUrl: lead.linkedin_url,
671:                         resolvedProfileUrl,
672:                         action: 'conflict',
673:                         conflictLeadId: updated.conflictLeadId,
674:                     });
675:                 }
676:             } catch (error) {
677:                 report.items.push({
678:                     leadId: lead.id,
679:                     status: lead.status,
680:                     currentUrl: lead.linkedin_url,
681:                     resolvedProfileUrl: null,
682:                     action: 'error',
683:                     error: error instanceof Error ? error.message : String(error),
684:                 });
685:             }
686:         }
687:     } finally {
688:         await closeBrowserSession(session);
689:     }
690: 
691:     console.log(JSON.stringify(report, null, 2));
692: }
693: 
694: async function runEnrichTargetsCommand(args: string[]): Promise<void> {
695:     const positional = getPositionalArgs(args);
696:     const limitRaw = getOptionValue(args, '--limit') ?? positional[0];
697:     const limit = limitRaw ? Math.max(1, parseIntStrict(limitRaw, '--limit')) : config.companyEnrichmentBatch;
698:     const dryRun = hasOption(args, '--dry-run') || positional.includes('dry') || positional.includes('dry-run');
699:     const report = await runCompanyEnrichmentBatch({
700:         limit,
701:         maxProfilesPerCompany: config.companyEnrichmentMaxProfilesPerCompany,
702:         dryRun,
703:     });
704:     console.log(JSON.stringify(report, null, 2));
705: }
706: 
707: async function runStatusCommand(): Promise<void> {
708:     const localDate = getLocalDateString();
709:     const [
710:         quarantineFlag,
711:         pauseState,
712:         incidents,
713:         jobStatusCounts,
714:         dailyStats,
715:         syncStatus,
716:         runnerLock,
717:         autoSiteCheckLastRunAt,
718:     ] = await Promise.all([
719:         getRuntimeFlag('account_quarantine'),
720:         getAutomationPauseState(),
721:         listOpenIncidents(),
722:         getJobStatusCounts(),
723:         getDailyStatsSnapshot(localDate),
724:         getEventSyncStatus(),
725:         getRuntimeLock(WORKFLOW_RUNNER_LOCK_KEY),
726:         getRuntimeFlag(AUTO_SITE_CHECK_LAST_RUN_KEY),
727:     ]);
728: 
729:     const payload = {
730:         localDate,
731:         quarantine: quarantineFlag === 'true',
732:         pause: pauseState,
733:         openIncidents: incidents.length,
734:         jobs: jobStatusCounts,
735:         dailyStats,
736:         sync: syncStatus,
737:         runnerLock,
738:         autoSiteCheck: {
739:             enabled: config.autoSiteCheckEnabled,
740:             fix: config.autoSiteCheckFix,
741:             limitPerStatus: config.autoSiteCheckLimit,
742:             intervalHours: config.autoSiteCheckIntervalHours,
743:             lastRunAt: autoSiteCheckLastRunAt,
744:         },
745:         stateSync: {
746:             postRunEnabled: config.postRunStateSyncEnabled,
747:             postRunLimit: config.postRunStateSyncLimit,
748:             postRunFix: config.postRunStateSyncFix,
749:         },
750:         ai: {
751:             personalizationEnabled: config.aiPersonalizationEnabled,
752:             guardianEnabled: config.aiGuardianEnabled,
753:             model: config.aiModel,
754:             openaiConfigured: !!config.openaiApiKey,
755:             guardianMinIntervalMinutes: config.aiGuardianMinIntervalMinutes,
756:             guardianPauseMinutes: config.aiGuardianPauseMinutes,
757:         },
758:     };
759:     console.log(JSON.stringify(payload, null, 2));
760: }
761: 
762: async function runPauseCommand(args: string[]): Promise<void> {
763:     const positional = getPositionalArgs(args);
764:     const minutesRaw = getOptionValue(args, '--minutes') ?? positional[0];
765:     const reasonRaw = getOptionValue(args, '--reason') ?? (positional.length > 1 ? positional.slice(1).join(' ') : 'manual_pause');
766: 
767:     const minutes = minutesRaw
768:         ? parsePauseMinutes(minutesRaw, '--minutes')
769:         : config.autoPauseMinutesOnFailureBurst;
770:     const pausedUntil = await setAutomationPause(minutes, reasonRaw);
771:     const renderedUntil = pausedUntil ?? 'manual resume';
772:     console.log(`Automazione in pausa. pausedUntil=${renderedUntil} reason=${reasonRaw}`);
773: }
774: 
775: async function runResumeCommand(): Promise<void> {
776:     await clearPauseState();
777:     console.log('Pausa automazione rimossa.');
778: }
779: 
780: async function runUnquarantineCommand(): Promise<void> {
781:     await setQuarantine(false);
782:     await clearPauseState();
783:     console.log('Quarantine disattivata e pausa rimossa.');
784: }
785: 
786: async function runResolveIncidentCommand(args: string[]): Promise<void> {
787:     const positional = getPositionalArgs(args);
788:     const idRaw = getOptionValue(args, '--id') ?? positional[0];
789:     if (!idRaw) {
790:         throw new Error('Specifica ID incidente: npm start -- incident-resolve <id>');
791:     }
792:     const incidentId = parseIntStrict(idRaw, '--id');
793:     if (incidentId < 1) {
794:         throw new Error('--id deve essere >= 1');
795:     }
796:     await resolveIncident(incidentId);
797:     console.log(`Incidente ${incidentId} risolto.`);
798: }
799: 
800: async function runPrivacyCleanupCommand(args: string[]): Promise<void> {
801:     const positional = getPositionalArgs(args);
802:     const daysRaw = getOptionValue(args, '--days') ?? positional[0];
803:     const days = daysRaw ? Math.max(7, parseIntStrict(daysRaw, '--days')) : config.retentionDays;
804:     const result = await cleanupPrivacyData(days);
805:     console.log(JSON.stringify({ retentionDays: days, ...result }, null, 2));
806: }
807: 
808: async function runCompanyTargetsCommand(args: string[]): Promise<void> {
809:     const positional = getPositionalArgs(args);
810:     const listName = getOptionValue(args, '--list') ?? positional[0] ?? null;
811:     const limitRaw = getOptionValue(args, '--limit') ?? positional[1];
812:     const limit = limitRaw ? Math.max(1, parseIntStrict(limitRaw, '--limit')) : 50;
813:     const [total, items] = await Promise.all([
814:         countCompanyTargets(listName ?? undefined),
815:         listCompanyTargets(listName, limit),
816:     ]);
817:     console.log(JSON.stringify({ list: listName ?? 'all', total, shown: items.length, items }, null, 2));
818: }
819: 
820: async function main(): Promise<void> {
821:     setupGracefulShutdown();
822:     const args = process.argv.slice(2);
823:     const command = args[0];
824:     const commandArgs = args.slice(1);
825: 
826:     await initDatabase();
827:     const shouldRecoverStuckJobs = command === 'run'
828:         || command === 'connect'
829:         || command === 'check'
830:         || command === 'message'
831:         || (command === 'run-loop' && !hasOption(commandArgs, '--dry-run'));
832:     if (shouldRecoverStuckJobs) {
833:         const recoveredJobs = await recoverStuckJobs(config.jobStuckMinutes);
834:         if (recoveredJobs > 0) {
835:             console.warn(`[BOOT] Ripristinati ${recoveredJobs} job RUNNING bloccati da oltre ${config.jobStuckMinutes} minuti.`);
836:         }
837:     }
838: 
839:     switch (command) {
840:         case 'import':
841:             await runImportCommand(commandArgs);
842:             break;
843:         case 'run': {
844:             const workflow = parseWorkflow(getWorkflowValue(commandArgs));
845:             await runWorkflowCommand(workflow, false);
846:             break;
847:         }
848:         case 'dry-run': {
849:             const workflow = parseWorkflow(getWorkflowValue(commandArgs));
850:             await runWorkflowCommand(workflow, true);
851:             break;
852:         }
853:         case 'run-loop':
854:             await runLoopCommand(commandArgs);
855:             break;
856:         case 'autopilot':
857:             await runAutopilotCommand(commandArgs);
858:             break;
859:         case 'login':
860:             await runLoginCommand(commandArgs);
861:             break;
862:         case 'doctor': {
863:             const report = await runDoctor();
864:             console.log(JSON.stringify(report, null, 2));
865:             break;
866:         }
867:         case 'funnel':
868:             await runFunnelCommand();
869:             break;
870:         case 'site-check':
871:             await runSiteCheckCommand(commandArgs);
872:             break;
873:         case 'state-sync':
874:             await runStateSyncCommand(commandArgs);
875:             break;
876:         case 'salesnav-resolve':
877:             await runSalesNavResolveCommand(commandArgs);
878:             break;
879:         case 'enrich-targets':
880:             await runEnrichTargetsCommand(commandArgs);
881:             break;
882:         case 'status':
883:             await runStatusCommand();
884:             break;
885:         case 'pause':
886:             await runPauseCommand(commandArgs);
887:             break;
888:         case 'resume':
889:             await runResumeCommand();
890:             break;
891:         case 'unquarantine':
892:             await runUnquarantineCommand();
893:             break;
894:         case 'incidents': {
895:             const positional = getPositionalArgs(commandArgs);
896:             const openOnly = commandArgs.includes('--open') || positional.includes('open') || positional.length === 0;
897:             if (!openOnly) {
898:                 console.log('Usa: npm start -- incidents open');
899:                 break;
900:             }
901:             const incidents = await listOpenIncidents();
902:             console.log(JSON.stringify(incidents, null, 2));
903:             break;
904:         }
905:         case 'incident-resolve':
906:             await runResolveIncidentCommand(commandArgs);
907:             break;
908:         case 'privacy-cleanup':
909:             await runPrivacyCleanupCommand(commandArgs);
910:             break;
911:         case 'lists': {
912:             const lists = await listLeadCampaignConfigs(false);
913:             console.log(JSON.stringify(lists, null, 2));
914:             break;
915:         }
916:         case 'company-targets':
917:             await runCompanyTargetsCommand(commandArgs);
918:             break;
919:         case 'list-config': {
920:             const positional = getPositionalArgs(commandArgs);
921:             const listName = getOptionValue(commandArgs, '--list') ?? positional[0];
922:             if (!listName) {
923:                 throw new Error('Specifica la lista: npm start -- list-config --list <nome_lista> ...');
924:             }
925: 
926:             const patch: {
927:                 priority?: number;
928:                 dailyInviteCap?: number | null;
929:                 dailyMessageCap?: number | null;
930:                 isActive?: boolean;
931:             } = {};
932: 
933:             const priorityRaw = getOptionValue(commandArgs, '--priority') ?? positional[1];
934:             if (hasOption(commandArgs, '--priority') || priorityRaw !== undefined) {
935:                 const raw = priorityRaw;
936:                 if (!raw) throw new Error('Manca valore per --priority');
937:                 const parsed = parseIntStrict(raw, '--priority');
938:                 if (parsed < 1) throw new Error('--priority deve essere >= 1');
939:                 patch.priority = parsed;
940:             }
941:             const inviteCapRaw = getOptionValue(commandArgs, '--invite-cap') ?? positional[2];
942:             if (hasOption(commandArgs, '--invite-cap') || inviteCapRaw !== undefined) {
943:                 const raw = inviteCapRaw;
944:                 if (!raw) throw new Error('Manca valore per --invite-cap');
945:                 patch.dailyInviteCap = parseNullableCap(raw, '--invite-cap');
946:             }
947:             const messageCapRaw = getOptionValue(commandArgs, '--message-cap') ?? positional[3];
948:             if (hasOption(commandArgs, '--message-cap') || messageCapRaw !== undefined) {
949:                 const raw = messageCapRaw;
950:                 if (!raw) throw new Error('Manca valore per --message-cap');
951:                 patch.dailyMessageCap = parseNullableCap(raw, '--message-cap');
952:             }
953:             const activeRaw = getOptionValue(commandArgs, '--active') ?? positional[4];
954:             if (hasOption(commandArgs, '--active') || activeRaw !== undefined) {
955:                 const raw = activeRaw;
956:                 if (!raw) throw new Error('Manca valore per --active');
957:                 patch.isActive = parseBoolStrict(raw, '--active');
958:             }
959: 
960:             const updated = await updateLeadCampaignConfig(listName, patch);
961:             console.log(JSON.stringify(updated, null, 2));
962:             break;
963:         }
964:         case 'sync-status': {
965:             const status = await getEventSyncStatus();
966:             console.log(JSON.stringify(status, null, 2));
967:             break;
968:         }
969:         case 'sync-run-once':
970:             await runEventSyncOnce();
971:             console.log('Sync eventi completato.');
972:             break;
973:         case 'connect':
974:             await runWorkflowCommand('invite', false);
975:             break;
976:         case 'check':
977:             await runWorkflowCommand('check', false);
978:             break;
979:         case 'message':
980:             await runWorkflowCommand('message', false);
981:             break;
982:         default:
983:             printHelp();
984:             break;
985:     }
986: }
987: 
988: main()
989:     .catch((error) => {
990:         console.error('[FATAL]', error);
991:         process.exitCode = 1;
992:     })
993:     .finally(async () => {
994:         await closeDatabase();
995:     });
````

## File: src/linkedinUrl.ts
````typescript
 1: export function tryParseUrl(raw: string): URL | null {
 2:     const trimmed = raw.trim();
 3:     if (!trimmed) return null;
 4:     try {
 5:         return new URL(trimmed);
 6:     } catch {
 7:         return null;
 8:     }
 9: }
10: 
11: export function isLinkedInHost(hostname: string): boolean {
12:     const host = hostname.toLowerCase();
13:     return host === 'linkedin.com' || host.endsWith('.linkedin.com');
14: }
15: 
16: export function isLinkedInUrl(raw: string): boolean {
17:     const parsed = tryParseUrl(raw);
18:     return !!parsed && isLinkedInHost(parsed.hostname);
19: }
20: 
21: export function isSalesNavigatorUrl(raw: string): boolean {
22:     const parsed = tryParseUrl(raw);
23:     if (!parsed || !isLinkedInHost(parsed.hostname)) return false;
24:     return parsed.pathname.toLowerCase().startsWith('/sales/');
25: }
26: 
27: export function isProfileUrl(raw: string): boolean {
28:     const parsed = tryParseUrl(raw);
29:     if (!parsed || !isLinkedInHost(parsed.hostname)) return false;
30:     const path = parsed.pathname.toLowerCase();
31:     return path.startsWith('/in/') || path.startsWith('/pub/');
32: }
33: 
34: export function normalizeLinkedInUrl(raw: string): string {
35:     const parsed = tryParseUrl(raw);
36:     if (!parsed || !isLinkedInHost(parsed.hostname)) {
37:         return raw.trim();
38:     }
39: 
40:     const normalized = new URL(parsed.toString());
41:     normalized.protocol = 'https:';
42:     normalized.hostname = 'www.linkedin.com';
43:     normalized.hash = '';
44: 
45:     // Canonicalizza i profili alla radice /in/<slug>/ per evitare varianti duplicate.
46:     const parts = normalized.pathname.split('/').filter(Boolean);
47:     if (parts.length >= 2 && parts[0].toLowerCase() === 'in') {
48:         normalized.pathname = `/in/${parts[1]}/`;
49:         normalized.search = '';
50:         return normalized.toString();
51:     }
52: 
53:     normalized.pathname = normalized.pathname.replace(/\/+$/, '');
54:     return normalized.toString();
55: }
````

## File: src/messages.ts
````typescript
 1: import { LeadRecord } from './types/domain';
 2: 
 3: const templates: string[] = [
 4:     `Ciao {{firstName}},\n\npiacere di connetterci qui su LinkedIn.\nSeguo aziende nel tuo settore e ho visto alcuni punti dove spesso si sblocca crescita commerciale con piccoli cambi operativi.\n\nSe ti va, facciamo una call di 15 minuti questa settimana?`,
 5:     `Ciao {{firstName}},\n\ngrazie del collegamento.\nHo dato un'occhiata a {{companyHint}} e credo ci sia spazio per uno scambio utile su acquisizione e pipeline.\n\nTi andrebbe una breve call di 15 minuti?`,
 6:     `Ciao {{firstName}},\n\npiacere di essere in contatto.\nLavoro su progetti che aiutano team come il tuo a migliorare conversione e tempi di risposta commerciale.\n\nSe hai 15 minuti nei prossimi giorni, ti racconto due idee concrete.`,
 7: ];
 8: 
 9: /**
10:  * Restituisce il primo nome da usare nel messaggio.
11:  * Priorità: first_name (da Sales Navigator) → prima parola di account_name → fallback generico.
12:  */
13: function resolveFirstName(lead: LeadRecord): string {
14:     if (lead.first_name && lead.first_name.trim()) {
15:         return lead.first_name.trim();
16:     }
17:     // Fallback: prima parola di account_name se sembra un nome proprio
18:     const clean = lead.account_name.trim();
19:     if (clean) {
20:         const firstWord = clean.split(/\s+/)[0];
21:         // Usa la prima parola solo se non è tutta maiuscola (es. "ACME" → scarta)
22:         if (firstWord !== firstWord.toUpperCase()) {
23:             return firstWord;
24:         }
25:     }
26:     return 'there';
27: }
28: 
29: function getCompanyHint(lead: LeadRecord): string {
30:     if (lead.account_name.trim()) {
31:         return lead.account_name.trim();
32:     }
33:     if (lead.website.trim()) {
34:         return lead.website.trim();
35:     }
36:     return 'la tua realtà';
37: }
38: 
39: function resolveTemplate(template: string, lead: LeadRecord): string {
40:     return template
41:         .replaceAll('{{firstName}}', resolveFirstName(lead))
42:         .replaceAll('{{companyHint}}', getCompanyHint(lead));
43: }
44: 
45: export function buildFollowUpMessage(lead: LeadRecord): string {
46:     const index = lead.id % templates.length;
47:     return resolveTemplate(templates[index], lead);
48: }
````

## File: src/messagingWorkflow.ts
````typescript
1: import { runWorkflow } from './core/orchestrator';
2: 
3: export async function runMessagingWorkflow(): Promise<void> {
4:     await runWorkflow({
5:         workflow: 'message',
6:         dryRun: false,
7:     });
8: }
````

## File: src/models.ts
````typescript
 1: import {
 2:     addLead as addLeadRepository,
 3:     getDailyStat,
 4:     countLeadsByStatuses,
 5:     countWeeklyInvites as countWeeklyInvitesRepository,
 6:     getLeadsByStatus,
 7:     incrementDailyStat,
 8:     setLeadStatus,
 9: } from './core/repositories';
10: import { LeadRecord, LeadStatus } from './types/domain';
11: 
12: export interface Lead extends LeadRecord { }
13: 
14: export async function addLead(lead: Partial<Lead>): Promise<void> {
15:     await addLeadRepository({
16:         accountName: lead.account_name ?? '',
17:         firstName: lead.first_name ?? '',
18:         lastName: lead.last_name ?? '',
19:         jobTitle: lead.job_title ?? '',
20:         website: lead.website ?? '',
21:         linkedinUrl: lead.linkedin_url ?? '',
22:         listName: lead.list_name ?? 'default',
23:     });
24: }
25: 
26: export async function getPendingLeads(limit: number): Promise<Lead[]> {
27:     return getLeadsByStatus('READY_INVITE', limit);
28: }
29: 
30: export async function getInvitedLeads(): Promise<Lead[]> {
31:     return getLeadsByStatus('INVITED', 1000);
32: }
33: 
34: export async function getAcceptedLeads(limit: number): Promise<Lead[]> {
35:     return getLeadsByStatus('READY_MESSAGE', limit);
36: }
37: 
38: export async function updateLeadStatus(id: number, status: LeadStatus): Promise<void> {
39:     await setLeadStatus(id, status);
40: }
41: 
42: export async function countDailyInvites(dateString: string): Promise<number> {
43:     return getDailyStat(dateString, 'invites_sent');
44: }
45: 
46: export async function countWeeklyInvites(weekStartDate: string): Promise<number> {
47:     return countWeeklyInvitesRepository(weekStartDate);
48: }
49: 
50: export async function incrementDailyInvites(dateString: string): Promise<void> {
51:     await incrementDailyStat(dateString, 'invites_sent');
52: }
53: 
54: export async function countReadyToInvite(): Promise<number> {
55:     return countLeadsByStatuses(['READY_INVITE']);
56: }
````

## File: src/risk/incidentManager.ts
````typescript
 1: import { clearAutomationPause, createIncident, pushOutboxEvent, setAutomationPause, setRuntimeFlag } from '../core/repositories';
 2: import { sendTelegramAlert } from '../telemetry/alerts';
 3: 
 4: export async function quarantineAccount(type: string, details: Record<string, unknown>): Promise<number> {
 5:     const incidentId = await createIncident(type, 'CRITICAL', details);
 6:     await setRuntimeFlag('account_quarantine', 'true');
 7:     await pushOutboxEvent(
 8:         'incident.opened',
 9:         {
10:             incidentId,
11:             type,
12:             severity: 'CRITICAL',
13:             details,
14:         },
15:         `incident.opened:${incidentId}`
16:     );
17:     await sendTelegramAlert(`CRITICAL incident #${incidentId}: ${type}`);
18:     return incidentId;
19: }
20: 
21: export async function setQuarantine(enabled: boolean): Promise<void> {
22:     await setRuntimeFlag('account_quarantine', enabled ? 'true' : 'false');
23: }
24: 
25: export async function pauseAutomation(type: string, details: Record<string, unknown>, minutes: number): Promise<number> {
26:     const incidentId = await createIncident(type, 'WARN', details);
27:     const pausedUntil = await setAutomationPause(minutes, type);
28:     await pushOutboxEvent(
29:         'automation.paused',
30:         {
31:             incidentId,
32:             type,
33:             severity: 'WARN',
34:             pausedUntil,
35:             details,
36:         },
37:         `automation.paused:${incidentId}`
38:     );
39:     await sendTelegramAlert(`WARN incident #${incidentId}: ${type}. Automazione in pausa fino a ${pausedUntil ?? 'manual resume'}`);
40:     return incidentId;
41: }
42: 
43: export async function resumeAutomation(): Promise<void> {
44:     await clearAutomationPause();
45: }
````

## File: src/risk/riskEngine.ts
````typescript
 1: import { config } from '../config';
 2: import { RiskInputs, RiskSnapshot } from '../types/domain';
 3: 
 4: function clampScore(value: number): number {
 5:     return Math.max(0, Math.min(100, Math.round(value)));
 6: }
 7: 
 8: export function evaluateRisk(inputs: RiskInputs): RiskSnapshot {
 9:     const score = clampScore(
10:         inputs.errorRate * 40 +
11:         inputs.selectorFailureRate * 20 +
12:         inputs.pendingRatio * 25 +
13:         Math.min(30, inputs.challengeCount * 20) +
14:         inputs.inviteVelocityRatio * 15
15:     );
16: 
17:     let action: RiskSnapshot['action'] = 'NORMAL';
18:     if (score >= config.riskStopThreshold || inputs.pendingRatio >= config.pendingRatioStop || inputs.challengeCount > 0) {
19:         action = 'STOP';
20:     } else if (score >= config.riskWarnThreshold || inputs.pendingRatio >= config.pendingRatioWarn) {
21:         action = 'WARN';
22:     }
23: 
24:     return {
25:         score,
26:         pendingRatio: inputs.pendingRatio,
27:         errorRate: inputs.errorRate,
28:         selectorFailureRate: inputs.selectorFailureRate,
29:         challengeCount: inputs.challengeCount,
30:         inviteVelocityRatio: inputs.inviteVelocityRatio,
31:         action,
32:     };
33: }
34: 
35: export function calculateDynamicBudget(
36:     softCap: number,
37:     hardCap: number,
38:     alreadyConsumed: number,
39:     riskAction: RiskSnapshot['action']
40: ): number {
41:     if (alreadyConsumed >= hardCap) {
42:         return 0;
43:     }
44: 
45:     let effectiveCap = softCap;
46:     if (riskAction === 'WARN') {
47:         effectiveCap = Math.floor(softCap * 0.5);
48:     }
49:     if (riskAction === 'STOP') {
50:         effectiveCap = 0;
51:     }
52: 
53:     effectiveCap = Math.min(hardCap, Math.max(0, effectiveCap));
54:     return Math.max(0, effectiveCap - alreadyConsumed);
55: }
56: 
57: export interface CooldownDecision {
58:     activate: boolean;
59:     tier: 'none' | 'warn' | 'high';
60:     minutes: number;
61:     reason: string | null;
62: }
63: 
64: export function evaluateCooldownDecision(snapshot: RiskSnapshot): CooldownDecision {
65:     if (!config.cooldownEnabled) {
66:         return { activate: false, tier: 'none', minutes: 0, reason: null };
67:     }
68: 
69:     if (snapshot.action !== 'WARN') {
70:         return { activate: false, tier: 'none', minutes: 0, reason: null };
71:     }
72: 
73:     const high = snapshot.score >= config.cooldownHighScore || snapshot.pendingRatio >= config.cooldownPendingHighThreshold;
74:     if (high) {
75:         return {
76:             activate: true,
77:             tier: 'high',
78:             minutes: config.cooldownHighMinutes,
79:             reason: 'risk_cooldown_high',
80:         };
81:     }
82: 
83:     const warn = snapshot.score >= config.cooldownWarnScore || snapshot.pendingRatio >= config.cooldownPendingThreshold;
84:     if (warn) {
85:         return {
86:             activate: true,
87:             tier: 'warn',
88:             minutes: config.cooldownWarnMinutes,
89:             reason: 'risk_cooldown_warn',
90:         };
91:     }
92: 
93:     return { activate: false, tier: 'none', minutes: 0, reason: null };
94: }
````

## File: src/security/filesystem.ts
````typescript
 1: import fs from 'fs';
 2: import path from 'path';
 3: 
 4: function chmodSafe(targetPath: string, mode: number): void {
 5:     if (process.platform === 'win32') {
 6:         return;
 7:     }
 8:     try {
 9:         fs.chmodSync(targetPath, mode);
10:     } catch {
11:         // Best effort: non bloccare runtime in caso di FS non compatibile.
12:     }
13: }
14: 
15: export function ensureDirectoryPrivate(directoryPath: string): void {
16:     if (!fs.existsSync(directoryPath)) {
17:         fs.mkdirSync(directoryPath, { recursive: true });
18:     }
19:     chmodSafe(directoryPath, 0o700);
20: }
21: 
22: export function ensureParentDirectoryPrivate(filePath: string): void {
23:     const directoryPath = path.dirname(filePath);
24:     ensureDirectoryPrivate(directoryPath);
25: }
26: 
27: export function ensureFilePrivate(filePath: string): void {
28:     if (!fs.existsSync(filePath)) {
29:         return;
30:     }
31:     chmodSafe(filePath, 0o600);
32: }
````

## File: src/security/redaction.ts
````typescript
 1: const MAX_RECURSION_DEPTH = 6;
 2: const REDACTED = '[REDACTED]';
 3: 
 4: const SENSITIVE_KEY_PATTERN = /(token|secret|password|pass|key|cookie|authorization|session|bearer)/i;
 5: 
 6: const JWT_PATTERN = /\b[A-Za-z0-9_-]{20,}\.[A-Za-z0-9_-]{20,}\.[A-Za-z0-9_-]{20,}\b/g;
 7: const SUPABASE_KEY_PATTERN = /\bsb_(publishable|secret)_[A-Za-z0-9_-]{20,}\b/gi;
 8: const API_KEY_PATTERN = /\b(sk|pk|rk)_[A-Za-z0-9_-]{16,}\b/gi;
 9: const TELEGRAM_BOT_TOKEN_PATTERN = /\b\d{8,}:[A-Za-z0-9_-]{20,}\b/g;
10: 
11: function sanitizeString(input: string): string {
12:     return input
13:         .replace(JWT_PATTERN, REDACTED)
14:         .replace(SUPABASE_KEY_PATTERN, REDACTED)
15:         .replace(API_KEY_PATTERN, REDACTED)
16:         .replace(TELEGRAM_BOT_TOKEN_PATTERN, REDACTED);
17: }
18: 
19: function sanitizeArray(input: unknown[], depth: number): unknown[] {
20:     if (depth > MAX_RECURSION_DEPTH) {
21:         return ['[MAX_DEPTH_REACHED]'];
22:     }
23:     return input.map((item) => sanitizeForLogs(item, depth + 1));
24: }
25: 
26: function sanitizeObject(input: Record<string, unknown>, depth: number): Record<string, unknown> {
27:     if (depth > MAX_RECURSION_DEPTH) {
28:         return { note: '[MAX_DEPTH_REACHED]' };
29:     }
30: 
31:     const output: Record<string, unknown> = {};
32:     for (const [key, value] of Object.entries(input)) {
33:         if (SENSITIVE_KEY_PATTERN.test(key)) {
34:             output[key] = REDACTED;
35:             continue;
36:         }
37:         output[key] = sanitizeForLogs(value, depth + 1);
38:     }
39:     return output;
40: }
41: 
42: export function sanitizeForLogs<T>(value: T, depth: number = 0): T {
43:     if (value === null || value === undefined) {
44:         return value;
45:     }
46: 
47:     if (typeof value === 'string') {
48:         return sanitizeString(value) as T;
49:     }
50: 
51:     if (typeof value === 'number' || typeof value === 'boolean') {
52:         return value;
53:     }
54: 
55:     if (Array.isArray(value)) {
56:         return sanitizeArray(value, depth) as T;
57:     }
58: 
59:     if (typeof value === 'object') {
60:         return sanitizeObject(value as Record<string, unknown>, depth) as T;
61:     }
62: 
63:     return String(value) as T;
64: }
````

## File: src/selectors.ts
````typescript
 1: /**
 2:  * Centralized selectors with progressive fallbacks.
 3:  */
 4: export const SELECTORS = {
 5:     globalNav: '.global-nav__me, [data-test-global-nav-me] button',
 6: 
 7:     connectButtonPrimary: [
 8:         'button.artdeco-button--primary:has-text("Connect")',
 9:         'button.artdeco-button--primary:has-text("Collegati")',
10:     ].join(', '),
11: 
12:     moreActionsButton: [
13:         'button[aria-label="More actions"]',
14:         'button[aria-label="Altre azioni"]',
15:         'button.artdeco-dropdown__trigger:has-text("More")',
16:         'button.artdeco-dropdown__trigger:has-text("Altro")',
17:     ].join(', '),
18: 
19:     connectInMoreMenu: [
20:         'div.artdeco-dropdown__content-inner li button:has-text("Connect")',
21:         'div.artdeco-dropdown__content-inner li button:has-text("Collegati")',
22:     ].join(', '),
23: 
24:     sendWithoutNote: [
25:         'button[aria-label="Send without a note"]',
26:         'button[aria-label="Invia senza nota"]',
27:     ].join(', '),
28: 
29:     sendFallback: [
30:         'button.artdeco-button--primary:has-text("Send")',
31:         'button.artdeco-button--primary:has-text("Invia")',
32:     ].join(', '),
33: 
34:     invitePendingIndicators: [
35:         'button:has-text("Pending")',
36:         'button:has-text("In attesa")',
37:         'button[aria-label*="Pending"]',
38:     ].join(', '),
39: 
40:     messageButton: [
41:         'button[aria-label^="Message"]',
42:         'button[aria-label^="Invia messaggio"]',
43:         'a.message-anywhere-button',
44:     ].join(', '),
45: 
46:     distanceBadge: [
47:         'span.dist-value',
48:         'span[aria-hidden="true"]:has-text("1st")',
49:         'span[aria-hidden="true"]:has-text("1°")',
50:     ].join(', '),
51: 
52:     messageTextbox: [
53:         'div.msg-form__contenteditable[role="textbox"]',
54:         'div[contenteditable="true"][role="textbox"]',
55:     ].join(', '),
56: 
57:     messageSendButton: [
58:         'button.msg-form__send-button',
59:         'button:has-text("Send")',
60:         'button:has-text("Invia")',
61:     ].join(', '),
62: 
63:     challengeSignals: [
64:         'input[name="captcha"]',
65:         'iframe[src*="captcha"]',
66:         'form[action*="checkpoint"]',
67:         'h1:has-text("Security verification")',
68:         'h1:has-text("Verifica")',
69:     ].join(', '),
70: };
````

## File: src/sync/eventSync.ts
````typescript
 1: import { config, EventSyncSink } from '../config';
 2: import { SyncStatus, getSyncStatus as getSupabaseSyncStatus, runSupabaseSyncOnce } from './supabaseSyncWorker';
 3: import { WebhookSyncStatus, getWebhookSyncStatus, runWebhookSyncOnce } from './webhookSyncWorker';
 4: 
 5: export interface EventSyncStatus {
 6:     activeSink: EventSyncSink;
 7:     enabled: boolean;
 8:     configured: boolean;
 9:     pendingOutbox: number;
10:     warning: string | null;
11:     supabase: SyncStatus;
12:     webhook: WebhookSyncStatus;
13: }
14: 
15: function buildSinkWarning(supabase: SyncStatus, webhook: WebhookSyncStatus): string | null {
16:     if (config.supabaseSyncEnabled && config.webhookSyncEnabled) {
17:         return `Entrambi i sink sono attivi ma verra usato solo EVENT_SYNC_SINK=${config.eventSyncSink}.`;
18:     }
19:     if (config.eventSyncSink === 'SUPABASE' && !config.supabaseSyncEnabled) {
20:         return 'EVENT_SYNC_SINK=SUPABASE ma SUPABASE_SYNC_ENABLED=false.';
21:     }
22:     if (config.eventSyncSink === 'WEBHOOK' && !config.webhookSyncEnabled) {
23:         return 'EVENT_SYNC_SINK=WEBHOOK ma WEBHOOK_SYNC_ENABLED=false.';
24:     }
25:     if (config.eventSyncSink === 'SUPABASE' && config.supabaseSyncEnabled && !supabase.configured) {
26:         return 'SUPABASE_SYNC_ENABLED=true ma SUPABASE_URL/SUPABASE_SERVICE_ROLE_KEY non configurati.';
27:     }
28:     if (config.eventSyncSink === 'WEBHOOK' && config.webhookSyncEnabled && !webhook.configured) {
29:         return 'WEBHOOK_SYNC_ENABLED=true ma WEBHOOK_SYNC_URL non configurato.';
30:     }
31:     return null;
32: }
33: 
34: export async function getEventSyncStatus(): Promise<EventSyncStatus> {
35:     const [supabase, webhook] = await Promise.all([getSupabaseSyncStatus(), getWebhookSyncStatus()]);
36:     const warning = buildSinkWarning(supabase, webhook);
37: 
38:     if (config.eventSyncSink === 'NONE') {
39:         return {
40:             activeSink: 'NONE',
41:             enabled: false,
42:             configured: true,
43:             pendingOutbox: supabase.pendingOutbox,
44:             warning,
45:             supabase,
46:             webhook,
47:         };
48:     }
49: 
50:     const active = config.eventSyncSink === 'WEBHOOK' ? webhook : supabase;
51:     return {
52:         activeSink: config.eventSyncSink,
53:         enabled: active.enabled,
54:         configured: active.configured,
55:         pendingOutbox: active.pendingOutbox,
56:         warning,
57:         supabase,
58:         webhook,
59:     };
60: }
61: 
62: export async function runEventSyncOnce(): Promise<void> {
63:     if (config.eventSyncSink === 'NONE') {
64:         return;
65:     }
66: 
67:     if (config.eventSyncSink === 'WEBHOOK') {
68:         await runWebhookSyncOnce();
69:         return;
70:     }
71: 
72:     await runSupabaseSyncOnce();
73: }
````

## File: src/sync/supabase.schema.sql
````sql
 1: create table if not exists public.cp_events (
 2:     id bigserial primary key,
 3:     topic text not null,
 4:     payload jsonb not null,
 5:     idempotency_key text not null unique,
 6:     created_at timestamptz not null default now()
 7: );
 8: 
 9: create table if not exists public.cp_daily_kpis (
10:     id bigserial primary key,
11:     local_date date not null,
12:     metric_name text not null,
13:     metric_value numeric not null,
14:     created_at timestamptz not null default now()
15: );
16: 
17: create table if not exists public.cp_incidents (
18:     id bigserial primary key,
19:     incident_type text not null,
20:     severity text not null,
21:     details jsonb not null,
22:     opened_at timestamptz not null default now()
23: );
24: 
25: create table if not exists public.cp_worker_runs (
26:     id bigserial primary key,
27:     worker_name text not null,
28:     status text not null,
29:     details jsonb not null,
30:     created_at timestamptz not null default now()
31: );
````

## File: src/sync/supabaseSyncWorker.ts
````typescript
  1: import { createClient, SupabaseClient } from '@supabase/supabase-js';
  2: import { config } from '../config';
  3: import { sendTelegramAlert } from '../telemetry/alerts';
  4: import { logInfo, logWarn } from '../telemetry/logger';
  5: import {
  6:     countPendingOutboxEvents,
  7:     getPendingOutboxEvents,
  8:     markOutboxDelivered,
  9:     markOutboxPermanentFailure,
 10:     markOutboxRetry,
 11: } from '../core/repositories';
 12: 
 13: let client: SupabaseClient | null = null;
 14: 
 15: function getClient(): SupabaseClient | null {
 16:     if (!config.supabaseSyncEnabled) return null;
 17:     if (!config.supabaseUrl || !config.supabaseServiceRoleKey) return null;
 18:     if (!client) {
 19:         client = createClient(config.supabaseUrl, config.supabaseServiceRoleKey, {
 20:             auth: {
 21:                 persistSession: false,
 22:                 autoRefreshToken: false,
 23:             },
 24:         });
 25:     }
 26:     return client;
 27: }
 28: 
 29: function retryDelayMs(attempt: number): number {
 30:     const base = config.supabaseSyncIntervalMs;
 31:     const jitter = Math.floor(Math.random() * 500);
 32:     return base * Math.pow(2, Math.max(0, attempt - 1)) + jitter;
 33: }
 34: 
 35: function parseOutboxPayload(raw: string): Record<string, unknown> {
 36:     try {
 37:         const parsed = JSON.parse(raw) as unknown;
 38:         if (parsed && typeof parsed === 'object') {
 39:             return parsed as Record<string, unknown>;
 40:         }
 41:     } catch {
 42:         // fallback sotto
 43:     }
 44:     return { raw };
 45: }
 46: 
 47: export interface SyncStatus {
 48:     enabled: boolean;
 49:     configured: boolean;
 50:     pendingOutbox: number;
 51: }
 52: 
 53: export async function getSyncStatus(): Promise<SyncStatus> {
 54:     const pendingOutbox = await countPendingOutboxEvents();
 55:     return {
 56:         enabled: config.supabaseSyncEnabled,
 57:         configured: !!(config.supabaseUrl && config.supabaseServiceRoleKey),
 58:         pendingOutbox,
 59:     };
 60: }
 61: 
 62: export async function runSupabaseSyncOnce(): Promise<void> {
 63:     const supabase = getClient();
 64:     if (!supabase) {
 65:         return;
 66:     }
 67: 
 68:     const events = await getPendingOutboxEvents(config.supabaseSyncBatchSize);
 69:     if (events.length === 0) {
 70:         return;
 71:     }
 72: 
 73:     let sent = 0;
 74:     let failed = 0;
 75:     let permanentFailures = 0;
 76:     for (const event of events) {
 77:         const payload = {
 78:             topic: event.topic,
 79:             payload: parseOutboxPayload(event.payload_json),
 80:             idempotency_key: event.idempotency_key,
 81:             created_at: event.created_at,
 82:         };
 83: 
 84:         const { error } = await supabase.from('cp_events').upsert(payload, {
 85:             onConflict: 'idempotency_key',
 86:             ignoreDuplicates: false,
 87:         });
 88: 
 89:         if (error) {
 90:             failed += 1;
 91:             const attempts = event.attempts + 1;
 92:             if (attempts >= config.supabaseSyncMaxRetries) {
 93:                 permanentFailures += 1;
 94:                 await markOutboxPermanentFailure(event.id, attempts, error.message);
 95:                 await logWarn('supabase.sync.event.permanent_failure', {
 96:                     eventId: event.id,
 97:                     idempotencyKey: event.idempotency_key,
 98:                     attempts,
 99:                     maxRetries: config.supabaseSyncMaxRetries,
100:                     error: error.message,
101:                 });
102:             } else {
103:                 const delay = retryDelayMs(attempts);
104:                 await markOutboxRetry(event.id, attempts, delay, error.message);
105:             }
106:         } else {
107:             sent += 1;
108:             await markOutboxDelivered(event.id);
109:         }
110:     }
111: 
112:     await logInfo('supabase.sync.batch', {
113:         sent,
114:         failed,
115:         permanentFailures,
116:         batchSize: events.length,
117:         maxRetries: config.supabaseSyncMaxRetries,
118:     });
119: 
120:     const pending = await countPendingOutboxEvents();
121:     if (pending > config.outboxAlertBacklog) {
122:         await logWarn('supabase.sync.backlog_high', { pending, threshold: config.outboxAlertBacklog });
123:         await sendTelegramAlert(`Outbox backlog alto: ${pending} eventi pendenti`);
124:     }
125: }
````

## File: src/sync/webhookSyncWorker.ts
````typescript
  1: import { createHmac } from 'crypto';
  2: import { config } from '../config';
  3: import { sendTelegramAlert } from '../telemetry/alerts';
  4: import { logInfo, logWarn } from '../telemetry/logger';
  5: import {
  6:     countPendingOutboxEvents,
  7:     getPendingOutboxEvents,
  8:     markOutboxDelivered,
  9:     markOutboxPermanentFailure,
 10:     markOutboxRetry,
 11: } from '../core/repositories';
 12: 
 13: function retryDelayMs(attempt: number): number {
 14:     const base = config.supabaseSyncIntervalMs;
 15:     const jitter = Math.floor(Math.random() * 500);
 16:     return base * Math.pow(2, Math.max(0, attempt - 1)) + jitter;
 17: }
 18: 
 19: function parseOutboxPayload(raw: string): Record<string, unknown> {
 20:     try {
 21:         const parsed = JSON.parse(raw) as unknown;
 22:         if (parsed && typeof parsed === 'object') {
 23:             return parsed as Record<string, unknown>;
 24:         }
 25:     } catch {
 26:         // fallback sotto
 27:     }
 28:     return { raw };
 29: }
 30: 
 31: function buildWebhookSignature(payload: string): string | null {
 32:     const secret = config.webhookSyncSecret;
 33:     if (!secret) {
 34:         return null;
 35:     }
 36:     const signature = createHmac('sha256', secret).update(payload, 'utf8').digest('hex');
 37:     return `sha256=${signature}`;
 38: }
 39: 
 40: function endpointHost(rawUrl: string): string | null {
 41:     try {
 42:         return new URL(rawUrl).host;
 43:     } catch {
 44:         return null;
 45:     }
 46: }
 47: 
 48: export interface WebhookSyncStatus {
 49:     enabled: boolean;
 50:     configured: boolean;
 51:     pendingOutbox: number;
 52:     endpointHost: string | null;
 53: }
 54: 
 55: export async function getWebhookSyncStatus(): Promise<WebhookSyncStatus> {
 56:     const pendingOutbox = await countPendingOutboxEvents();
 57:     const configured = !!config.webhookSyncUrl;
 58:     return {
 59:         enabled: config.webhookSyncEnabled,
 60:         configured,
 61:         pendingOutbox,
 62:         endpointHost: configured ? endpointHost(config.webhookSyncUrl) : null,
 63:     };
 64: }
 65: 
 66: export async function runWebhookSyncOnce(): Promise<void> {
 67:     if (!config.webhookSyncEnabled || !config.webhookSyncUrl) {
 68:         return;
 69:     }
 70: 
 71:     const events = await getPendingOutboxEvents(config.webhookSyncBatchSize);
 72:     if (events.length === 0) {
 73:         return;
 74:     }
 75: 
 76:     let sent = 0;
 77:     let failed = 0;
 78:     let permanentFailures = 0;
 79: 
 80:     for (const event of events) {
 81:         const payload = {
 82:             topic: event.topic,
 83:             payload: parseOutboxPayload(event.payload_json),
 84:             idempotencyKey: event.idempotency_key,
 85:             createdAt: event.created_at,
 86:         };
 87: 
 88:         const body = JSON.stringify(payload);
 89:         const signature = buildWebhookSignature(body);
 90:         const headers: Record<string, string> = {
 91:             'content-type': 'application/json',
 92:             'x-idempotency-key': event.idempotency_key,
 93:             'x-event-topic': event.topic,
 94:         };
 95:         if (signature) {
 96:             headers['x-signature-sha256'] = signature;
 97:         }
 98: 
 99:         try {
100:             const response = await fetch(config.webhookSyncUrl, {
101:                 method: 'POST',
102:                 headers,
103:                 body,
104:                 signal: AbortSignal.timeout(config.webhookSyncTimeoutMs),
105:             });
106: 
107:             if (!response.ok) {
108:                 failed += 1;
109:                 const responseText = (await response.text().catch(() => '')).slice(0, 500);
110:                 const errorMessage = `HTTP_${response.status}:${response.statusText}${responseText ? `:${responseText}` : ''}`;
111:                 const attempts = event.attempts + 1;
112:                 if (attempts >= config.webhookSyncMaxRetries) {
113:                     permanentFailures += 1;
114:                     await markOutboxPermanentFailure(event.id, attempts, errorMessage);
115:                     await logWarn('webhook.sync.event.permanent_failure', {
116:                         eventId: event.id,
117:                         idempotencyKey: event.idempotency_key,
118:                         attempts,
119:                         maxRetries: config.webhookSyncMaxRetries,
120:                         error: errorMessage,
121:                     });
122:                 } else {
123:                     const delay = retryDelayMs(attempts);
124:                     await markOutboxRetry(event.id, attempts, delay, errorMessage);
125:                 }
126:                 continue;
127:             }
128: 
129:             sent += 1;
130:             await markOutboxDelivered(event.id);
131:         } catch (error) {
132:             failed += 1;
133:             const attempts = event.attempts + 1;
134:             const message = error instanceof Error ? error.message : String(error);
135:             if (attempts >= config.webhookSyncMaxRetries) {
136:                 permanentFailures += 1;
137:                 await markOutboxPermanentFailure(event.id, attempts, message);
138:                 await logWarn('webhook.sync.event.permanent_failure', {
139:                     eventId: event.id,
140:                     idempotencyKey: event.idempotency_key,
141:                     attempts,
142:                     maxRetries: config.webhookSyncMaxRetries,
143:                     error: message,
144:                 });
145:             } else {
146:                 const delay = retryDelayMs(attempts);
147:                 await markOutboxRetry(event.id, attempts, delay, message);
148:             }
149:         }
150:     }
151: 
152:     await logInfo('webhook.sync.batch', {
153:         sent,
154:         failed,
155:         permanentFailures,
156:         batchSize: events.length,
157:         maxRetries: config.webhookSyncMaxRetries,
158:         endpointHost: endpointHost(config.webhookSyncUrl),
159:     });
160: 
161:     const pending = await countPendingOutboxEvents();
162:     if (pending > config.outboxAlertBacklog) {
163:         await logWarn('webhook.sync.backlog_high', { pending, threshold: config.outboxAlertBacklog });
164:         await sendTelegramAlert(`Outbox backlog alto: ${pending} eventi pendenti`);
165:     }
166: }
````

## File: src/telemetry/alerts.ts
````typescript
 1: import { config } from '../config';
 2: 
 3: export async function sendTelegramAlert(message: string): Promise<void> {
 4:     if (!config.telegramBotToken || !config.telegramChatId) {
 5:         return;
 6:     }
 7: 
 8:     const endpoint = `https://api.telegram.org/bot${config.telegramBotToken}/sendMessage`;
 9:     try {
10:         await fetch(endpoint, {
11:             method: 'POST',
12:             headers: { 'Content-Type': 'application/json' },
13:             body: JSON.stringify({
14:                 chat_id: config.telegramChatId,
15:                 text: message,
16:                 disable_web_page_preview: true,
17:             }),
18:         });
19:     } catch (error) {
20:         console.error('[WARN] Invio alert Telegram fallito', error);
21:     }
22: }
````

## File: src/telemetry/logger.ts
````typescript
 1: import { recordRunLog } from '../core/repositories';
 2: import { sanitizeForLogs } from '../security/redaction';
 3: 
 4: export async function logInfo(event: string, payload: Record<string, unknown> = {}): Promise<void> {
 5:     const safePayload = sanitizeForLogs(payload);
 6:     console.log(`[INFO] ${event}`, safePayload);
 7:     await recordRunLog('INFO', event, safePayload);
 8: }
 9: 
10: export async function logWarn(event: string, payload: Record<string, unknown> = {}): Promise<void> {
11:     const safePayload = sanitizeForLogs(payload);
12:     console.warn(`[WARN] ${event}`, safePayload);
13:     await recordRunLog('WARN', event, safePayload);
14: }
15: 
16: export async function logError(event: string, payload: Record<string, unknown> = {}): Promise<void> {
17:     const safePayload = sanitizeForLogs(payload);
18:     console.error(`[ERROR] ${event}`, safePayload);
19:     await recordRunLog('ERROR', event, safePayload);
20: }
````

## File: src/tests/e2eDry.ts
````typescript
 1: import assert from 'assert';
 2: import fs from 'fs';
 3: import path from 'path';
 4: 
 5: async function run(): Promise<void> {
 6:     const testDbPath = path.resolve(process.cwd(), 'data', 'test_e2e_dry.sqlite');
 7:     if (fs.existsSync(testDbPath)) {
 8:         fs.unlinkSync(testDbPath);
 9:     }
10: 
11:     process.env.DB_PATH = testDbPath;
12:     process.env.SUPABASE_SYNC_ENABLED = 'false';
13:     process.env.SELECTOR_CANARY_ENABLED = 'false';
14:     process.env.HOUR_START = '0';
15:     process.env.HOUR_END = '24';
16: 
17:     const dbModule = await import('../db');
18:     const repositories = await import('../core/repositories');
19:     const scheduler = await import('../core/scheduler');
20: 
21:     await dbModule.initDatabase();
22: 
23:     await repositories.addLead({
24:         accountName: 'Dry Run Srl',
25:         firstName: 'Dry',
26:         lastName: 'Run',
27:         jobTitle: 'Test Lead',
28:         website: 'https://example.org',
29:         linkedinUrl: 'https://www.linkedin.com/in/dry-run-lead-test/',
30:         listName: 'dry-list',
31:     });
32:     await repositories.promoteNewLeadsToReadyInvite(10);
33: 
34:     const result = await scheduler.scheduleJobs('invite');
35:     assert.equal(result.queuedInviteJobs >= 1, true);
36:     assert.equal(result.localDate.length, 10);
37: 
38:     await dbModule.closeDatabase();
39:     if (fs.existsSync(testDbPath)) {
40:         fs.unlinkSync(testDbPath);
41:     }
42: }
43: 
44: run()
45:     .then(() => {
46:         console.log('Dry-run scenario passed.');
47:     })
48:     .catch((error) => {
49:         console.error(error);
50:         process.exit(1);
51:     });
````

## File: src/tests/integration.ts
````typescript
  1: import assert from 'assert';
  2: import fs from 'fs';
  3: import path from 'path';
  4: 
  5: async function run(): Promise<void> {
  6:     const testDbPath = path.resolve(process.cwd(), 'data', 'test_integration.sqlite');
  7:     if (fs.existsSync(testDbPath)) {
  8:         fs.unlinkSync(testDbPath);
  9:     }
 10: 
 11:     process.env.DB_PATH = testDbPath;
 12:     process.env.SUPABASE_SYNC_ENABLED = 'false';
 13:     process.env.SELECTOR_CANARY_ENABLED = 'false';
 14: 
 15:     const dbModule = await import('../db');
 16:     const repositories = await import('../core/repositories');
 17:     const stateService = await import('../core/leadStateService');
 18: 
 19:     await dbModule.initDatabase();
 20: 
 21:     const inserted = await repositories.addLead({
 22:         accountName: 'Rossi Srl',
 23:         firstName: 'Mario',
 24:         lastName: 'Rossi',
 25:         jobTitle: 'CEO',
 26:         website: 'https://example.com',
 27:         linkedinUrl: 'https://www.linkedin.com/in/mario-rossi-test/',
 28:         listName: 'test-list',
 29:     });
 30:     assert.equal(inserted, true);
 31: 
 32:     await repositories.promoteNewLeadsToReadyInvite(10);
 33:     const ready = await repositories.getLeadsByStatus('READY_INVITE', 10);
 34:     assert.equal(ready.length, 1);
 35: 
 36:     const lead = ready[0];
 37:     await stateService.transitionLead(lead.id, 'INVITED', 'integration_invite');
 38:     const invited = await repositories.getLeadsByStatus('INVITED', 10);
 39:     assert.equal(invited.length, 1);
 40: 
 41:     await stateService.reconcileLeadStatus(lead.id, 'READY_INVITE', 'integration_reconcile_back');
 42:     const readyAgain = await repositories.getLeadsByStatus('READY_INVITE', 10);
 43:     assert.equal(readyAgain.length, 1);
 44:     await stateService.transitionLead(lead.id, 'INVITED', 'integration_invite_again');
 45: 
 46:     const queued = await repositories.enqueueJob(
 47:         'INVITE',
 48:         { leadId: lead.id, localDate: '2026-02-24' },
 49:         `invite:${lead.id}:2026-02-24`,
 50:         10,
 51:         3
 52:     );
 53:     assert.equal(queued, true);
 54: 
 55:     const locked = await repositories.lockNextQueuedJob(['INVITE']);
 56:     assert.ok(locked);
 57:     if (!locked) {
 58:         throw new Error('Lock job fallito');
 59:     }
 60:     await repositories.markJobSucceeded(locked.id);
 61: 
 62:     const dailyInvites = await repositories.getDailyStat('2026-02-24', 'invites_sent');
 63:     assert.equal(dailyInvites, 0);
 64: 
 65:     const lockA = await repositories.acquireRuntimeLock('integration.runner.lock', 'owner-a', 5, { source: 'integration' });
 66:     assert.equal(lockA.acquired, true);
 67: 
 68:     const lockBBlocked = await repositories.acquireRuntimeLock('integration.runner.lock', 'owner-b', 5, { source: 'integration' });
 69:     assert.equal(lockBBlocked.acquired, false);
 70:     assert.equal(lockBBlocked.lock?.owner_id, 'owner-a');
 71: 
 72:     const heartbeatOk = await repositories.heartbeatRuntimeLock('integration.runner.lock', 'owner-a', 5);
 73:     assert.equal(heartbeatOk, true);
 74: 
 75:     const releasedByWrongOwner = await repositories.releaseRuntimeLock('integration.runner.lock', 'owner-b');
 76:     assert.equal(releasedByWrongOwner, false);
 77: 
 78:     const releasedByOwner = await repositories.releaseRuntimeLock('integration.runner.lock', 'owner-a');
 79:     assert.equal(releasedByOwner, true);
 80: 
 81:     const staleLock = await repositories.acquireRuntimeLock('integration.stale.lock', 'owner-a', 1, { source: 'integration' });
 82:     assert.equal(staleLock.acquired, true);
 83:     await new Promise((resolve) => setTimeout(resolve, 2100));
 84: 
 85:     const staleTakeover = await repositories.acquireRuntimeLock('integration.stale.lock', 'owner-b', 5, { source: 'integration' });
 86:     assert.equal(staleTakeover.acquired, true);
 87:     assert.equal(staleTakeover.lock?.owner_id, 'owner-b');
 88: 
 89:     const delayedQueued = await repositories.enqueueJob(
 90:         'INVITE',
 91:         { leadId: lead.id, localDate: '2026-02-24' },
 92:         `invite:${lead.id}:delayed`,
 93:         10,
 94:         3,
 95:         60
 96:     );
 97:     assert.equal(delayedQueued, true);
 98:     const delayedLocked = await repositories.lockNextQueuedJob(['INVITE']);
 99:     assert.equal(delayedLocked, null);
100: 
101:     await dbModule.closeDatabase();
102:     if (fs.existsSync(testDbPath)) {
103:         fs.unlinkSync(testDbPath);
104:     }
105: }
106: 
107: run()
108:     .then(() => {
109:         console.log('Integration tests passed.');
110:     })
111:     .catch((error) => {
112:         console.error(error);
113:         process.exit(1);
114:     });
````

## File: src/tests/unit.ts
````typescript
  1: import assert from 'assert';
  2: import { isValidLeadTransition } from '../core/leadStateService';
  3: import { calculateDynamicBudget, evaluateCooldownDecision, evaluateRisk } from '../risk/riskEngine';
  4: import { hashMessage, validateMessageContent } from '../validation/messageValidator';
  5: import { isProfileUrl, isSalesNavigatorUrl, normalizeLinkedInUrl } from '../linkedinUrl';
  6: import { buildPersonalizedFollowUpMessage } from '../ai/messagePersonalizer';
  7: import { evaluateAiGuardian } from '../ai/guardian';
  8: import { ScheduleResult } from '../core/scheduler';
  9: import { LeadRecord } from '../types/domain';
 10: 
 11: async function run(): Promise<void> {
 12:     assert.equal(isValidLeadTransition('NEW', 'READY_INVITE'), true);
 13:     assert.equal(isValidLeadTransition('READY_INVITE', 'INVITED'), true);
 14:     assert.equal(isValidLeadTransition('INVITED', 'MESSAGED'), false);
 15: 
 16:     const risk = evaluateRisk({
 17:         pendingRatio: 0.4,
 18:         errorRate: 0.1,
 19:         selectorFailureRate: 0.05,
 20:         challengeCount: 0,
 21:         inviteVelocityRatio: 0.3,
 22:     });
 23:     assert.equal(risk.action === 'NORMAL' || risk.action === 'WARN' || risk.action === 'STOP', true);
 24: 
 25:     const budgetNormal = calculateDynamicBudget(25, 35, 5, 'NORMAL');
 26:     const budgetWarn = calculateDynamicBudget(25, 35, 5, 'WARN');
 27:     assert.equal(budgetNormal > budgetWarn, true);
 28: 
 29:     const cooldownDecision = evaluateCooldownDecision({
 30:         ...risk,
 31:         action: 'WARN',
 32:         score: 72,
 33:         pendingRatio: 0.7,
 34:     });
 35:     assert.equal(cooldownDecision.activate, true);
 36:     assert.equal(cooldownDecision.minutes > 0, true);
 37: 
 38:     const goodMessage = 'Ciao Mario, grazie per il collegamento.';
 39:     const hash = hashMessage(goodMessage);
 40:     assert.equal(hash.length, 64);
 41:     const goodValidation = validateMessageContent(goodMessage, { duplicateCountLast24h: 0 });
 42:     assert.equal(goodValidation.valid, true);
 43: 
 44:     const badValidation = validateMessageContent('Ciao {{firstName}}', { duplicateCountLast24h: 5 });
 45:     assert.equal(badValidation.valid, false);
 46: 
 47:     assert.equal(isSalesNavigatorUrl('https://www.linkedin.com/sales/lead/ACwAA123,NAME_SEARCH/'), true);
 48:     assert.equal(isProfileUrl('https://www.linkedin.com/in/mario-rossi-123/'), true);
 49:     assert.equal(isProfileUrl('https://www.linkedin.com/sales/lead/ACwAA123,NAME_SEARCH/'), false);
 50:     assert.equal(
 51:         normalizeLinkedInUrl('https://it.linkedin.com/in/mario-rossi-123/detail/recent-activity/?trk=abc'),
 52:         'https://www.linkedin.com/in/mario-rossi-123/'
 53:     );
 54: 
 55:     const lead: LeadRecord = {
 56:         id: 99,
 57:         account_name: 'Demo Srl',
 58:         first_name: 'Mario',
 59:         last_name: 'Rossi',
 60:         job_title: 'CEO',
 61:         website: 'https://demo.example',
 62:         linkedin_url: 'https://www.linkedin.com/in/mario-rossi-123/',
 63:         status: 'READY_MESSAGE',
 64:         list_name: 'default',
 65:         invited_at: null,
 66:         accepted_at: null,
 67:         messaged_at: null,
 68:         last_error: null,
 69:         blocked_reason: null,
 70:         created_at: '2026-02-25T00:00:00.000Z',
 71:         updated_at: '2026-02-25T00:00:00.000Z',
 72:     };
 73:     const personalized = await buildPersonalizedFollowUpMessage(lead);
 74:     assert.equal(personalized.message.length > 0, true);
 75:     assert.equal(personalized.source === 'template' || personalized.source === 'ai', true);
 76: 
 77:     const schedule: ScheduleResult = {
 78:         localDate: '2026-02-25',
 79:         riskSnapshot: {
 80:             score: 40,
 81:             pendingRatio: 0.3,
 82:             errorRate: 0.05,
 83:             selectorFailureRate: 0.02,
 84:             challengeCount: 0,
 85:             inviteVelocityRatio: 0.2,
 86:             action: 'NORMAL',
 87:         },
 88:         inviteBudget: 10,
 89:         messageBudget: 10,
 90:         queuedInviteJobs: 5,
 91:         queuedCheckJobs: 4,
 92:         queuedMessageJobs: 3,
 93:         listBreakdown: [{
 94:             listName: 'default',
 95:             inviteBudget: 10,
 96:             messageBudget: 10,
 97:             queuedInviteJobs: 5,
 98:             queuedCheckJobs: 4,
 99:             queuedMessageJobs: 3,
100:             adaptiveFactor: 1,
101:             adaptiveReasons: [],
102:             pendingRatio: 0.3,
103:             blockedRatio: 0.1,
104:             maxScheduledDelaySec: 30,
105:         }],
106:         dryRun: false,
107:     };
108:     const guardian = await evaluateAiGuardian('all', schedule);
109:     assert.equal(guardian.decision !== null, true);
110: }
111: 
112: run()
113:     .then(() => {
114:         console.log('Unit tests passed.');
115:     })
116:     .catch((error) => {
117:         console.error(error);
118:         process.exit(1);
119:     });
````

## File: src/types/domain.ts
````typescript
  1: export type LeadStatus =
  2:     | 'NEW'
  3:     | 'READY_INVITE'
  4:     | 'INVITED'
  5:     | 'ACCEPTED'
  6:     | 'READY_MESSAGE'
  7:     | 'MESSAGED'
  8:     | 'SKIPPED'
  9:     | 'BLOCKED'
 10:     | 'PENDING'; // compat legacy
 11: 
 12: export type JobType = 'INVITE' | 'ACCEPTANCE_CHECK' | 'MESSAGE';
 13: 
 14: export type JobStatus = 'QUEUED' | 'RUNNING' | 'SUCCEEDED' | 'FAILED' | 'DEAD_LETTER' | 'PAUSED';
 15: 
 16: export interface LeadRecord {
 17:     id: number;
 18:     account_name: string;
 19:     first_name: string;
 20:     last_name: string;
 21:     job_title: string;
 22:     website: string;
 23:     linkedin_url: string;
 24:     status: LeadStatus;
 25:     list_name: string;
 26:     invited_at: string | null;
 27:     accepted_at: string | null;
 28:     messaged_at: string | null;
 29:     last_error: string | null;
 30:     blocked_reason: string | null;
 31:     created_at: string;
 32:     updated_at: string | null;
 33: }
 34: 
 35: export interface JobRecord {
 36:     id: number;
 37:     type: JobType;
 38:     status: JobStatus;
 39:     payload_json: string;
 40:     idempotency_key: string;
 41:     priority: number;
 42:     attempts: number;
 43:     max_attempts: number;
 44:     next_run_at: string;
 45:     locked_at: string | null;
 46:     last_error: string | null;
 47:     created_at: string;
 48:     updated_at: string | null;
 49: }
 50: 
 51: export interface InviteJobPayload {
 52:     leadId: number;
 53:     localDate: string;
 54: }
 55: 
 56: export interface AcceptanceJobPayload {
 57:     leadId: number;
 58: }
 59: 
 60: export interface MessageJobPayload {
 61:     leadId: number;
 62:     acceptedAtDate: string;
 63: }
 64: 
 65: export type JobPayload = InviteJobPayload | AcceptanceJobPayload | MessageJobPayload;
 66: 
 67: export interface RiskInputs {
 68:     pendingRatio: number;
 69:     errorRate: number;
 70:     selectorFailureRate: number;
 71:     challengeCount: number;
 72:     inviteVelocityRatio: number;
 73: }
 74: 
 75: export interface RiskSnapshot {
 76:     score: number;
 77:     pendingRatio: number;
 78:     errorRate: number;
 79:     selectorFailureRate: number;
 80:     challengeCount: number;
 81:     inviteVelocityRatio: number;
 82:     action: 'NORMAL' | 'WARN' | 'STOP';
 83: }
 84: 
 85: export interface IncidentRecord {
 86:     id: number;
 87:     type: string;
 88:     severity: 'INFO' | 'WARN' | 'CRITICAL';
 89:     status: 'OPEN' | 'ACK' | 'RESOLVED';
 90:     details_json: string;
 91:     opened_at: string;
 92:     acknowledged_at: string | null;
 93:     resolved_at: string | null;
 94: }
 95: 
 96: export interface OutboxEventRecord {
 97:     id: number;
 98:     topic: string;
 99:     payload_json: string;
100:     idempotency_key: string;
101:     attempts: number;
102:     next_retry_at: string;
103:     delivered_at: string | null;
104:     last_error: string | null;
105:     created_at: string;
106: }
107: 
108: export interface MessageValidationResult {
109:     valid: boolean;
110:     reasons: string[];
111: }
````

## File: src/validation/messageValidator.ts
````typescript
 1: import crypto from 'crypto';
 2: import { MessageValidationResult } from '../types/domain';
 3: 
 4: export interface MessageValidationContext {
 5:     duplicateCountLast24h: number;
 6:     maxLen?: number;
 7: }
 8: 
 9: export function extractUnresolvedPlaceholders(message: string): string[] {
10:     const matches = message.match(/\{\{[^}]+\}\}|\[[^\]]+\]/g);
11:     return matches ?? [];
12: }
13: 
14: export function hashMessage(message: string): string {
15:     return crypto.createHash('sha256').update(message).digest('hex');
16: }
17: 
18: export function validateMessageContent(message: string, context: MessageValidationContext): MessageValidationResult {
19:     const reasons: string[] = [];
20:     const trimmed = message.trim();
21:     const maxLen = context.maxLen ?? 550;
22: 
23:     if (!trimmed) {
24:         reasons.push('Messaggio vuoto.');
25:     }
26:     if (trimmed.length > maxLen) {
27:         reasons.push(`Messaggio troppo lungo (${trimmed.length}/${maxLen}).`);
28:     }
29:     const unresolved = extractUnresolvedPlaceholders(trimmed);
30:     if (unresolved.length > 0) {
31:         reasons.push(`Placeholder non risolti: ${unresolved.join(', ')}`);
32:     }
33:     if (context.duplicateCountLast24h >= 3) {
34:         reasons.push('Messaggio troppo ripetitivo nelle ultime 24h.');
35:     }
36: 
37:     return {
38:         valid: reasons.length === 0,
39:         reasons,
40:     };
41: }
````

## File: src/workers/acceptanceWorker.ts
````typescript
 1: import { detectChallenge, humanDelay } from '../browser';
 2: import { transitionLead } from '../core/leadStateService';
 3: import { getLeadById } from '../core/repositories';
 4: import { SELECTORS } from '../selectors';
 5: import { AcceptanceJobPayload } from '../types/domain';
 6: import { WorkerContext } from './context';
 7: import { ChallengeDetectedError } from './errors';
 8: import { isSalesNavigatorUrl } from '../linkedinUrl';
 9: 
10: function isFirstDegreeBadge(text: string | null): boolean {
11:     if (!text) return true;
12:     return /1st|1°|1\b/i.test(text);
13: }
14: 
15: export async function processAcceptanceJob(payload: AcceptanceJobPayload, context: WorkerContext): Promise<void> {
16:     const lead = await getLeadById(payload.leadId);
17:     if (!lead || lead.status !== 'INVITED') {
18:         return;
19:     }
20: 
21:     if (isSalesNavigatorUrl(lead.linkedin_url)) {
22:         await transitionLead(lead.id, 'BLOCKED', 'salesnav_url_requires_profile_check');
23:         return;
24:     }
25: 
26:     await context.session.page.goto(lead.linkedin_url, { waitUntil: 'domcontentloaded' });
27:     await humanDelay(context.session.page, 2000, 4000);
28: 
29:     if (await detectChallenge(context.session.page)) {
30:         throw new ChallengeDetectedError();
31:     }
32: 
33:     const msgBtn = context.session.page.locator(SELECTORS.messageButton).first();
34:     if (await msgBtn.count() === 0) {
35:         return;
36:     }
37: 
38:     const badgeText = await context.session.page.locator(SELECTORS.distanceBadge).first().textContent().catch(() => '');
39:     if (!isFirstDegreeBadge(badgeText)) {
40:         return;
41:     }
42: 
43:     await transitionLead(lead.id, 'ACCEPTED', 'acceptance_detected');
44:     await transitionLead(lead.id, 'READY_MESSAGE', 'message_queue_ready');
45: }
````

## File: src/workers/context.ts
````typescript
1: import { BrowserSession } from '../browser';
2: 
3: export interface WorkerContext {
4:     session: BrowserSession;
5:     dryRun: boolean;
6:     localDate: string;
7: }
````

## File: src/workers/errors.ts
````typescript
 1: export class RetryableWorkerError extends Error {
 2:     public readonly code: string;
 3: 
 4:     constructor(message: string, code: string = 'RETRYABLE') {
 5:         super(message);
 6:         this.name = 'RetryableWorkerError';
 7:         this.code = code;
 8:     }
 9: }
10: 
11: export class ChallengeDetectedError extends Error {
12:     constructor(message: string = 'Challenge/CAPTCHA rilevato') {
13:         super(message);
14:         this.name = 'ChallengeDetectedError';
15:     }
16: }
````

## File: src/workers/inviteWorker.ts
````typescript
  1: import { Page } from 'playwright';
  2: import { detectChallenge, humanDelay, simulateHumanReading } from '../browser';
  3: import { transitionLead } from '../core/leadStateService';
  4: import { getLeadById, incrementDailyStat, incrementListDailyStat } from '../core/repositories';
  5: import { SELECTORS } from '../selectors';
  6: import { InviteJobPayload } from '../types/domain';
  7: import { WorkerContext } from './context';
  8: import { ChallengeDetectedError, RetryableWorkerError } from './errors';
  9: import { isSalesNavigatorUrl } from '../linkedinUrl';
 10: 
 11: async function clickConnectOnProfile(page: Page): Promise<boolean> {
 12:     const primaryBtn = page.locator(SELECTORS.connectButtonPrimary).first();
 13:     if (await primaryBtn.count() > 0) {
 14:         await primaryBtn.click();
 15:         return true;
 16:     }
 17: 
 18:     const moreBtn = page.locator(SELECTORS.moreActionsButton).first();
 19:     if (await moreBtn.count() > 0) {
 20:         await moreBtn.click();
 21:         await humanDelay(page, 700, 1300);
 22:         const connectInMenu = page.locator(SELECTORS.connectInMoreMenu).first();
 23:         if (await connectInMenu.count() > 0) {
 24:             await connectInMenu.click();
 25:             return true;
 26:         }
 27:     }
 28: 
 29:     return false;
 30: }
 31: 
 32: async function detectInviteProof(page: Page): Promise<boolean> {
 33:     const pendingCount = await page.locator(SELECTORS.invitePendingIndicators).count();
 34:     if (pendingCount > 0) {
 35:         return true;
 36:     }
 37: 
 38:     const pageText = await page.textContent('body').catch(() => '');
 39:     if (!pageText) {
 40:         return false;
 41:     }
 42:     return /invitation sent|in attesa|pending/i.test(pageText);
 43: }
 44: 
 45: export async function processInviteJob(payload: InviteJobPayload, context: WorkerContext): Promise<void> {
 46:     const lead = await getLeadById(payload.leadId);
 47:     if (!lead) {
 48:         throw new RetryableWorkerError(`Lead ${payload.leadId} non trovato`, 'LEAD_NOT_FOUND');
 49:     }
 50: 
 51:     if (lead.status === 'NEW' || lead.status === 'PENDING') {
 52:         await transitionLead(lead.id, 'READY_INVITE', 'new_lead_promoted');
 53:     }
 54: 
 55:     if (lead.status !== 'READY_INVITE' && lead.status !== 'NEW' && lead.status !== 'PENDING') {
 56:         return;
 57:     }
 58: 
 59:     if (isSalesNavigatorUrl(lead.linkedin_url)) {
 60:         await transitionLead(lead.id, 'BLOCKED', 'salesnav_url_requires_profile_invite');
 61:         return;
 62:     }
 63: 
 64:     await context.session.page.goto(lead.linkedin_url, { waitUntil: 'domcontentloaded' });
 65:     await simulateHumanReading(context.session.page);
 66: 
 67:     if (await detectChallenge(context.session.page)) {
 68:         throw new ChallengeDetectedError();
 69:     }
 70: 
 71:     const connectClicked = await clickConnectOnProfile(context.session.page);
 72:     if (!connectClicked) {
 73:         await incrementDailyStat(context.localDate, 'selector_failures');
 74:         await transitionLead(lead.id, 'SKIPPED', 'connect_not_found');
 75:         return;
 76:     }
 77: 
 78:     await humanDelay(context.session.page, 900, 1800);
 79: 
 80:     if (!context.dryRun) {
 81:         const sendWithoutNote = context.session.page.locator(SELECTORS.sendWithoutNote).first();
 82:         if (await sendWithoutNote.count() > 0) {
 83:             await sendWithoutNote.click();
 84:         } else {
 85:             const fallback = context.session.page.locator(SELECTORS.sendFallback).first();
 86:             if (await fallback.count() > 0) {
 87:                 await fallback.click();
 88:             } else {
 89:                 await incrementDailyStat(context.localDate, 'selector_failures');
 90:                 throw new RetryableWorkerError('Conferma invito senza nota non trovata', 'SEND_BUTTON_NOT_FOUND');
 91:             }
 92:         }
 93:     }
 94: 
 95:     await humanDelay(context.session.page, 1200, 2200);
 96:     const proofOfSend = context.dryRun ? true : await detectInviteProof(context.session.page);
 97:     if (!proofOfSend) {
 98:         throw new RetryableWorkerError('Proof-of-send non rilevato', 'NO_PROOF_OF_SEND');
 99:     }
100: 
101:     await transitionLead(lead.id, 'INVITED', context.dryRun ? 'invite_dry_run' : 'invite_sent', {
102:         dryRun: context.dryRun,
103:     });
104:     await incrementDailyStat(context.localDate, 'invites_sent');
105:     await incrementListDailyStat(context.localDate, lead.list_name, 'invites_sent');
106: }
````

## File: src/workers/messageWorker.ts
````typescript
 1: import { detectChallenge, humanDelay, humanType } from '../browser';
 2: import { transitionLead } from '../core/leadStateService';
 3: import { countRecentMessageHash, getLeadById, incrementDailyStat, incrementListDailyStat, storeMessageHash } from '../core/repositories';
 4: import { SELECTORS } from '../selectors';
 5: import { MessageJobPayload } from '../types/domain';
 6: import { hashMessage, validateMessageContent } from '../validation/messageValidator';
 7: import { WorkerContext } from './context';
 8: import { ChallengeDetectedError, RetryableWorkerError } from './errors';
 9: import { isSalesNavigatorUrl } from '../linkedinUrl';
10: import { buildPersonalizedFollowUpMessage } from '../ai/messagePersonalizer';
11: import { logInfo } from '../telemetry/logger';
12: 
13: export async function processMessageJob(payload: MessageJobPayload, context: WorkerContext): Promise<void> {
14:     const lead = await getLeadById(payload.leadId);
15:     if (!lead || lead.status !== 'READY_MESSAGE') {
16:         return;
17:     }
18: 
19:     if (isSalesNavigatorUrl(lead.linkedin_url)) {
20:         await transitionLead(lead.id, 'BLOCKED', 'salesnav_url_requires_profile_message');
21:         return;
22:     }
23: 
24:     const personalized = await buildPersonalizedFollowUpMessage(lead);
25:     const message = personalized.message;
26:     const messageHash = hashMessage(message);
27:     const duplicateCount = await countRecentMessageHash(messageHash, 24);
28:     const validation = validateMessageContent(message, { duplicateCountLast24h: duplicateCount });
29:     if (!validation.valid) {
30:         await transitionLead(lead.id, 'BLOCKED', 'message_validation_failed', {
31:             reasons: validation.reasons,
32:         });
33:         return;
34:     }
35: 
36:     await context.session.page.goto(lead.linkedin_url, { waitUntil: 'domcontentloaded' });
37:     await humanDelay(context.session.page, 2500, 5000);
38: 
39:     if (await detectChallenge(context.session.page)) {
40:         throw new ChallengeDetectedError();
41:     }
42: 
43:     const msgBtn = context.session.page.locator(SELECTORS.messageButton).first();
44:     if (await msgBtn.count() === 0) {
45:         throw new RetryableWorkerError('Bottone messaggio non trovato', 'MESSAGE_BUTTON_NOT_FOUND');
46:     }
47: 
48:     await msgBtn.click();
49:     await humanDelay(context.session.page, 1200, 2200);
50: 
51:     const textbox = context.session.page.locator(SELECTORS.messageTextbox).first();
52:     if (await textbox.count() === 0) {
53:         await incrementDailyStat(context.localDate, 'selector_failures');
54:         throw new RetryableWorkerError('Textbox messaggio non trovata', 'TEXTBOX_NOT_FOUND');
55:     }
56:     await humanType(context.session.page, SELECTORS.messageTextbox, message);
57:     await humanDelay(context.session.page, 800, 1600);
58: 
59:     if (!context.dryRun) {
60:         const sendBtn = context.session.page.locator(SELECTORS.messageSendButton).first();
61:         if (await sendBtn.count() === 0 || (await sendBtn.isDisabled())) {
62:             await incrementDailyStat(context.localDate, 'selector_failures');
63:             throw new RetryableWorkerError('Bottone invio non disponibile', 'SEND_NOT_AVAILABLE');
64:         }
65:         await sendBtn.click();
66:     }
67: 
68:     await transitionLead(lead.id, 'MESSAGED', context.dryRun ? 'message_dry_run' : 'message_sent');
69:     await logInfo('message.generated', {
70:         leadId: lead.id,
71:         source: personalized.source,
72:         model: personalized.model,
73:         messageLength: message.length,
74:     });
75:     await storeMessageHash(lead.id, messageHash);
76:     await incrementDailyStat(context.localDate, 'messages_sent');
77:     await incrementListDailyStat(context.localDate, lead.list_name, 'messages_sent');
78: }
````

## File: tsconfig.json
````json
 1: {
 2:     "compilerOptions": {
 3:         "target": "ES2022",
 4:         "module": "CommonJS",
 5:         "outDir": "./dist",
 6:         "rootDir": "./src",
 7:         "strict": true,
 8:         "esModuleInterop": true,
 9:         "skipLibCheck": true,
10:         "forceConsistentCasingInFileNames": true,
11:         "resolveJsonModule": true
12:     },
13:     "include": [
14:         "src/**/*"
15:     ],
16:     "exclude": [
17:         "node_modules",
18:         "dist"
19:     ]
20: }
````
